<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","usr","local","rustup","toolchains","1.45.2-x86_64-unknown-linux-gnu","lib","rustlib","src","rust","src","libcore","fmt","mod.rs"],"content":"//! Utilities for formatting and printing strings.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::cell::{Cell, Ref, RefCell, RefMut, UnsafeCell};\nuse crate::marker::PhantomData;\nuse crate::mem;\nuse crate::num::flt2dec;\nuse crate::ops::Deref;\nuse crate::result;\nuse crate::str;\n\nmod builders;\nmod float;\nmod num;\n\n#[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n/// Possible alignments returned by `Formatter::align`\n#[derive(Debug)]\npub enum Alignment {\n    #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n    /// Indication that contents should be left-aligned.\n    Left,\n    #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n    /// Indication that contents should be right-aligned.\n    Right,\n    #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n    /// Indication that contents should be center-aligned.\n    Center,\n}\n\n#[stable(feature = \"debug_builders\", since = \"1.2.0\")]\npub use self::builders::{DebugList, DebugMap, DebugSet, DebugStruct, DebugTuple};\n\n#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n#[doc(hidden)]\npub mod rt {\n    pub mod v1;\n}\n\n/// The type returned by formatter methods.\n///\n/// # Examples\n///\n/// ```\n/// use std::fmt;\n///\n/// #[derive(Debug)]\n/// struct Triangle {\n///     a: f32,\n///     b: f32,\n///     c: f32\n/// }\n///\n/// impl fmt::Display for Triangle {\n///     fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n///         write!(f, \"({}, {}, {})\", self.a, self.b, self.c)\n///     }\n/// }\n///\n/// let pythagorean_triple = Triangle { a: 3.0, b: 4.0, c: 5.0 };\n///\n/// assert_eq!(format!(\"{}\", pythagorean_triple), \"(3, 4, 5)\");\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub type Result = result::Result\u003c(), Error\u003e;\n\n/// The error type which is returned from formatting a message into a stream.\n///\n/// This type does not support transmission of an error other than that an error\n/// occurred. Any extra information must be arranged to be transmitted through\n/// some other means.\n///\n/// An important thing to remember is that the type `fmt::Error` should not be\n/// confused with [`std::io::Error`] or [`std::error::Error`], which you may also\n/// have in scope.\n///\n/// [`std::io::Error`]: ../../std/io/struct.Error.html\n/// [`std::error::Error`]: ../../std/error/trait.Error.html\n///\n/// # Examples\n///\n/// ```rust\n/// use std::fmt::{self, write};\n///\n/// let mut output = String::new();\n/// if let Err(fmt::Error) = write(\u0026mut output, format_args!(\"Hello {}!\", \"world\")) {\n///     panic!(\"An error occurred\");\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]\npub struct Error;\n\n/// A collection of methods that are required to format a message into a stream.\n///\n/// This trait is the type which this modules requires when formatting\n/// information. This is similar to the standard library's [`io::Write`] trait,\n/// but it is only intended for use in libcore.\n///\n/// This trait should generally not be implemented by consumers of the standard\n/// library. The [`write!`] macro accepts an instance of [`io::Write`], and the\n/// [`io::Write`] trait is favored over implementing this trait.\n///\n/// [`write!`]: ../../std/macro.write.html\n/// [`io::Write`]: ../../std/io/trait.Write.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Write {\n    /// Writes a string slice into this writer, returning whether the write\n    /// succeeded.\n    ///\n    /// This method can only succeed if the entire string slice was successfully\n    /// written, and this method will not return until all data has been\n    /// written or an error occurs.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an instance of [`Error`] on error.\n    ///\n    /// [`Error`]: struct.Error.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt::{Error, Write};\n    ///\n    /// fn writer\u003cW: Write\u003e(f: \u0026mut W, s: \u0026str) -\u003e Result\u003c(), Error\u003e {\n    ///     f.write_str(s)\n    /// }\n    ///\n    /// let mut buf = String::new();\n    /// writer(\u0026mut buf, \"hola\").unwrap();\n    /// assert_eq!(\u0026buf, \"hola\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write_str(\u0026mut self, s: \u0026str) -\u003e Result;\n\n    /// Writes a [`char`] into this writer, returning whether the write succeeded.\n    ///\n    /// A single [`char`] may be encoded as more than one byte.\n    /// This method can only succeed if the entire byte sequence was successfully\n    /// written, and this method will not return until all data has been\n    /// written or an error occurs.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an instance of [`Error`] on error.\n    ///\n    /// [`char`]: ../../std/primitive.char.html\n    /// [`Error`]: struct.Error.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt::{Error, Write};\n    ///\n    /// fn writer\u003cW: Write\u003e(f: \u0026mut W, c: char) -\u003e Result\u003c(), Error\u003e {\n    ///     f.write_char(c)\n    /// }\n    ///\n    /// let mut buf = String::new();\n    /// writer(\u0026mut buf, 'a').unwrap();\n    /// writer(\u0026mut buf, 'b').unwrap();\n    /// assert_eq!(\u0026buf, \"ab\");\n    /// ```\n    #[stable(feature = \"fmt_write_char\", since = \"1.1.0\")]\n    fn write_char(\u0026mut self, c: char) -\u003e Result {\n        self.write_str(c.encode_utf8(\u0026mut [0; 4]))\n    }\n\n    /// Glue for usage of the [`write!`] macro with implementors of this trait.\n    ///\n    /// This method should generally not be invoked manually, but rather through\n    /// the [`write!`] macro itself.\n    ///\n    /// [`write!`]: ../../std/macro.write.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt::{Error, Write};\n    ///\n    /// fn writer\u003cW: Write\u003e(f: \u0026mut W, s: \u0026str) -\u003e Result\u003c(), Error\u003e {\n    ///     f.write_fmt(format_args!(\"{}\", s))\n    /// }\n    ///\n    /// let mut buf = String::new();\n    /// writer(\u0026mut buf, \"world\").unwrap();\n    /// assert_eq!(\u0026buf, \"world\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write_fmt(mut self: \u0026mut Self, args: Arguments\u003c'_\u003e) -\u003e Result {\n        write(\u0026mut self, args)\n    }\n}\n\n#[stable(feature = \"fmt_write_blanket_impl\", since = \"1.4.0\")]\nimpl\u003cW: Write + ?Sized\u003e Write for \u0026mut W {\n    fn write_str(\u0026mut self, s: \u0026str) -\u003e Result {\n        (**self).write_str(s)\n    }\n\n    fn write_char(\u0026mut self, c: char) -\u003e Result {\n        (**self).write_char(c)\n    }\n\n    fn write_fmt(\u0026mut self, args: Arguments\u003c'_\u003e) -\u003e Result {\n        (**self).write_fmt(args)\n    }\n}\n\n/// Configuration for formatting.\n///\n/// A `Formatter` represents various options related to formatting. Users do not\n/// construct `Formatter`s directly; a mutable reference to one is passed to\n/// the `fmt` method of all formatting traits, like [`Debug`] and [`Display`].\n///\n/// To interact with a `Formatter`, you'll call various methods to change the\n/// various options related to formatting. For examples, please see the\n/// documentation of the methods defined on `Formatter` below.\n///\n/// [`Debug`]: trait.Debug.html\n/// [`Display`]: trait.Display.html\n#[allow(missing_debug_implementations)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Formatter\u003c'a\u003e {\n    flags: u32,\n    fill: char,\n    align: rt::v1::Alignment,\n    width: Option\u003cusize\u003e,\n    precision: Option\u003cusize\u003e,\n\n    buf: \u0026'a mut (dyn Write + 'a),\n}\n\n// NB. Argument is essentially an optimized partially applied formatting function,\n// equivalent to `exists T.(\u0026T, fn(\u0026T, \u0026mut Formatter\u003c'_\u003e) -\u003e Result`.\n\nextern \"C\" {\n    type Opaque;\n}\n\n/// This struct represents the generic \"argument\" which is taken by the Xprintf\n/// family of functions. It contains a function to format the given value. At\n/// compile time it is ensured that the function and the value have the correct\n/// types, and then this struct is used to canonicalize arguments to one type.\n#[derive(Copy, Clone)]\n#[allow(missing_debug_implementations)]\n#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n#[doc(hidden)]\npub struct ArgumentV1\u003c'a\u003e {\n    value: \u0026'a Opaque,\n    formatter: fn(\u0026Opaque, \u0026mut Formatter\u003c'_\u003e) -\u003e Result,\n}\n\n// This guarantees a single stable value for the function pointer associated with\n// indices/counts in the formatting infrastructure.\n//\n// Note that a function defined as such would not be correct as functions are\n// always tagged unnamed_addr with the current lowering to LLVM IR, so their\n// address is not considered important to LLVM and as such the as_usize cast\n// could have been miscompiled. In practice, we never call as_usize on non-usize\n// containing data (as a matter of static generation of the formatting\n// arguments), so this is merely an additional check.\n//\n// We primarily want to ensure that the function pointer at `USIZE_MARKER` has\n// an address corresponding *only* to functions that also take `\u0026usize` as their\n// first argument. The read_volatile here ensures that we can safely ready out a\n// usize from the passed reference and that this address does not point at a\n// non-usize taking function.\n#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\nstatic USIZE_MARKER: fn(\u0026usize, \u0026mut Formatter\u003c'_\u003e) -\u003e Result = |ptr, _| {\n    // SAFETY: ptr is a reference\n    let _v: usize = unsafe { crate::ptr::read_volatile(ptr) };\n    loop {}\n};\n\nimpl\u003c'a\u003e ArgumentV1\u003c'a\u003e {\n    #[doc(hidden)]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n    pub fn new\u003c'b, T\u003e(x: \u0026'b T, f: fn(\u0026T, \u0026mut Formatter\u003c'_\u003e) -\u003e Result) -\u003e ArgumentV1\u003c'b\u003e {\n        // SAFETY: `mem::transmute(x)` is safe because\n        //     1. `\u0026'b T` keeps the lifetime it originated with `'b`\n        //              (so as to not have an unbounded lifetime)\n        //     2. `\u0026'b T` and `\u0026'b Opaque` have the same memory layout\n        //              (when `T` is `Sized`, as it is here)\n        // `mem::transmute(f)` is safe since `fn(\u0026T, \u0026mut Formatter\u003c'_\u003e) -\u003e Result`\n        // and `fn(\u0026Opaque, \u0026mut Formatter\u003c'_\u003e) -\u003e Result` have the same ABI\n        // (as long as `T` is `Sized`)\n        unsafe { ArgumentV1 { formatter: mem::transmute(f), value: mem::transmute(x) } }\n    }\n\n    #[doc(hidden)]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n    pub fn from_usize(x: \u0026usize) -\u003e ArgumentV1\u003c'_\u003e {\n        ArgumentV1::new(x, USIZE_MARKER)\n    }\n\n    fn as_usize(\u0026self) -\u003e Option\u003cusize\u003e {\n        if self.formatter as usize == USIZE_MARKER as usize {\n            // SAFETY: The `formatter` field is only set to USIZE_MARKER if\n            // the value is a usize, so this is safe\n            Some(unsafe { *(self.value as *const _ as *const usize) })\n        } else {\n            None\n        }\n    }\n}\n\n// flags available in the v1 format of format_args\n#[derive(Copy, Clone)]\nenum FlagV1 {\n    SignPlus,\n    SignMinus,\n    Alternate,\n    SignAwareZeroPad,\n    DebugLowerHex,\n    DebugUpperHex,\n}\n\nimpl\u003c'a\u003e Arguments\u003c'a\u003e {\n    /// When using the format_args!() macro, this function is used to generate the\n    /// Arguments structure.\n    #[doc(hidden)]\n    #[inline]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n    pub fn new_v1(pieces: \u0026'a [\u0026'a str], args: \u0026'a [ArgumentV1\u003c'a\u003e]) -\u003e Arguments\u003c'a\u003e {\n        Arguments { pieces, fmt: None, args }\n    }\n\n    /// This function is used to specify nonstandard formatting parameters.\n    /// The `pieces` array must be at least as long as `fmt` to construct\n    /// a valid Arguments structure. Also, any `Count` within `fmt` that is\n    /// `CountIsParam` or `CountIsNextParam` has to point to an argument\n    /// created with `argumentusize`. However, failing to do so doesn't cause\n    /// unsafety, but will ignore invalid .\n    #[doc(hidden)]\n    #[inline]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n    pub fn new_v1_formatted(\n        pieces: \u0026'a [\u0026'a str],\n        args: \u0026'a [ArgumentV1\u003c'a\u003e],\n        fmt: \u0026'a [rt::v1::Argument],\n    ) -\u003e Arguments\u003c'a\u003e {\n        Arguments { pieces, fmt: Some(fmt), args }\n    }\n\n    /// Estimates the length of the formatted text.\n    ///\n    /// This is intended to be used for setting initial `String` capacity\n    /// when using `format!`. Note: this is neither the lower nor upper bound.\n    #[doc(hidden)]\n    #[inline]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n    pub fn estimated_capacity(\u0026self) -\u003e usize {\n        let pieces_length: usize = self.pieces.iter().map(|x| x.len()).sum();\n\n        if self.args.is_empty() {\n            pieces_length\n        } else if self.pieces[0] == \"\" \u0026\u0026 pieces_length \u003c 16 {\n            // If the format string starts with an argument,\n            // don't preallocate anything, unless length\n            // of pieces is significant.\n            0\n        } else {\n            // There are some arguments, so any additional push\n            // will reallocate the string. To avoid that,\n            // we're \"pre-doubling\" the capacity here.\n            pieces_length.checked_mul(2).unwrap_or(0)\n        }\n    }\n}\n\n/// This structure represents a safely precompiled version of a format string\n/// and its arguments. This cannot be generated at runtime because it cannot\n/// safely be done, so no constructors are given and the fields are private\n/// to prevent modification.\n///\n/// The [`format_args!`] macro will safely create an instance of this structure.\n/// The macro validates the format string at compile-time so usage of the\n/// [`write`] and [`format`] functions can be safely performed.\n///\n/// You can use the `Arguments\u003c'a\u003e` that [`format_args!`] returns in `Debug`\n/// and `Display` contexts as seen below. The example also shows that `Debug`\n/// and `Display` format to the same thing: the interpolated format string\n/// in `format_args!`.\n///\n/// ```rust\n/// let debug = format!(\"{:?}\", format_args!(\"{} foo {:?}\", 1, 2));\n/// let display = format!(\"{}\", format_args!(\"{} foo {:?}\", 1, 2));\n/// assert_eq!(\"1 foo 2\", display);\n/// assert_eq!(display, debug);\n/// ```\n///\n/// [`format_args!`]: ../../std/macro.format_args.html\n/// [`format`]: ../../std/fmt/fn.format.html\n/// [`write`]: ../../std/fmt/fn.write.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Copy, Clone)]\npub struct Arguments\u003c'a\u003e {\n    // Format string pieces to print.\n    pieces: \u0026'a [\u0026'a str],\n\n    // Placeholder specs, or `None` if all specs are default (as in \"{}{}\").\n    fmt: Option\u003c\u0026'a [rt::v1::Argument]\u003e,\n\n    // Dynamic arguments for interpolation, to be interleaved with string\n    // pieces. (Every argument is preceded by a string piece.)\n    args: \u0026'a [ArgumentV1\u003c'a\u003e],\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Debug for Arguments\u003c'_\u003e {\n    fn fmt(\u0026self, fmt: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        Display::fmt(self, fmt)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Display for Arguments\u003c'_\u003e {\n    fn fmt(\u0026self, fmt: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        write(fmt.buf, *self)\n    }\n}\n\n/// `?` formatting.\n///\n/// `Debug` should format the output in a programmer-facing, debugging context.\n///\n/// Generally speaking, you should just `derive` a `Debug` implementation.\n///\n/// When used with the alternate format specifier `#?`, the output is pretty-printed.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// This trait can be used with `#[derive]` if all fields implement `Debug`. When\n/// `derive`d for structs, it will use the name of the `struct`, then `{`, then a\n/// comma-separated list of each field's name and `Debug` value, then `}`. For\n/// `enum`s, it will use the name of the variant and, if applicable, `(`, then the\n/// `Debug` values of the fields, then `)`.\n///\n/// # Stability\n///\n/// Derived `Debug` formats are not stable, and so may change with future Rust\n/// versions. Additionally, `Debug` implementations of types provided by the\n/// standard library (`libstd`, `libcore`, `liballoc`, etc.) are not stable, and\n/// may also change with future Rust versions.\n///\n/// # Examples\n///\n/// Deriving an implementation:\n///\n/// ```\n/// #[derive(Debug)]\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// let origin = Point { x: 0, y: 0 };\n///\n/// assert_eq!(format!(\"The origin is: {:?}\", origin), \"The origin is: Point { x: 0, y: 0 }\");\n/// ```\n///\n/// Manually implementing:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// impl fmt::Debug for Point {\n///     fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n///         f.debug_struct(\"Point\")\n///          .field(\"x\", \u0026self.x)\n///          .field(\"y\", \u0026self.y)\n///          .finish()\n///     }\n/// }\n///\n/// let origin = Point { x: 0, y: 0 };\n///\n/// assert_eq!(format!(\"The origin is: {:?}\", origin), \"The origin is: Point { x: 0, y: 0 }\");\n/// ```\n///\n/// There are a number of helper methods on the [`Formatter`] struct to help you with manual\n/// implementations, such as [`debug_struct`].\n///\n/// `Debug` implementations using either `derive` or the debug builder API\n/// on [`Formatter`] support pretty-printing using the alternate flag: `{:#?}`.\n///\n/// [`debug_struct`]: ../../std/fmt/struct.Formatter.html#method.debug_struct\n/// [`Formatter`]: ../../std/fmt/struct.Formatter.html\n///\n/// Pretty-printing with `#?`:\n///\n/// ```\n/// #[derive(Debug)]\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// let origin = Point { x: 0, y: 0 };\n///\n/// assert_eq!(format!(\"The origin is: {:#?}\", origin),\n/// \"The origin is: Point {\n///     x: 0,\n///     y: 0,\n/// }\");\n/// ```\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(\n    on(\n        crate_local,\n        label = \"`{Self}` cannot be formatted using `{{:?}}`\",\n        note = \"add `#[derive(Debug)]` or manually implement `{Debug}`\"\n    ),\n    message = \"`{Self}` doesn't implement `{Debug}`\",\n    label = \"`{Self}` cannot be formatted using `{{:?}}` because it doesn't implement `{Debug}`\"\n)]\n#[doc(alias = \"{:?}\")]\n#[rustc_diagnostic_item = \"debug_trait\"]\npub trait Debug {\n    /// Formats the value using the given formatter.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Position {\n    ///     longitude: f32,\n    ///     latitude: f32,\n    /// }\n    ///\n    /// impl fmt::Debug for Position {\n    ///     fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n    ///         f.debug_tuple(\"\")\n    ///          .field(\u0026self.longitude)\n    ///          .field(\u0026self.latitude)\n    ///          .finish()\n    ///     }\n    /// }\n    ///\n    /// let position = Position { longitude: 1.987, latitude: 2.983 };\n    /// assert_eq!(format!(\"{:?}\", position), \"(1.987, 2.983)\");\n    ///\n    /// assert_eq!(format!(\"{:#?}\", position), \"(\n    ///     1.987,\n    ///     2.983,\n    /// )\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result;\n}\n\n// Separate module to reexport the macro `Debug` from prelude without the trait `Debug`.\npub(crate) mod macros {\n    /// Derive macro generating an impl of the trait `Debug`.\n    #[rustc_builtin_macro]\n    #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n    #[allow_internal_unstable(core_intrinsics)]\n    pub macro Debug($item:item) {\n        /* compiler built-in */\n    }\n}\n#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n#[doc(inline)]\npub use macros::Debug;\n\n/// Format trait for an empty format, `{}`.\n///\n/// `Display` is similar to [`Debug`][debug], but `Display` is for user-facing\n/// output, and so cannot be derived.\n///\n/// [debug]: trait.Debug.html\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Implementing `Display` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// impl fmt::Display for Point {\n///     fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n///         write!(f, \"({}, {})\", self.x, self.y)\n///     }\n/// }\n///\n/// let origin = Point { x: 0, y: 0 };\n///\n/// assert_eq!(format!(\"The origin is: {}\", origin), \"The origin is: (0, 0)\");\n/// ```\n#[rustc_on_unimplemented(\n    on(\n        _Self = \"std::path::Path\",\n        label = \"`{Self}` cannot be formatted with the default formatter; call `.display()` on it\",\n        note = \"call `.display()` or `.to_string_lossy()` to safely print paths, \\\n                as they may contain non-Unicode data\"\n    ),\n    message = \"`{Self}` doesn't implement `{Display}`\",\n    label = \"`{Self}` cannot be formatted with the default formatter\",\n    note = \"in format strings you may be able to use `{{:?}}` (or {{:#?}} for pretty-print) instead\"\n)]\n#[doc(alias = \"{}\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Display {\n    /// Formats the value using the given formatter.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Position {\n    ///     longitude: f32,\n    ///     latitude: f32,\n    /// }\n    ///\n    /// impl fmt::Display for Position {\n    ///     fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n    ///         write!(f, \"({}, {})\", self.longitude, self.latitude)\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\"(1.987, 2.983)\",\n    ///            format!(\"{}\", Position { longitude: 1.987, latitude: 2.983, }));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result;\n}\n\n/// `o` formatting.\n///\n/// The `Octal` trait should format its output as a number in base-8.\n///\n/// For primitive signed integers (`i8` to `i128`, and `isize`),\n/// negative values are formatted as the two’s complement representation.\n///\n/// The alternate flag, `#`, adds a `0o` in front of the output.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `i32`:\n///\n/// ```\n/// let x = 42; // 42 is '52' in octal\n///\n/// assert_eq!(format!(\"{:o}\", x), \"52\");\n/// assert_eq!(format!(\"{:#o}\", x), \"0o52\");\n///\n/// assert_eq!(format!(\"{:o}\", -16), \"37777777760\");\n/// ```\n///\n/// Implementing `Octal` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::Octal for Length {\n///     fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n///         let val = self.0;\n///\n///         fmt::Octal::fmt(\u0026val, f) // delegate to i32's implementation\n///     }\n/// }\n///\n/// let l = Length(9);\n///\n/// assert_eq!(format!(\"l as octal is: {:o}\", l), \"l as octal is: 11\");\n///\n/// assert_eq!(format!(\"l as octal is: {:#06o}\", l), \"l as octal is: 0o0011\");\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Octal {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result;\n}\n\n/// `b` formatting.\n///\n/// The `Binary` trait should format its output as a number in binary.\n///\n/// For primitive signed integers ([`i8`] to [`i128`], and [`isize`]),\n/// negative values are formatted as the two’s complement representation.\n///\n/// The alternate flag, `#`, adds a `0b` in front of the output.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// # Examples\n///\n/// Basic usage with [`i32`]:\n///\n/// ```\n/// let x = 42; // 42 is '101010' in binary\n///\n/// assert_eq!(format!(\"{:b}\", x), \"101010\");\n/// assert_eq!(format!(\"{:#b}\", x), \"0b101010\");\n///\n/// assert_eq!(format!(\"{:b}\", -16), \"11111111111111111111111111110000\");\n/// ```\n///\n/// Implementing `Binary` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::Binary for Length {\n///     fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n///         let val = self.0;\n///\n///         fmt::Binary::fmt(\u0026val, f) // delegate to i32's implementation\n///     }\n/// }\n///\n/// let l = Length(107);\n///\n/// assert_eq!(format!(\"l as binary is: {:b}\", l), \"l as binary is: 1101011\");\n///\n/// assert_eq!(\n///     format!(\"l as binary is: {:#032b}\", l),\n///     \"l as binary is: 0b000000000000000000000001101011\"\n/// );\n/// ```\n///\n/// [module]: ../../std/fmt/index.html\n/// [`i8`]: ../../std/primitive.i8.html\n/// [`i128`]: ../../std/primitive.i128.html\n/// [`isize`]: ../../std/primitive.isize.html\n/// [`i32`]: ../../std/primitive.i32.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Binary {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result;\n}\n\n/// `x` formatting.\n///\n/// The `LowerHex` trait should format its output as a number in hexadecimal, with `a` through `f`\n/// in lower case.\n///\n/// For primitive signed integers (`i8` to `i128`, and `isize`),\n/// negative values are formatted as the two’s complement representation.\n///\n/// The alternate flag, `#`, adds a `0x` in front of the output.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `i32`:\n///\n/// ```\n/// let x = 42; // 42 is '2a' in hex\n///\n/// assert_eq!(format!(\"{:x}\", x), \"2a\");\n/// assert_eq!(format!(\"{:#x}\", x), \"0x2a\");\n///\n/// assert_eq!(format!(\"{:x}\", -16), \"fffffff0\");\n/// ```\n///\n/// Implementing `LowerHex` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::LowerHex for Length {\n///     fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n///         let val = self.0;\n///\n///         fmt::LowerHex::fmt(\u0026val, f) // delegate to i32's implementation\n///     }\n/// }\n///\n/// let l = Length(9);\n///\n/// assert_eq!(format!(\"l as hex is: {:x}\", l), \"l as hex is: 9\");\n///\n/// assert_eq!(format!(\"l as hex is: {:#010x}\", l), \"l as hex is: 0x00000009\");\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait LowerHex {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result;\n}\n\n/// `X` formatting.\n///\n/// The `UpperHex` trait should format its output as a number in hexadecimal, with `A` through `F`\n/// in upper case.\n///\n/// For primitive signed integers (`i8` to `i128`, and `isize`),\n/// negative values are formatted as the two’s complement representation.\n///\n/// The alternate flag, `#`, adds a `0x` in front of the output.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `i32`:\n///\n/// ```\n/// let x = 42; // 42 is '2A' in hex\n///\n/// assert_eq!(format!(\"{:X}\", x), \"2A\");\n/// assert_eq!(format!(\"{:#X}\", x), \"0x2A\");\n///\n/// assert_eq!(format!(\"{:X}\", -16), \"FFFFFFF0\");\n/// ```\n///\n/// Implementing `UpperHex` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::UpperHex for Length {\n///     fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n///         let val = self.0;\n///\n///         fmt::UpperHex::fmt(\u0026val, f) // delegate to i32's implementation\n///     }\n/// }\n///\n/// let l = Length(i32::MAX);\n///\n/// assert_eq!(format!(\"l as hex is: {:X}\", l), \"l as hex is: 7FFFFFFF\");\n///\n/// assert_eq!(format!(\"l as hex is: {:#010X}\", l), \"l as hex is: 0x7FFFFFFF\");\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait UpperHex {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result;\n}\n\n/// `p` formatting.\n///\n/// The `Pointer` trait should format its output as a memory location. This is commonly presented\n/// as hexadecimal.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `\u0026i32`:\n///\n/// ```\n/// let x = \u002642;\n///\n/// let address = format!(\"{:p}\", x); // this produces something like '0x7f06092ac6d0'\n/// ```\n///\n/// Implementing `Pointer` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::Pointer for Length {\n///     fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n///         // use `as` to convert to a `*const T`, which implements Pointer, which we can use\n///\n///         let ptr = self as *const Self;\n///         fmt::Pointer::fmt(\u0026ptr, f)\n///     }\n/// }\n///\n/// let l = Length(42);\n///\n/// println!(\"l is in memory here: {:p}\", l);\n///\n/// let l_ptr = format!(\"{:018p}\", l);\n/// assert_eq!(l_ptr.len(), 18);\n/// assert_eq!(\u0026l_ptr[..2], \"0x\");\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Pointer {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result;\n}\n\n/// `e` formatting.\n///\n/// The `LowerExp` trait should format its output in scientific notation with a lower-case `e`.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `f64`:\n///\n/// ```\n/// let x = 42.0; // 42.0 is '4.2e1' in scientific notation\n///\n/// assert_eq!(format!(\"{:e}\", x), \"4.2e1\");\n/// ```\n///\n/// Implementing `LowerExp` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::LowerExp for Length {\n///     fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n///         let val = f64::from(self.0);\n///         fmt::LowerExp::fmt(\u0026val, f) // delegate to f64's implementation\n///     }\n/// }\n///\n/// let l = Length(100);\n///\n/// assert_eq!(\n///     format!(\"l in scientific notation is: {:e}\", l),\n///     \"l in scientific notation is: 1e2\"\n/// );\n///\n/// assert_eq!(\n///     format!(\"l in scientific notation is: {:05e}\", l),\n///     \"l in scientific notation is: 001e2\"\n/// );\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait LowerExp {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result;\n}\n\n/// `E` formatting.\n///\n/// The `UpperExp` trait should format its output in scientific notation with an upper-case `E`.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `f64`:\n///\n/// ```\n/// let x = 42.0; // 42.0 is '4.2E1' in scientific notation\n///\n/// assert_eq!(format!(\"{:E}\", x), \"4.2E1\");\n/// ```\n///\n/// Implementing `UpperExp` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::UpperExp for Length {\n///     fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n///         let val = f64::from(self.0);\n///         fmt::UpperExp::fmt(\u0026val, f) // delegate to f64's implementation\n///     }\n/// }\n///\n/// let l = Length(100);\n///\n/// assert_eq!(\n///     format!(\"l in scientific notation is: {:E}\", l),\n///     \"l in scientific notation is: 1E2\"\n/// );\n///\n/// assert_eq!(\n///     format!(\"l in scientific notation is: {:05E}\", l),\n///     \"l in scientific notation is: 001E2\"\n/// );\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait UpperExp {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result;\n}\n\n/// The `write` function takes an output stream, and an `Arguments` struct\n/// that can be precompiled with the `format_args!` macro.\n///\n/// The arguments will be formatted according to the specified format string\n/// into the output stream provided.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::fmt;\n///\n/// let mut output = String::new();\n/// fmt::write(\u0026mut output, format_args!(\"Hello {}!\", \"world\"))\n///     .expect(\"Error occurred while trying to write in String\");\n/// assert_eq!(output, \"Hello world!\");\n/// ```\n///\n/// Please note that using [`write!`] might be preferable. Example:\n///\n/// ```\n/// use std::fmt::Write;\n///\n/// let mut output = String::new();\n/// write!(\u0026mut output, \"Hello {}!\", \"world\")\n///     .expect(\"Error occurred while trying to write in String\");\n/// assert_eq!(output, \"Hello world!\");\n/// ```\n///\n/// [`write!`]: ../../std/macro.write.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn write(output: \u0026mut dyn Write, args: Arguments\u003c'_\u003e) -\u003e Result {\n    let mut formatter = Formatter {\n        flags: 0,\n        width: None,\n        precision: None,\n        buf: output,\n        align: rt::v1::Alignment::Unknown,\n        fill: ' ',\n    };\n\n    let mut idx = 0;\n\n    match args.fmt {\n        None =\u003e {\n            // We can use default formatting parameters for all arguments.\n            for (arg, piece) in args.args.iter().zip(args.pieces.iter()) {\n                formatter.buf.write_str(*piece)?;\n                (arg.formatter)(arg.value, \u0026mut formatter)?;\n                idx += 1;\n            }\n        }\n        Some(fmt) =\u003e {\n            // Every spec has a corresponding argument that is preceded by\n            // a string piece.\n            for (arg, piece) in fmt.iter().zip(args.pieces.iter()) {\n                formatter.buf.write_str(*piece)?;\n                run(\u0026mut formatter, arg, \u0026args.args)?;\n                idx += 1;\n            }\n        }\n    }\n\n    // There can be only one trailing string piece left.\n    if let Some(piece) = args.pieces.get(idx) {\n        formatter.buf.write_str(*piece)?;\n    }\n\n    Ok(())\n}\n\nfn run(fmt: \u0026mut Formatter\u003c'_\u003e, arg: \u0026rt::v1::Argument, args: \u0026[ArgumentV1\u003c'_\u003e]) -\u003e Result {\n    fmt.fill = arg.format.fill;\n    fmt.align = arg.format.align;\n    fmt.flags = arg.format.flags;\n    fmt.width = getcount(args, \u0026arg.format.width);\n    fmt.precision = getcount(args, \u0026arg.format.precision);\n\n    // Extract the correct argument\n    let value = args[arg.position];\n\n    // Then actually do some printing\n    (value.formatter)(value.value, fmt)\n}\n\nfn getcount(args: \u0026[ArgumentV1\u003c'_\u003e], cnt: \u0026rt::v1::Count) -\u003e Option\u003cusize\u003e {\n    match *cnt {\n        rt::v1::Count::Is(n) =\u003e Some(n),\n        rt::v1::Count::Implied =\u003e None,\n        rt::v1::Count::Param(i) =\u003e args[i].as_usize(),\n    }\n}\n\n/// Padding after the end of something. Returned by `Formatter::padding`.\n#[must_use = \"don't forget to write the post padding\"]\nstruct PostPadding {\n    fill: char,\n    padding: usize,\n}\n\nimpl PostPadding {\n    fn new(fill: char, padding: usize) -\u003e PostPadding {\n        PostPadding { fill, padding }\n    }\n\n    /// Write this post padding.\n    fn write(self, buf: \u0026mut dyn Write) -\u003e Result {\n        for _ in 0..self.padding {\n            buf.write_char(self.fill)?;\n        }\n        Ok(())\n    }\n}\n\nimpl\u003c'a\u003e Formatter\u003c'a\u003e {\n    fn wrap_buf\u003c'b, 'c, F\u003e(\u0026'b mut self, wrap: F) -\u003e Formatter\u003c'c\u003e\n    where\n        'b: 'c,\n        F: FnOnce(\u0026'b mut (dyn Write + 'b)) -\u003e \u0026'c mut (dyn Write + 'c),\n    {\n        Formatter {\n            // We want to change this\n            buf: wrap(self.buf),\n\n            // And preserve these\n            flags: self.flags,\n            fill: self.fill,\n            align: self.align,\n            width: self.width,\n            precision: self.precision,\n        }\n    }\n\n    // Helper methods used for padding and processing formatting arguments that\n    // all formatting traits can use.\n\n    /// Performs the correct padding for an integer which has already been\n    /// emitted into a str. The str should *not* contain the sign for the\n    /// integer, that will be added by this method.\n    ///\n    /// # Arguments\n    ///\n    /// * is_nonnegative - whether the original integer was either positive or zero.\n    /// * prefix - if the '#' character (Alternate) is provided, this\n    ///   is the prefix to put in front of the number.\n    /// * buf - the byte array that the number has been formatted into\n    ///\n    /// This function will correctly account for the flags provided as well as\n    /// the minimum width. It will not take precision into account.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo { nb: i32 };\n    ///\n    /// impl Foo {\n    ///     fn new(nb: i32) -\u003e Foo {\n    ///         Foo {\n    ///             nb,\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         // We need to remove \"-\" from the number output.\n    ///         let tmp = self.nb.abs().to_string();\n    ///\n    ///         formatter.pad_integral(self.nb \u003e 0, \"Foo \", \u0026tmp)\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\u0026format!(\"{}\", Foo::new(2)), \"2\");\n    /// assert_eq!(\u0026format!(\"{}\", Foo::new(-1)), \"-1\");\n    /// assert_eq!(\u0026format!(\"{:#}\", Foo::new(-1)), \"-Foo 1\");\n    /// assert_eq!(\u0026format!(\"{:0\u003e#8}\", Foo::new(-1)), \"00-Foo 1\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn pad_integral(\u0026mut self, is_nonnegative: bool, prefix: \u0026str, buf: \u0026str) -\u003e Result {\n        let mut width = buf.len();\n\n        let mut sign = None;\n        if !is_nonnegative {\n            sign = Some('-');\n            width += 1;\n        } else if self.sign_plus() {\n            sign = Some('+');\n            width += 1;\n        }\n\n        let prefix = if self.alternate() {\n            width += prefix.chars().count();\n            Some(prefix)\n        } else {\n            None\n        };\n\n        // Writes the sign if it exists, and then the prefix if it was requested\n        #[inline(never)]\n        fn write_prefix(f: \u0026mut Formatter\u003c'_\u003e, sign: Option\u003cchar\u003e, prefix: Option\u003c\u0026str\u003e) -\u003e Result {\n            if let Some(c) = sign {\n                f.buf.write_char(c)?;\n            }\n            if let Some(prefix) = prefix { f.buf.write_str(prefix) } else { Ok(()) }\n        }\n\n        // The `width` field is more of a `min-width` parameter at this point.\n        match self.width {\n            // If there's no minimum length requirements then we can just\n            // write the bytes.\n            None =\u003e {\n                write_prefix(self, sign, prefix)?;\n                self.buf.write_str(buf)\n            }\n            // Check if we're over the minimum width, if so then we can also\n            // just write the bytes.\n            Some(min) if width \u003e= min =\u003e {\n                write_prefix(self, sign, prefix)?;\n                self.buf.write_str(buf)\n            }\n            // The sign and prefix goes before the padding if the fill character\n            // is zero\n            Some(min) if self.sign_aware_zero_pad() =\u003e {\n                let old_fill = crate::mem::replace(\u0026mut self.fill, '0');\n                let old_align = crate::mem::replace(\u0026mut self.align, rt::v1::Alignment::Right);\n                write_prefix(self, sign, prefix)?;\n                let post_padding = self.padding(min - width, rt::v1::Alignment::Right)?;\n                self.buf.write_str(buf)?;\n                post_padding.write(self.buf)?;\n                self.fill = old_fill;\n                self.align = old_align;\n                Ok(())\n            }\n            // Otherwise, the sign and prefix goes after the padding\n            Some(min) =\u003e {\n                let post_padding = self.padding(min - width, rt::v1::Alignment::Right)?;\n                write_prefix(self, sign, prefix)?;\n                self.buf.write_str(buf)?;\n                post_padding.write(self.buf)\n            }\n        }\n    }\n\n    /// This function takes a string slice and emits it to the internal buffer\n    /// after applying the relevant formatting flags specified. The flags\n    /// recognized for generic strings are:\n    ///\n    /// * width - the minimum width of what to emit\n    /// * fill/align - what to emit and where to emit it if the string\n    ///                provided needs to be padded\n    /// * precision - the maximum length to emit, the string is truncated if it\n    ///               is longer than this length\n    ///\n    /// Notably this function ignores the `flag` parameters.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo;\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         formatter.pad(\"Foo\")\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\u0026format!(\"{:\u003c4}\", Foo), \"Foo \");\n    /// assert_eq!(\u0026format!(\"{:0\u003e4}\", Foo), \"0Foo\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn pad(\u0026mut self, s: \u0026str) -\u003e Result {\n        // Make sure there's a fast path up front\n        if self.width.is_none() \u0026\u0026 self.precision.is_none() {\n            return self.buf.write_str(s);\n        }\n        // The `precision` field can be interpreted as a `max-width` for the\n        // string being formatted.\n        let s = if let Some(max) = self.precision {\n            // If our string is longer that the precision, then we must have\n            // truncation. However other flags like `fill`, `width` and `align`\n            // must act as always.\n            if let Some((i, _)) = s.char_indices().nth(max) {\n                // LLVM here can't prove that `..i` won't panic `\u0026s[..i]`, but\n                // we know that it can't panic. Use `get` + `unwrap_or` to avoid\n                // `unsafe` and otherwise don't emit any panic-related code\n                // here.\n                s.get(..i).unwrap_or(\u0026s)\n            } else {\n                \u0026s\n            }\n        } else {\n            \u0026s\n        };\n        // The `width` field is more of a `min-width` parameter at this point.\n        match self.width {\n            // If we're under the maximum length, and there's no minimum length\n            // requirements, then we can just emit the string\n            None =\u003e self.buf.write_str(s),\n            // If we're under the maximum width, check if we're over the minimum\n            // width, if so it's as easy as just emitting the string.\n            Some(width) if s.chars().count() \u003e= width =\u003e self.buf.write_str(s),\n            // If we're under both the maximum and the minimum width, then fill\n            // up the minimum width with the specified string + some alignment.\n            Some(width) =\u003e {\n                let align = rt::v1::Alignment::Left;\n                let post_padding = self.padding(width - s.chars().count(), align)?;\n                self.buf.write_str(s)?;\n                post_padding.write(self.buf)\n            }\n        }\n    }\n\n    /// Write the pre-padding and return the unwritten post-padding. Callers are\n    /// responsible for ensuring post-padding is written after the thing that is\n    /// being padded.\n    fn padding(\n        \u0026mut self,\n        padding: usize,\n        default: rt::v1::Alignment,\n    ) -\u003e result::Result\u003cPostPadding, Error\u003e {\n        let align = match self.align {\n            rt::v1::Alignment::Unknown =\u003e default,\n            _ =\u003e self.align,\n        };\n\n        let (pre_pad, post_pad) = match align {\n            rt::v1::Alignment::Left =\u003e (0, padding),\n            rt::v1::Alignment::Right | rt::v1::Alignment::Unknown =\u003e (padding, 0),\n            rt::v1::Alignment::Center =\u003e (padding / 2, (padding + 1) / 2),\n        };\n\n        for _ in 0..pre_pad {\n            self.buf.write_char(self.fill)?;\n        }\n\n        Ok(PostPadding::new(self.fill, post_pad))\n    }\n\n    /// Takes the formatted parts and applies the padding.\n    /// Assumes that the caller already has rendered the parts with required precision,\n    /// so that `self.precision` can be ignored.\n    fn pad_formatted_parts(\u0026mut self, formatted: \u0026flt2dec::Formatted\u003c'_\u003e) -\u003e Result {\n        if let Some(mut width) = self.width {\n            // for the sign-aware zero padding, we render the sign first and\n            // behave as if we had no sign from the beginning.\n            let mut formatted = formatted.clone();\n            let old_fill = self.fill;\n            let old_align = self.align;\n            let mut align = old_align;\n            if self.sign_aware_zero_pad() {\n                // a sign always goes first\n                let sign = formatted.sign;\n                self.buf.write_str(sign)?;\n\n                // remove the sign from the formatted parts\n                formatted.sign = \"\";\n                width = width.saturating_sub(sign.len());\n                align = rt::v1::Alignment::Right;\n                self.fill = '0';\n                self.align = rt::v1::Alignment::Right;\n            }\n\n            // remaining parts go through the ordinary padding process.\n            let len = formatted.len();\n            let ret = if width \u003c= len {\n                // no padding\n                self.write_formatted_parts(\u0026formatted)\n            } else {\n                let post_padding = self.padding(width - len, align)?;\n                self.write_formatted_parts(\u0026formatted)?;\n                post_padding.write(self.buf)\n            };\n            self.fill = old_fill;\n            self.align = old_align;\n            ret\n        } else {\n            // this is the common case and we take a shortcut\n            self.write_formatted_parts(formatted)\n        }\n    }\n\n    fn write_formatted_parts(\u0026mut self, formatted: \u0026flt2dec::Formatted\u003c'_\u003e) -\u003e Result {\n        fn write_bytes(buf: \u0026mut dyn Write, s: \u0026[u8]) -\u003e Result {\n            // SAFETY: This is used for `flt2dec::Part::Num` and `flt2dec::Part::Copy`.\n            // It's safe to use for `flt2dec::Part::Num` since every char `c` is between\n            // `b'0'` and `b'9'`, which means `s` is valid UTF-8.\n            // It's also probably safe in practice to use for `flt2dec::Part::Copy(buf)`\n            // since `buf` should be plain ASCII, but it's possible for someone to pass\n            // in a bad value for `buf` into `flt2dec::to_shortest_str` since it is a\n            // public function.\n            // FIXME: Determine whether this could result in UB.\n            buf.write_str(unsafe { str::from_utf8_unchecked(s) })\n        }\n\n        if !formatted.sign.is_empty() {\n            self.buf.write_str(formatted.sign)?;\n        }\n        for part in formatted.parts {\n            match *part {\n                flt2dec::Part::Zero(mut nzeroes) =\u003e {\n                    const ZEROES: \u0026str = // 64 zeroes\n                        \"0000000000000000000000000000000000000000000000000000000000000000\";\n                    while nzeroes \u003e ZEROES.len() {\n                        self.buf.write_str(ZEROES)?;\n                        nzeroes -= ZEROES.len();\n                    }\n                    if nzeroes \u003e 0 {\n                        self.buf.write_str(\u0026ZEROES[..nzeroes])?;\n                    }\n                }\n                flt2dec::Part::Num(mut v) =\u003e {\n                    let mut s = [0; 5];\n                    let len = part.len();\n                    for c in s[..len].iter_mut().rev() {\n                        *c = b'0' + (v % 10) as u8;\n                        v /= 10;\n                    }\n                    write_bytes(self.buf, \u0026s[..len])?;\n                }\n                flt2dec::Part::Copy(buf) =\u003e {\n                    write_bytes(self.buf, buf)?;\n                }\n            }\n        }\n        Ok(())\n    }\n\n    /// Writes some data to the underlying buffer contained within this\n    /// formatter.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo;\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         formatter.write_str(\"Foo\")\n    ///         // This is equivalent to:\n    ///         // write!(formatter, \"Foo\")\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\u0026format!(\"{}\", Foo), \"Foo\");\n    /// assert_eq!(\u0026format!(\"{:0\u003e8}\", Foo), \"Foo\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn write_str(\u0026mut self, data: \u0026str) -\u003e Result {\n        self.buf.write_str(data)\n    }\n\n    /// Writes some formatted information into this instance.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32);\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         formatter.write_fmt(format_args!(\"Foo {}\", self.0))\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\u0026format!(\"{}\", Foo(-1)), \"Foo -1\");\n    /// assert_eq!(\u0026format!(\"{:0\u003e8}\", Foo(2)), \"Foo 2\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn write_fmt(\u0026mut self, fmt: Arguments\u003c'_\u003e) -\u003e Result {\n        write(self.buf, fmt)\n    }\n\n    /// Flags for formatting\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_deprecated(\n        since = \"1.24.0\",\n        reason = \"use the `sign_plus`, `sign_minus`, `alternate`, \\\n                  or `sign_aware_zero_pad` methods instead\"\n    )]\n    pub fn flags(\u0026self) -\u003e u32 {\n        self.flags\n    }\n\n    /// Character used as 'fill' whenever there is alignment.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo;\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         let c = formatter.fill();\n    ///         if let Some(width) = formatter.width() {\n    ///             for _ in 0..width {\n    ///                 write!(formatter, \"{}\", c)?;\n    ///             }\n    ///             Ok(())\n    ///         } else {\n    ///             write!(formatter, \"{}\", c)\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// // We set alignment to the left with \"\u003e\".\n    /// assert_eq!(\u0026format!(\"{:G\u003e3}\", Foo), \"GGG\");\n    /// assert_eq!(\u0026format!(\"{:t\u003e6}\", Foo), \"tttttt\");\n    /// ```\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn fill(\u0026self) -\u003e char {\n        self.fill\n    }\n\n    /// Flag indicating what form of alignment was requested.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// extern crate core;\n    ///\n    /// use std::fmt::{self, Alignment};\n    ///\n    /// struct Foo;\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         let s = if let Some(s) = formatter.align() {\n    ///             match s {\n    ///                 Alignment::Left    =\u003e \"left\",\n    ///                 Alignment::Right   =\u003e \"right\",\n    ///                 Alignment::Center  =\u003e \"center\",\n    ///             }\n    ///         } else {\n    ///             \"into the void\"\n    ///         };\n    ///         write!(formatter, \"{}\", s)\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\u0026format!(\"{:\u003c}\", Foo), \"left\");\n    /// assert_eq!(\u0026format!(\"{:\u003e}\", Foo), \"right\");\n    /// assert_eq!(\u0026format!(\"{:^}\", Foo), \"center\");\n    /// assert_eq!(\u0026format!(\"{}\", Foo), \"into the void\");\n    /// ```\n    #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n    pub fn align(\u0026self) -\u003e Option\u003cAlignment\u003e {\n        match self.align {\n            rt::v1::Alignment::Left =\u003e Some(Alignment::Left),\n            rt::v1::Alignment::Right =\u003e Some(Alignment::Right),\n            rt::v1::Alignment::Center =\u003e Some(Alignment::Center),\n            rt::v1::Alignment::Unknown =\u003e None,\n        }\n    }\n\n    /// Optionally specified integer width that the output should be.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32);\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         if let Some(width) = formatter.width() {\n    ///             // If we received a width, we use it\n    ///             write!(formatter, \"{:width$}\", \u0026format!(\"Foo({})\", self.0), width = width)\n    ///         } else {\n    ///             // Otherwise we do nothing special\n    ///             write!(formatter, \"Foo({})\", self.0)\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\u0026format!(\"{:10}\", Foo(23)), \"Foo(23)   \");\n    /// assert_eq!(\u0026format!(\"{}\", Foo(23)), \"Foo(23)\");\n    /// ```\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn width(\u0026self) -\u003e Option\u003cusize\u003e {\n        self.width\n    }\n\n    /// Optionally specified precision for numeric types. Alternatively, the\n    /// maximum width for string types.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(f32);\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         if let Some(precision) = formatter.precision() {\n    ///             // If we received a precision, we use it.\n    ///             write!(formatter, \"Foo({1:.*})\", precision, self.0)\n    ///         } else {\n    ///             // Otherwise we default to 2.\n    ///             write!(formatter, \"Foo({:.2})\", self.0)\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\u0026format!(\"{:.4}\", Foo(23.2)), \"Foo(23.2000)\");\n    /// assert_eq!(\u0026format!(\"{}\", Foo(23.2)), \"Foo(23.20)\");\n    /// ```\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn precision(\u0026self) -\u003e Option\u003cusize\u003e {\n        self.precision\n    }\n\n    /// Determines if the `+` flag was specified.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32);\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         if formatter.sign_plus() {\n    ///             write!(formatter,\n    ///                    \"Foo({}{})\",\n    ///                    if self.0 \u003c 0 { '-' } else { '+' },\n    ///                    self.0)\n    ///         } else {\n    ///             write!(formatter, \"Foo({})\", self.0)\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\u0026format!(\"{:+}\", Foo(23)), \"Foo(+23)\");\n    /// assert_eq!(\u0026format!(\"{}\", Foo(23)), \"Foo(23)\");\n    /// ```\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn sign_plus(\u0026self) -\u003e bool {\n        self.flags \u0026 (1 \u003c\u003c FlagV1::SignPlus as u32) != 0\n    }\n\n    /// Determines if the `-` flag was specified.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32);\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         if formatter.sign_minus() {\n    ///             // You want a minus sign? Have one!\n    ///             write!(formatter, \"-Foo({})\", self.0)\n    ///         } else {\n    ///             write!(formatter, \"Foo({})\", self.0)\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\u0026format!(\"{:-}\", Foo(23)), \"-Foo(23)\");\n    /// assert_eq!(\u0026format!(\"{}\", Foo(23)), \"Foo(23)\");\n    /// ```\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn sign_minus(\u0026self) -\u003e bool {\n        self.flags \u0026 (1 \u003c\u003c FlagV1::SignMinus as u32) != 0\n    }\n\n    /// Determines if the `#` flag was specified.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32);\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         if formatter.alternate() {\n    ///             write!(formatter, \"Foo({})\", self.0)\n    ///         } else {\n    ///             write!(formatter, \"{}\", self.0)\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\u0026format!(\"{:#}\", Foo(23)), \"Foo(23)\");\n    /// assert_eq!(\u0026format!(\"{}\", Foo(23)), \"23\");\n    /// ```\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn alternate(\u0026self) -\u003e bool {\n        self.flags \u0026 (1 \u003c\u003c FlagV1::Alternate as u32) != 0\n    }\n\n    /// Determines if the `0` flag was specified.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32);\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         assert!(formatter.sign_aware_zero_pad());\n    ///         assert_eq!(formatter.width(), Some(4));\n    ///         // We ignore the formatter's options.\n    ///         write!(formatter, \"{}\", self.0)\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\u0026format!(\"{:04}\", Foo(23)), \"23\");\n    /// ```\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn sign_aware_zero_pad(\u0026self) -\u003e bool {\n        self.flags \u0026 (1 \u003c\u003c FlagV1::SignAwareZeroPad as u32) != 0\n    }\n\n    // FIXME: Decide what public API we want for these two flags.\n    // https://github.com/rust-lang/rust/issues/48584\n    fn debug_lower_hex(\u0026self) -\u003e bool {\n        self.flags \u0026 (1 \u003c\u003c FlagV1::DebugLowerHex as u32) != 0\n    }\n\n    fn debug_upper_hex(\u0026self) -\u003e bool {\n        self.flags \u0026 (1 \u003c\u003c FlagV1::DebugUpperHex as u32) != 0\n    }\n\n    /// Creates a [`DebugStruct`] builder designed to assist with creation of\n    /// [`fmt::Debug`] implementations for structs.\n    ///\n    /// [`DebugStruct`]: ../../std/fmt/struct.DebugStruct.html\n    /// [`fmt::Debug`]: ../../std/fmt/trait.Debug.html\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    /// use std::net::Ipv4Addr;\n    ///\n    /// struct Foo {\n    ///     bar: i32,\n    ///     baz: String,\n    ///     addr: Ipv4Addr,\n    /// }\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(\u0026self, fmt: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         fmt.debug_struct(\"Foo\")\n    ///             .field(\"bar\", \u0026self.bar)\n    ///             .field(\"baz\", \u0026self.baz)\n    ///             .field(\"addr\", \u0026format_args!(\"{}\", self.addr))\n    ///             .finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     \"Foo { bar: 10, baz: \\\"Hello World\\\", addr: 127.0.0.1 }\",\n    ///     format!(\"{:?}\", Foo {\n    ///         bar: 10,\n    ///         baz: \"Hello World\".to_string(),\n    ///         addr: Ipv4Addr::new(127, 0, 0, 1),\n    ///     })\n    /// );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn debug_struct\u003c'b\u003e(\u0026'b mut self, name: \u0026str) -\u003e DebugStruct\u003c'b, 'a\u003e {\n        builders::debug_struct_new(self, name)\n    }\n\n    /// Creates a `DebugTuple` builder designed to assist with creation of\n    /// `fmt::Debug` implementations for tuple structs.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    /// use std::marker::PhantomData;\n    ///\n    /// struct Foo\u003cT\u003e(i32, String, PhantomData\u003cT\u003e);\n    ///\n    /// impl\u003cT\u003e fmt::Debug for Foo\u003cT\u003e {\n    ///     fn fmt(\u0026self, fmt: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         fmt.debug_tuple(\"Foo\")\n    ///             .field(\u0026self.0)\n    ///             .field(\u0026self.1)\n    ///             .field(\u0026format_args!(\"_\"))\n    ///             .finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     \"Foo(10, \\\"Hello\\\", _)\",\n    ///     format!(\"{:?}\", Foo(10, \"Hello\".to_string(), PhantomData::\u003cu8\u003e))\n    /// );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn debug_tuple\u003c'b\u003e(\u0026'b mut self, name: \u0026str) -\u003e DebugTuple\u003c'b, 'a\u003e {\n        builders::debug_tuple_new(self, name)\n    }\n\n    /// Creates a `DebugList` builder designed to assist with creation of\n    /// `fmt::Debug` implementations for list-like structures.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec\u003ci32\u003e);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(\u0026self, fmt: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         fmt.debug_list().entries(self.0.iter()).finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(format!(\"{:?}\", Foo(vec![10, 11])), \"[10, 11]\");\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn debug_list\u003c'b\u003e(\u0026'b mut self) -\u003e DebugList\u003c'b, 'a\u003e {\n        builders::debug_list_new(self)\n    }\n\n    /// Creates a `DebugSet` builder designed to assist with creation of\n    /// `fmt::Debug` implementations for set-like structures.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec\u003ci32\u003e);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(\u0026self, fmt: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         fmt.debug_set().entries(self.0.iter()).finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(format!(\"{:?}\", Foo(vec![10, 11])), \"{10, 11}\");\n    /// ```\n    ///\n    /// [`format_args!`]: ../../std/macro.format_args.html\n    ///\n    /// In this more complex example, we use [`format_args!`] and `.debug_set()`\n    /// to build a list of match arms:\n    ///\n    /// ```rust\n    /// use std::fmt;\n    ///\n    /// struct Arm\u003c'a, L: 'a, R: 'a\u003e(\u0026'a (L, R));\n    /// struct Table\u003c'a, K: 'a, V: 'a\u003e(\u0026'a [(K, V)], V);\n    ///\n    /// impl\u003c'a, L, R\u003e fmt::Debug for Arm\u003c'a, L, R\u003e\n    /// where\n    ///     L: 'a + fmt::Debug, R: 'a + fmt::Debug\n    /// {\n    ///     fn fmt(\u0026self, fmt: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         L::fmt(\u0026(self.0).0, fmt)?;\n    ///         fmt.write_str(\" =\u003e \")?;\n    ///         R::fmt(\u0026(self.0).1, fmt)\n    ///     }\n    /// }\n    ///\n    /// impl\u003c'a, K, V\u003e fmt::Debug for Table\u003c'a, K, V\u003e\n    /// where\n    ///     K: 'a + fmt::Debug, V: 'a + fmt::Debug\n    /// {\n    ///     fn fmt(\u0026self, fmt: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         fmt.debug_set()\n    ///         .entries(self.0.iter().map(Arm))\n    ///         .entry(\u0026Arm(\u0026(format_args!(\"_\"), \u0026self.1)))\n    ///         .finish()\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn debug_set\u003c'b\u003e(\u0026'b mut self) -\u003e DebugSet\u003c'b, 'a\u003e {\n        builders::debug_set_new(self)\n    }\n\n    /// Creates a `DebugMap` builder designed to assist with creation of\n    /// `fmt::Debug` implementations for map-like structures.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec\u003c(String, i32)\u003e);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(\u0026self, fmt: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         fmt.debug_map().entries(self.0.iter().map(|\u0026(ref k, ref v)| (k, v))).finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     format!(\"{:?}\",  Foo(vec![(\"A\".to_string(), 10), (\"B\".to_string(), 11)])),\n    ///     r#\"{\"A\": 10, \"B\": 11}\"#\n    ///  );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn debug_map\u003c'b\u003e(\u0026'b mut self) -\u003e DebugMap\u003c'b, 'a\u003e {\n        builders::debug_map_new(self)\n    }\n}\n\n#[stable(since = \"1.2.0\", feature = \"formatter_write\")]\nimpl Write for Formatter\u003c'_\u003e {\n    fn write_str(\u0026mut self, s: \u0026str) -\u003e Result {\n        self.buf.write_str(s)\n    }\n\n    fn write_char(\u0026mut self, c: char) -\u003e Result {\n        self.buf.write_char(c)\n    }\n\n    fn write_fmt(\u0026mut self, args: Arguments\u003c'_\u003e) -\u003e Result {\n        write(self.buf, args)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Display for Error {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        Display::fmt(\"an error occurred when formatting an argument\", f)\n    }\n}\n\n// Implementations of the core formatting traits\n\nmacro_rules! fmt_refs {\n    ($($tr:ident),*) =\u003e {\n        $(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl\u003cT: ?Sized + $tr\u003e $tr for \u0026T {\n            fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result { $tr::fmt(\u0026**self, f) }\n        }\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl\u003cT: ?Sized + $tr\u003e $tr for \u0026mut T {\n            fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result { $tr::fmt(\u0026**self, f) }\n        }\n        )*\n    }\n}\n\nfmt_refs! { Debug, Display, Octal, Binary, LowerHex, UpperHex, LowerExp, UpperExp }\n\n#[unstable(feature = \"never_type\", issue = \"35121\")]\nimpl Debug for ! {\n    fn fmt(\u0026self, _: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        *self\n    }\n}\n\n#[unstable(feature = \"never_type\", issue = \"35121\")]\nimpl Display for ! {\n    fn fmt(\u0026self, _: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        *self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Debug for bool {\n    #[inline]\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        Display::fmt(self, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Display for bool {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        Display::fmt(if *self { \"true\" } else { \"false\" }, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Debug for str {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        f.write_char('\"')?;\n        let mut from = 0;\n        for (i, c) in self.char_indices() {\n            let esc = c.escape_debug();\n            // If char needs escaping, flush backlog so far and write, else skip\n            if esc.len() != 1 {\n                f.write_str(\u0026self[from..i])?;\n                for c in esc {\n                    f.write_char(c)?;\n                }\n                from = i + c.len_utf8();\n            }\n        }\n        f.write_str(\u0026self[from..])?;\n        f.write_char('\"')\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Display for str {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        f.pad(self)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Debug for char {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        f.write_char('\\'')?;\n        for c in self.escape_debug() {\n            f.write_char(c)?\n        }\n        f.write_char('\\'')\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Display for char {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        if f.width.is_none() \u0026\u0026 f.precision.is_none() {\n            f.write_char(*self)\n        } else {\n            f.pad(self.encode_utf8(\u0026mut [0; 4]))\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003cT: ?Sized\u003e Pointer for *const T {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        let old_width = f.width;\n        let old_flags = f.flags;\n\n        // The alternate flag is already treated by LowerHex as being special-\n        // it denotes whether to prefix with 0x. We use it to work out whether\n        // or not to zero extend, and then unconditionally set it to get the\n        // prefix.\n        if f.alternate() {\n            f.flags |= 1 \u003c\u003c (FlagV1::SignAwareZeroPad as u32);\n\n            if f.width.is_none() {\n                f.width = Some(((mem::size_of::\u003cusize\u003e() * 8) / 4) + 2);\n            }\n        }\n        f.flags |= 1 \u003c\u003c (FlagV1::Alternate as u32);\n\n        let ret = LowerHex::fmt(\u0026(*self as *const () as usize), f);\n\n        f.width = old_width;\n        f.flags = old_flags;\n\n        ret\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003cT: ?Sized\u003e Pointer for *mut T {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        Pointer::fmt(\u0026(*self as *const T), f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003cT: ?Sized\u003e Pointer for \u0026T {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        Pointer::fmt(\u0026(*self as *const T), f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003cT: ?Sized\u003e Pointer for \u0026mut T {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        Pointer::fmt(\u0026(\u0026**self as *const T), f)\n    }\n}\n\n// Implementation of Display/Debug for various core types\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003cT: ?Sized\u003e Debug for *const T {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        Pointer::fmt(self, f)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003cT: ?Sized\u003e Debug for *mut T {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        Pointer::fmt(self, f)\n    }\n}\n\nmacro_rules! peel {\n    ($name:ident, $($other:ident,)*) =\u003e (tuple! { $($other,)* })\n}\n\nmacro_rules! tuple {\n    () =\u003e ();\n    ( $($name:ident,)+ ) =\u003e (\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl\u003c$($name:Debug),+\u003e Debug for ($($name,)+) where last_type!($($name,)+): ?Sized {\n            #[allow(non_snake_case, unused_assignments)]\n            fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n                let mut builder = f.debug_tuple(\"\");\n                let ($(ref $name,)+) = *self;\n                $(\n                    builder.field(\u0026$name);\n                )+\n\n                builder.finish()\n            }\n        }\n        peel! { $($name,)+ }\n    )\n}\n\nmacro_rules! last_type {\n    ($a:ident,) =\u003e { $a };\n    ($a:ident, $($rest_a:ident,)+) =\u003e { last_type!($($rest_a,)+) };\n}\n\ntuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003cT: Debug\u003e Debug for [T] {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        f.debug_list().entries(self.iter()).finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Debug for () {\n    #[inline]\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        f.pad(\"()\")\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003cT: ?Sized\u003e Debug for PhantomData\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        f.pad(\"PhantomData\")\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003cT: Copy + Debug\u003e Debug for Cell\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        f.debug_struct(\"Cell\").field(\"value\", \u0026self.get()).finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003cT: ?Sized + Debug\u003e Debug for RefCell\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        match self.try_borrow() {\n            Ok(borrow) =\u003e f.debug_struct(\"RefCell\").field(\"value\", \u0026borrow).finish(),\n            Err(_) =\u003e {\n                // The RefCell is mutably borrowed so we can't look at its value\n                // here. Show a placeholder instead.\n                struct BorrowedPlaceholder;\n\n                impl Debug for BorrowedPlaceholder {\n                    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n                        f.write_str(\"\u003cborrowed\u003e\")\n                    }\n                }\n\n                f.debug_struct(\"RefCell\").field(\"value\", \u0026BorrowedPlaceholder).finish()\n            }\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003cT: ?Sized + Debug\u003e Debug for Ref\u003c'_, T\u003e {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        Debug::fmt(\u0026**self, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003cT: ?Sized + Debug\u003e Debug for RefMut\u003c'_, T\u003e {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        Debug::fmt(\u0026*(self.deref()), f)\n    }\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl\u003cT: ?Sized + Debug\u003e Debug for UnsafeCell\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        f.pad(\"UnsafeCell\")\n    }\n}\n\n// If you expected tests to be here, look instead at the ui/ifmt.rs test,\n// it's a lot easier than creating all of the rt::Piece structures here.\n","traces":[{"line":281,"address":[4212640,4212448,4212544,4212736],"length":1,"stats":{"Line":0},"fn_name":"new\u003c\u0026i32\u003e"},{"line":290,"address":[4212654,4212462,4212750,4212558],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[4212823,4212712,4212808,4212616,4212535,4212631,4212727,4212520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[4211344],"length":1,"stats":{"Line":0},"fn_name":"new_v1"},{"line":328,"address":[4211371],"length":1,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[4211416,4211411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1981,"address":[4212352,4212366,4212400,4212414],"length":1,"stats":{"Line":0},"fn_name":"fmt\u003cu32\u003e"}],"covered":0,"coverable":7},{"path":["/","usr","local","rustup","toolchains","1.45.2-x86_64-unknown-linux-gnu","lib","rustlib","src","rust","src","libcore","fmt","num.rs"],"content":"//! Integer and floating-point number formatting\n\nuse crate::fmt;\nuse crate::mem::MaybeUninit;\nuse crate::num::flt2dec;\nuse crate::ops::{Div, Rem, Sub};\nuse crate::ptr;\nuse crate::slice;\nuse crate::str;\n\n#[doc(hidden)]\ntrait Int:\n    PartialEq + PartialOrd + Div\u003cOutput = Self\u003e + Rem\u003cOutput = Self\u003e + Sub\u003cOutput = Self\u003e + Copy\n{\n    fn zero() -\u003e Self;\n    fn from_u8(u: u8) -\u003e Self;\n    fn to_u8(\u0026self) -\u003e u8;\n    fn to_u16(\u0026self) -\u003e u16;\n    fn to_u32(\u0026self) -\u003e u32;\n    fn to_u64(\u0026self) -\u003e u64;\n    fn to_u128(\u0026self) -\u003e u128;\n}\n\nmacro_rules! doit {\n    ($($t:ident)*) =\u003e ($(impl Int for $t {\n        fn zero() -\u003e Self { 0 }\n        fn from_u8(u: u8) -\u003e Self { u as Self }\n        fn to_u8(\u0026self) -\u003e u8 { *self as u8 }\n        fn to_u16(\u0026self) -\u003e u16 { *self as u16 }\n        fn to_u32(\u0026self) -\u003e u32 { *self as u32 }\n        fn to_u64(\u0026self) -\u003e u64 { *self as u64 }\n        fn to_u128(\u0026self) -\u003e u128 { *self as u128 }\n    })*)\n}\ndoit! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }\n\n/// A type that represents a specific radix\n#[doc(hidden)]\ntrait GenericRadix {\n    /// The number of digits.\n    const BASE: u8;\n\n    /// A radix-specific prefix string.\n    const PREFIX: \u0026'static str;\n\n    /// Converts an integer to corresponding radix digit.\n    fn digit(x: u8) -\u003e u8;\n\n    /// Format an integer using the radix using a formatter.\n    fn fmt_int\u003cT: Int\u003e(\u0026self, mut x: T, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        // The radix can be as low as 2, so we need a buffer of at least 128\n        // characters for a base 2 number.\n        let zero = T::zero();\n        let is_nonnegative = x \u003e= zero;\n        let mut buf = [MaybeUninit::\u003cu8\u003e::uninit(); 128];\n        let mut curr = buf.len();\n        let base = T::from_u8(Self::BASE);\n        if is_nonnegative {\n            // Accumulate each digit of the number from the least significant\n            // to the most significant figure.\n            for byte in buf.iter_mut().rev() {\n                let n = x % base; // Get the current place value.\n                x = x / base; // Deaccumulate the number.\n                byte.write(Self::digit(n.to_u8())); // Store the digit in the buffer.\n                curr -= 1;\n                if x == zero {\n                    // No more digits left to accumulate.\n                    break;\n                };\n            }\n        } else {\n            // Do the same as above, but accounting for two's complement.\n            for byte in buf.iter_mut().rev() {\n                let n = zero - (x % base); // Get the current place value.\n                x = x / base; // Deaccumulate the number.\n                byte.write(Self::digit(n.to_u8())); // Store the digit in the buffer.\n                curr -= 1;\n                if x == zero {\n                    // No more digits left to accumulate.\n                    break;\n                };\n            }\n        }\n        let buf = \u0026buf[curr..];\n        // SAFETY: The only chars in `buf` are created by `Self::digit` which are assumed to be\n        // valid UTF-8\n        let buf = unsafe {\n            str::from_utf8_unchecked(slice::from_raw_parts(MaybeUninit::first_ptr(buf), buf.len()))\n        };\n        f.pad_integral(is_nonnegative, Self::PREFIX, buf)\n    }\n}\n\n/// A binary (base 2) radix\n#[derive(Clone, PartialEq)]\nstruct Binary;\n\n/// An octal (base 8) radix\n#[derive(Clone, PartialEq)]\nstruct Octal;\n\n/// A hexadecimal (base 16) radix, formatted with lower-case characters\n#[derive(Clone, PartialEq)]\nstruct LowerHex;\n\n/// A hexadecimal (base 16) radix, formatted with upper-case characters\n#[derive(Clone, PartialEq)]\nstruct UpperHex;\n\nmacro_rules! radix {\n    ($T:ident, $base:expr, $prefix:expr, $($x:pat =\u003e $conv:expr),+) =\u003e {\n        impl GenericRadix for $T {\n            const BASE: u8 = $base;\n            const PREFIX: \u0026'static str = $prefix;\n            fn digit(x: u8) -\u003e u8 {\n                match x {\n                    $($x =\u003e $conv,)+\n                    x =\u003e panic!(\"number not in the range 0..={}: {}\", Self::BASE - 1, x),\n                }\n            }\n        }\n    }\n}\n\nradix! { Binary,    2, \"0b\", x @  0 ..=  1 =\u003e b'0' + x }\nradix! { Octal,     8, \"0o\", x @  0 ..=  7 =\u003e b'0' + x }\nradix! { LowerHex, 16, \"0x\", x @  0 ..=  9 =\u003e b'0' + x,\nx @ 10 ..= 15 =\u003e b'a' + (x - 10) }\nradix! { UpperHex, 16, \"0x\", x @  0 ..=  9 =\u003e b'0' + x,\nx @ 10 ..= 15 =\u003e b'A' + (x - 10) }\n\nmacro_rules! int_base {\n    ($Trait:ident for $T:ident as $U:ident -\u003e $Radix:ident) =\u003e {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl fmt::$Trait for $T {\n            fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                $Radix.fmt_int(*self as $U, f)\n            }\n        }\n    };\n}\n\nmacro_rules! debug {\n    ($T:ident) =\u003e {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl fmt::Debug for $T {\n            #[inline]\n            fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                if f.debug_lower_hex() {\n                    fmt::LowerHex::fmt(self, f)\n                } else if f.debug_upper_hex() {\n                    fmt::UpperHex::fmt(self, f)\n                } else {\n                    fmt::Display::fmt(self, f)\n                }\n            }\n        }\n    };\n}\n\nmacro_rules! integer {\n    ($Int:ident, $Uint:ident) =\u003e {\n        int_base! { Binary   for $Int as $Uint  -\u003e Binary }\n        int_base! { Octal    for $Int as $Uint  -\u003e Octal }\n        int_base! { LowerHex for $Int as $Uint  -\u003e LowerHex }\n        int_base! { UpperHex for $Int as $Uint  -\u003e UpperHex }\n        debug! { $Int }\n\n        int_base! { Binary   for $Uint as $Uint -\u003e Binary }\n        int_base! { Octal    for $Uint as $Uint -\u003e Octal }\n        int_base! { LowerHex for $Uint as $Uint -\u003e LowerHex }\n        int_base! { UpperHex for $Uint as $Uint -\u003e UpperHex }\n        debug! { $Uint }\n    };\n}\ninteger! { isize, usize }\ninteger! { i8, u8 }\ninteger! { i16, u16 }\ninteger! { i32, u32 }\ninteger! { i64, u64 }\ninteger! { i128, u128 }\n\nstatic DEC_DIGITS_LUT: \u0026[u8; 200] = b\"0001020304050607080910111213141516171819\\\n      2021222324252627282930313233343536373839\\\n      4041424344454647484950515253545556575859\\\n      6061626364656667686970717273747576777879\\\n      8081828384858687888990919293949596979899\";\n\nmacro_rules! impl_Display {\n    ($($t:ident),* as $u:ident via $conv_fn:ident named $name:ident) =\u003e {\n        fn $name(mut n: $u, is_nonnegative: bool, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n            // 2^128 is about 3*10^38, so 39 gives an extra byte of space\n            let mut buf = [MaybeUninit::\u003cu8\u003e::uninit(); 39];\n            let mut curr = buf.len() as isize;\n            let buf_ptr = MaybeUninit::first_ptr_mut(\u0026mut buf);\n            let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n\n            // SAFETY: Since `d1` and `d2` are always less than or equal to `198`, we\n            // can copy from `lut_ptr[d1..d1 + 1]` and `lut_ptr[d2..d2 + 1]`. To show\n            // that it's OK to copy into `buf_ptr`, notice that at the beginning\n            // `curr == buf.len() == 39 \u003e log(n)` since `n \u003c 2^128 \u003c 10^39`, and at\n            // each step this is kept the same as `n` is divided. Since `n` is always\n            // non-negative, this means that `curr \u003e 0` so `buf_ptr[curr..curr + 1]`\n            // is safe to access.\n            unsafe {\n                // need at least 16 bits for the 4-characters-at-a-time to work.\n                assert!(crate::mem::size_of::\u003c$u\u003e() \u003e= 2);\n\n                // eagerly decode 4 characters at a time\n                while n \u003e= 10000 {\n                    let rem = (n % 10000) as isize;\n                    n /= 10000;\n\n                    let d1 = (rem / 100) \u003c\u003c 1;\n                    let d2 = (rem % 100) \u003c\u003c 1;\n                    curr -= 4;\n\n                    // We are allowed to copy to `buf_ptr[curr..curr + 3]` here since\n                    // otherwise `curr \u003c 0`. But then `n` was originally at least `10000^10`\n                    // which is `10^40 \u003e 2^128 \u003e n`.\n                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                    ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\n                }\n\n                // if we reach here numbers are \u003c= 9999, so at most 4 chars long\n                let mut n = n as isize; // possibly reduce 64bit math\n\n                // decode 2 more chars, if \u003e 2 chars\n                if n \u003e= 100 {\n                    let d1 = (n % 100) \u003c\u003c 1;\n                    n /= 100;\n                    curr -= 2;\n                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                }\n\n                // decode last 1 or 2 chars\n                if n \u003c 10 {\n                    curr -= 1;\n                    *buf_ptr.offset(curr) = (n as u8) + b'0';\n                } else {\n                    let d1 = n \u003c\u003c 1;\n                    curr -= 2;\n                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                }\n            }\n\n            // SAFETY: `curr` \u003e 0 (since we made `buf` large enough), and all the chars are valid\n            // UTF-8 since `DEC_DIGITS_LUT` is\n            let buf_slice = unsafe {\n                str::from_utf8_unchecked(\n                    slice::from_raw_parts(buf_ptr.offset(curr), buf.len() - curr as usize))\n            };\n            f.pad_integral(is_nonnegative, \"\", buf_slice)\n        }\n\n        $(\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl fmt::Display for $t {\n                #[allow(unused_comparisons)]\n                fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                    let is_nonnegative = *self \u003e= 0;\n                    let n = if is_nonnegative {\n                        self.$conv_fn()\n                    } else {\n                        // convert the negative num to positive by summing 1 to it's 2 complement\n                        (!self.$conv_fn()).wrapping_add(1)\n                    };\n                    $name(n, is_nonnegative, f)\n                }\n            })*\n    };\n}\n\nmacro_rules! impl_Exp {\n    ($($t:ident),* as $u:ident via $conv_fn:ident named $name:ident) =\u003e {\n        fn $name(\n            mut n: $u,\n            is_nonnegative: bool,\n            upper: bool,\n            f: \u0026mut fmt::Formatter\u003c'_\u003e\n        ) -\u003e fmt::Result {\n            let (mut n, mut exponent, trailing_zeros, added_precision) = {\n                let mut exponent = 0;\n                // count and remove trailing decimal zeroes\n                while n % 10 == 0 \u0026\u0026 n \u003e= 10 {\n                    n /= 10;\n                    exponent += 1;\n                }\n                let trailing_zeros = exponent;\n\n                let (added_precision, subtracted_precision) = match f.precision() {\n                    Some(fmt_prec) =\u003e {\n                        // number of decimal digits minus 1\n                        let mut tmp = n;\n                        let mut prec = 0;\n                        while tmp \u003e= 10 {\n                            tmp /= 10;\n                            prec += 1;\n                        }\n                        (fmt_prec.saturating_sub(prec), prec.saturating_sub(fmt_prec))\n                    }\n                    None =\u003e (0,0)\n                };\n                for _ in 1..subtracted_precision {\n                    n/=10;\n                    exponent += 1;\n                }\n                if subtracted_precision != 0 {\n                    let rem = n % 10;\n                    n /= 10;\n                    exponent += 1;\n                    // round up last digit\n                    if rem \u003e= 5 {\n                        n += 1;\n                    }\n                }\n                (n, exponent, trailing_zeros, added_precision)\n            };\n\n            // 39 digits (worst case u128) + . = 40\n            // Since `curr` always decreases by the number of digits copied, this means\n            // that `curr \u003e= 0`.\n            let mut buf = [MaybeUninit::\u003cu8\u003e::uninit(); 40];\n            let mut curr = buf.len() as isize; //index for buf\n            let buf_ptr = MaybeUninit::first_ptr_mut(\u0026mut buf);\n            let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n\n            // decode 2 chars at a time\n            while n \u003e= 100 {\n                let d1 = ((n % 100) as isize) \u003c\u003c 1;\n                curr -= 2;\n                // SAFETY: `d1 \u003c= 198`, so we can copy from `lut_ptr[d1..d1 + 2]` since\n                // `DEC_DIGITS_LUT` has a length of 200.\n                unsafe {\n                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                }\n                n /= 100;\n                exponent += 2;\n            }\n            // n is \u003c= 99, so at most 2 chars long\n            let mut n = n as isize; // possibly reduce 64bit math\n            // decode second-to-last character\n            if n \u003e= 10 {\n                curr -= 1;\n                // SAFETY: Safe since `40 \u003e curr \u003e= 0` (see comment)\n                unsafe {\n                    *buf_ptr.offset(curr) = (n as u8 % 10_u8) + b'0';\n                }\n                n /= 10;\n                exponent += 1;\n            }\n            // add decimal point iff \u003e1 mantissa digit will be printed\n            if exponent != trailing_zeros || added_precision != 0 {\n                curr -= 1;\n                // SAFETY: Safe since `40 \u003e curr \u003e= 0`\n                unsafe {\n                    *buf_ptr.offset(curr) = b'.';\n                }\n            }\n\n            // SAFETY: Safe since `40 \u003e curr \u003e= 0`\n            let buf_slice = unsafe {\n                // decode last character\n                curr -= 1;\n                *buf_ptr.offset(curr) = (n as u8) + b'0';\n\n                let len = buf.len() - curr as usize;\n                slice::from_raw_parts(buf_ptr.offset(curr), len)\n            };\n\n            // stores 'e' (or 'E') and the up to 2-digit exponent\n            let mut exp_buf = [MaybeUninit::\u003cu8\u003e::uninit(); 3];\n            let exp_ptr = MaybeUninit::first_ptr_mut(\u0026mut exp_buf);\n            // SAFETY: In either case, `exp_buf` is written within bounds and `exp_ptr[..len]`\n            // is contained within `exp_buf` since `len \u003c= 3`.\n            let exp_slice = unsafe {\n                *exp_ptr.offset(0) = if upper {b'E'} else {b'e'};\n                let len = if exponent \u003c 10 {\n                    *exp_ptr.offset(1) = (exponent as u8) + b'0';\n                    2\n                } else {\n                    let off = exponent \u003c\u003c 1;\n                    ptr::copy_nonoverlapping(lut_ptr.offset(off), exp_ptr.offset(1), 2);\n                    3\n                };\n                slice::from_raw_parts(exp_ptr, len)\n            };\n\n            let parts = \u0026[\n                flt2dec::Part::Copy(buf_slice),\n                flt2dec::Part::Zero(added_precision),\n                flt2dec::Part::Copy(exp_slice)\n            ];\n            let sign = if !is_nonnegative {\n                \"-\"\n            } else if f.sign_plus() {\n                \"+\"\n            } else {\n                \"\"\n            };\n            let formatted = flt2dec::Formatted{sign, parts};\n            f.pad_formatted_parts(\u0026formatted)\n        }\n\n        $(\n            #[stable(feature = \"integer_exp_format\", since = \"1.42.0\")]\n            impl fmt::LowerExp for $t {\n                #[allow(unused_comparisons)]\n                fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                    let is_nonnegative = *self \u003e= 0;\n                    let n = if is_nonnegative {\n                        self.$conv_fn()\n                    } else {\n                        // convert the negative num to positive by summing 1 to it's 2 complement\n                        (!self.$conv_fn()).wrapping_add(1)\n                    };\n                    $name(n, is_nonnegative, false, f)\n                }\n            })*\n        $(\n            #[stable(feature = \"integer_exp_format\", since = \"1.42.0\")]\n            impl fmt::UpperExp for $t {\n                #[allow(unused_comparisons)]\n                fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                    let is_nonnegative = *self \u003e= 0;\n                    let n = if is_nonnegative {\n                        self.$conv_fn()\n                    } else {\n                        // convert the negative num to positive by summing 1 to it's 2 complement\n                        (!self.$conv_fn()).wrapping_add(1)\n                    };\n                    $name(n, is_nonnegative, true, f)\n                }\n            })*\n    };\n}\n\n// Include wasm32 in here since it doesn't reflect the native pointer size, and\n// often cares strongly about getting a smaller code size.\n#[cfg(any(target_pointer_width = \"64\", target_arch = \"wasm32\"))]\nmod imp {\n    use super::*;\n    impl_Display!(\n        i8, u8, i16, u16, i32, u32, i64, u64, usize, isize\n            as u64 via to_u64 named fmt_u64\n    );\n    impl_Exp!(\n        i8, u8, i16, u16, i32, u32, i64, u64, usize, isize\n            as u64 via to_u64 named exp_u64\n    );\n}\n\n#[cfg(not(any(target_pointer_width = \"64\", target_arch = \"wasm32\")))]\nmod imp {\n    use super::*;\n    impl_Display!(i8, u8, i16, u16, i32, u32, isize, usize as u32 via to_u32 named fmt_u32);\n    impl_Display!(i64, u64 as u64 via to_u64 named fmt_u64);\n    impl_Exp!(i8, u8, i16, u16, i32, u32, isize, usize as u32 via to_u32 named exp_u32);\n    impl_Exp!(i64, u64 as u64 via to_u64 named exp_u64);\n}\n\nimpl_Display!(i128, u128 as u128 via to_u128 named fmt_u128);\nimpl_Exp!(i128, u128 as u128 via to_u128 named exp_u128);\n","traces":[{"line":148,"address":[4213072,4212896],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":149,"address":[4213091,4213158,4213220,4212915,4212982,4213044],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[4213146,4212970],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[4213040,4212988,4213124,4213164,4212948,4213216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[4213028,4213204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[4213004,4213180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[4213060,4213222,4213046,4213236],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":7},{"path":["/","usr","local","rustup","toolchains","1.45.2-x86_64-unknown-linux-gnu","lib","rustlib","src","rust","src","libcore","macros","mod.rs"],"content":"#[doc(include = \"panic.md\")]\n#[macro_export]\n#[allow_internal_unstable(core_panic, track_caller)]\n#[stable(feature = \"core\", since = \"1.6.0\")]\nmacro_rules! panic {\n    () =\u003e (\n        $crate::panic!(\"explicit panic\")\n    );\n    ($msg:expr) =\u003e (\n        $crate::panicking::panic($msg)\n    );\n    ($msg:expr,) =\u003e (\n        $crate::panic!($msg)\n    );\n    ($fmt:expr, $($arg:tt)+) =\u003e (\n        $crate::panicking::panic_fmt($crate::format_args!($fmt, $($arg)+))\n    );\n}\n\n/// Asserts that two expressions are equal to each other (using [`PartialEq`]).\n///\n/// On panic, this macro will print the values of the expressions with their\n/// debug representations.\n///\n/// Like [`assert!`], this macro has a second form, where a custom\n/// panic message can be provided.\n///\n/// [`PartialEq`]: cmp/trait.PartialEq.html\n/// [`assert!`]: macro.assert.html\n///\n/// # Examples\n///\n/// ```\n/// let a = 3;\n/// let b = 1 + 2;\n/// assert_eq!(a, b);\n///\n/// assert_eq!(a, b, \"we are testing addition with {} and {}\", a, b);\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! assert_eq {\n    ($left:expr, $right:expr) =\u003e ({\n        match (\u0026$left, \u0026$right) {\n            (left_val, right_val) =\u003e {\n                if !(*left_val == *right_val) {\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    panic!(r#\"assertion failed: `(left == right)`\n  left: `{:?}`,\n right: `{:?}`\"#, \u0026*left_val, \u0026*right_val)\n                }\n            }\n        }\n    });\n    ($left:expr, $right:expr,) =\u003e ({\n        $crate::assert_eq!($left, $right)\n    });\n    ($left:expr, $right:expr, $($arg:tt)+) =\u003e ({\n        match (\u0026($left), \u0026($right)) {\n            (left_val, right_val) =\u003e {\n                if !(*left_val == *right_val) {\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    panic!(r#\"assertion failed: `(left == right)`\n  left: `{:?}`,\n right: `{:?}`: {}\"#, \u0026*left_val, \u0026*right_val,\n                           $crate::format_args!($($arg)+))\n                }\n            }\n        }\n    });\n}\n\n/// Asserts that two expressions are not equal to each other (using [`PartialEq`]).\n///\n/// On panic, this macro will print the values of the expressions with their\n/// debug representations.\n///\n/// Like [`assert!`], this macro has a second form, where a custom\n/// panic message can be provided.\n///\n/// [`PartialEq`]: cmp/trait.PartialEq.html\n/// [`assert!`]: macro.assert.html\n///\n/// # Examples\n///\n/// ```\n/// let a = 3;\n/// let b = 2;\n/// assert_ne!(a, b);\n///\n/// assert_ne!(a, b, \"we are testing that the values are not equal\");\n/// ```\n#[macro_export]\n#[stable(feature = \"assert_ne\", since = \"1.13.0\")]\nmacro_rules! assert_ne {\n    ($left:expr, $right:expr) =\u003e ({\n        match (\u0026$left, \u0026$right) {\n            (left_val, right_val) =\u003e {\n                if *left_val == *right_val {\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    panic!(r#\"assertion failed: `(left != right)`\n  left: `{:?}`,\n right: `{:?}`\"#, \u0026*left_val, \u0026*right_val)\n                }\n            }\n        }\n    });\n    ($left:expr, $right:expr,) =\u003e {\n        $crate::assert_ne!($left, $right)\n    };\n    ($left:expr, $right:expr, $($arg:tt)+) =\u003e ({\n        match (\u0026($left), \u0026($right)) {\n            (left_val, right_val) =\u003e {\n                if *left_val == *right_val {\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    panic!(r#\"assertion failed: `(left != right)`\n  left: `{:?}`,\n right: `{:?}`: {}\"#, \u0026*left_val, \u0026*right_val,\n                           $crate::format_args!($($arg)+))\n                }\n            }\n        }\n    });\n}\n\n/// Asserts that a boolean expression is `true` at runtime.\n///\n/// This will invoke the [`panic!`] macro if the provided expression cannot be\n/// evaluated to `true` at runtime.\n///\n/// Like [`assert!`], this macro also has a second version, where a custom panic\n/// message can be provided.\n///\n/// # Uses\n///\n/// Unlike [`assert!`], `debug_assert!` statements are only enabled in non\n/// optimized builds by default. An optimized build will not execute\n/// `debug_assert!` statements unless `-C debug-assertions` is passed to the\n/// compiler. This makes `debug_assert!` useful for checks that are too\n/// expensive to be present in a release build but may be helpful during\n/// development. The result of expanding `debug_assert!` is always type checked.\n///\n/// An unchecked assertion allows a program in an inconsistent state to keep\n/// running, which might have unexpected consequences but does not introduce\n/// unsafety as long as this only happens in safe code. The performance cost\n/// of assertions, is however, not measurable in general. Replacing [`assert!`]\n/// with `debug_assert!` is thus only encouraged after thorough profiling, and\n/// more importantly, only in safe code!\n///\n/// [`panic!`]: macro.panic.html\n/// [`assert!`]: macro.assert.html\n///\n/// # Examples\n///\n/// ```\n/// // the panic message for these assertions is the stringified value of the\n/// // expression given.\n/// debug_assert!(true);\n///\n/// fn some_expensive_computation() -\u003e bool { true } // a very simple function\n/// debug_assert!(some_expensive_computation());\n///\n/// // assert with a custom message\n/// let x = true;\n/// debug_assert!(x, \"x wasn't true!\");\n///\n/// let a = 3; let b = 27;\n/// debug_assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! debug_assert {\n    ($($arg:tt)*) =\u003e (if $crate::cfg!(debug_assertions) { $crate::assert!($($arg)*); })\n}\n\n/// Asserts that two expressions are equal to each other.\n///\n/// On panic, this macro will print the values of the expressions with their\n/// debug representations.\n///\n/// Unlike [`assert_eq!`], `debug_assert_eq!` statements are only enabled in non\n/// optimized builds by default. An optimized build will not execute\n/// `debug_assert_eq!` statements unless `-C debug-assertions` is passed to the\n/// compiler. This makes `debug_assert_eq!` useful for checks that are too\n/// expensive to be present in a release build but may be helpful during\n/// development. The result of expanding `debug_assert_eq!` is always type checked.\n///\n/// [`assert_eq!`]: ../std/macro.assert_eq.html\n///\n/// # Examples\n///\n/// ```\n/// let a = 3;\n/// let b = 1 + 2;\n/// debug_assert_eq!(a, b);\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! debug_assert_eq {\n    ($($arg:tt)*) =\u003e (if $crate::cfg!(debug_assertions) { $crate::assert_eq!($($arg)*); })\n}\n\n/// Asserts that two expressions are not equal to each other.\n///\n/// On panic, this macro will print the values of the expressions with their\n/// debug representations.\n///\n/// Unlike [`assert_ne!`], `debug_assert_ne!` statements are only enabled in non\n/// optimized builds by default. An optimized build will not execute\n/// `debug_assert_ne!` statements unless `-C debug-assertions` is passed to the\n/// compiler. This makes `debug_assert_ne!` useful for checks that are too\n/// expensive to be present in a release build but may be helpful during\n/// development. The result of expanding `debug_assert_ne!` is always type checked.\n///\n/// [`assert_ne!`]: ../std/macro.assert_ne.html\n///\n/// # Examples\n///\n/// ```\n/// let a = 3;\n/// let b = 2;\n/// debug_assert_ne!(a, b);\n/// ```\n#[macro_export]\n#[stable(feature = \"assert_ne\", since = \"1.13.0\")]\nmacro_rules! debug_assert_ne {\n    ($($arg:tt)*) =\u003e (if $crate::cfg!(debug_assertions) { $crate::assert_ne!($($arg)*); })\n}\n\n/// Returns whether the given expression matches any of the given patterns.\n///\n/// Like in a `match` expression, the pattern can be optionally followed by `if`\n/// and a guard expression that has access to names bound by the pattern.\n///\n/// # Examples\n///\n/// ```\n/// let foo = 'f';\n/// assert!(matches!(foo, 'A'..='Z' | 'a'..='z'));\n///\n/// let bar = Some(4);\n/// assert!(matches!(bar, Some(x) if x \u003e 2));\n/// ```\n#[macro_export]\n#[stable(feature = \"matches_macro\", since = \"1.42.0\")]\nmacro_rules! matches {\n    ($expression:expr, $( $pattern:pat )|+ $( if $guard: expr )?) =\u003e {\n        match $expression {\n            $( $pattern )|+ $( if $guard )? =\u003e true,\n            _ =\u003e false\n        }\n    }\n}\n\n/// Unwraps a result or propagates its error.\n///\n/// The `?` operator was added to replace `try!` and should be used instead.\n/// Furthermore, `try` is a reserved word in Rust 2018, so if you must use\n/// it, you will need to use the [raw-identifier syntax][ris]: `r#try`.\n///\n/// [ris]: https://doc.rust-lang.org/nightly/rust-by-example/compatibility/raw_identifiers.html\n///\n/// `try!` matches the given [`Result`]. In case of the `Ok` variant, the\n/// expression has the value of the wrapped value.\n///\n/// In case of the `Err` variant, it retrieves the inner error. `try!` then\n/// performs conversion using `From`. This provides automatic conversion\n/// between specialized errors and more general ones. The resulting\n/// error is then immediately returned.\n///\n/// Because of the early return, `try!` can only be used in functions that\n/// return [`Result`].\n///\n/// [`Result`]: ../std/result/enum.Result.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io;\n/// use std::fs::File;\n/// use std::io::prelude::*;\n///\n/// enum MyError {\n///     FileWriteError\n/// }\n///\n/// impl From\u003cio::Error\u003e for MyError {\n///     fn from(e: io::Error) -\u003e MyError {\n///         MyError::FileWriteError\n///     }\n/// }\n///\n/// // The preferred method of quick returning Errors\n/// fn write_to_file_question() -\u003e Result\u003c(), MyError\u003e {\n///     let mut file = File::create(\"my_best_friends.txt\")?;\n///     file.write_all(b\"This is a list of my best friends.\")?;\n///     Ok(())\n/// }\n///\n/// // The previous method of quick returning Errors\n/// fn write_to_file_using_try() -\u003e Result\u003c(), MyError\u003e {\n///     let mut file = r#try!(File::create(\"my_best_friends.txt\"));\n///     r#try!(file.write_all(b\"This is a list of my best friends.\"));\n///     Ok(())\n/// }\n///\n/// // This is equivalent to:\n/// fn write_to_file_using_match() -\u003e Result\u003c(), MyError\u003e {\n///     let mut file = r#try!(File::create(\"my_best_friends.txt\"));\n///     match file.write_all(b\"This is a list of my best friends.\") {\n///         Ok(v) =\u003e v,\n///         Err(e) =\u003e return Err(From::from(e)),\n///     }\n///     Ok(())\n/// }\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(since = \"1.39.0\", reason = \"use the `?` operator instead\")]\n#[doc(alias = \"?\")]\nmacro_rules! r#try {\n    ($expr:expr) =\u003e {\n        match $expr {\n            $crate::result::Result::Ok(val) =\u003e val,\n            $crate::result::Result::Err(err) =\u003e {\n                return $crate::result::Result::Err($crate::convert::From::from(err));\n            }\n        }\n    };\n    ($expr:expr,) =\u003e {\n        $crate::r#try!($expr)\n    };\n}\n\n/// Writes formatted data into a buffer.\n///\n/// This macro accepts a format string, a list of arguments, and a 'writer'. Arguments will be\n/// formatted according to the specified format string and the result will be passed to the writer.\n/// The writer may be any value with a `write_fmt` method; generally this comes from an\n/// implementation of either the [`std::fmt::Write`] or the [`std::io::Write`] trait. The macro\n/// returns whatever the `write_fmt` method returns; commonly a [`std::fmt::Result`], or an\n/// [`io::Result`].\n///\n/// See [`std::fmt`] for more information on the format string syntax.\n///\n/// [`std::fmt`]: ../std/fmt/index.html\n/// [`std::fmt::Write`]: ../std/fmt/trait.Write.html\n/// [`std::io::Write`]: ../std/io/trait.Write.html\n/// [`std::fmt::Result`]: ../std/fmt/type.Result.html\n/// [`io::Result`]: ../std/io/type.Result.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io::Write;\n///\n/// fn main() -\u003e std::io::Result\u003c()\u003e {\n///     let mut w = Vec::new();\n///     write!(\u0026mut w, \"test\")?;\n///     write!(\u0026mut w, \"formatted {}\", \"arguments\")?;\n///\n///     assert_eq!(w, b\"testformatted arguments\");\n///     Ok(())\n/// }\n/// ```\n///\n/// A module can import both `std::fmt::Write` and `std::io::Write` and call `write!` on objects\n/// implementing either, as objects do not typically implement both. However, the module must\n/// import the traits qualified so their names do not conflict:\n///\n/// ```\n/// use std::fmt::Write as FmtWrite;\n/// use std::io::Write as IoWrite;\n///\n/// fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n///     let mut s = String::new();\n///     let mut v = Vec::new();\n///\n///     write!(\u0026mut s, \"{} {}\", \"abc\", 123)?; // uses fmt::Write::write_fmt\n///     write!(\u0026mut v, \"s = {:?}\", s)?; // uses io::Write::write_fmt\n///     assert_eq!(v, b\"s = \\\"abc 123\\\"\");\n///     Ok(())\n/// }\n/// ```\n///\n/// Note: This macro can be used in `no_std` setups as well.\n/// In a `no_std` setup you are responsible for the implementation details of the components.\n///\n/// ```no_run\n/// # extern crate core;\n/// use core::fmt::Write;\n///\n/// struct Example;\n///\n/// impl Write for Example {\n///     fn write_str(\u0026mut self, _s: \u0026str) -\u003e core::fmt::Result {\n///          unimplemented!();\n///     }\n/// }\n///\n/// let mut m = Example{};\n/// write!(\u0026mut m, \"Hello World\").expect(\"Not written\");\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! write {\n    ($dst:expr, $($arg:tt)*) =\u003e ($dst.write_fmt($crate::format_args!($($arg)*)))\n}\n\n/// Write formatted data into a buffer, with a newline appended.\n///\n/// On all platforms, the newline is the LINE FEED character (`\\n`/`U+000A`) alone\n/// (no additional CARRIAGE RETURN (`\\r`/`U+000D`).\n///\n/// For more information, see [`write!`]. For information on the format string syntax, see\n/// [`std::fmt`].\n///\n/// [`write!`]: macro.write.html\n/// [`std::fmt`]: ../std/fmt/index.html\n///\n///\n/// # Examples\n///\n/// ```\n/// use std::io::{Write, Result};\n///\n/// fn main() -\u003e Result\u003c()\u003e {\n///     let mut w = Vec::new();\n///     writeln!(\u0026mut w)?;\n///     writeln!(\u0026mut w, \"test\")?;\n///     writeln!(\u0026mut w, \"formatted {}\", \"arguments\")?;\n///\n///     assert_eq!(\u0026w[..], \"\\ntest\\nformatted arguments\\n\".as_bytes());\n///     Ok(())\n/// }\n/// ```\n///\n/// A module can import both `std::fmt::Write` and `std::io::Write` and call `write!` on objects\n/// implementing either, as objects do not typically implement both. However, the module must\n/// import the traits qualified so their names do not conflict:\n///\n/// ```\n/// use std::fmt::Write as FmtWrite;\n/// use std::io::Write as IoWrite;\n///\n/// fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n///     let mut s = String::new();\n///     let mut v = Vec::new();\n///\n///     writeln!(\u0026mut s, \"{} {}\", \"abc\", 123)?; // uses fmt::Write::write_fmt\n///     writeln!(\u0026mut v, \"s = {:?}\", s)?; // uses io::Write::write_fmt\n///     assert_eq!(v, b\"s = \\\"abc 123\\\\n\\\"\\n\");\n///     Ok(())\n/// }\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow_internal_unstable(format_args_nl)]\nmacro_rules! writeln {\n    ($dst:expr) =\u003e (\n        $crate::write!($dst, \"\\n\")\n    );\n    ($dst:expr,) =\u003e (\n        $crate::writeln!($dst)\n    );\n    ($dst:expr, $($arg:tt)*) =\u003e (\n        $dst.write_fmt($crate::format_args_nl!($($arg)*))\n    );\n}\n\n/// Indicates unreachable code.\n///\n/// This is useful any time that the compiler can't determine that some code is unreachable. For\n/// example:\n///\n/// * Match arms with guard conditions.\n/// * Loops that dynamically terminate.\n/// * Iterators that dynamically terminate.\n///\n/// If the determination that the code is unreachable proves incorrect, the\n/// program immediately terminates with a [`panic!`].\n///\n/// The unsafe counterpart of this macro is the [`unreachable_unchecked`] function, which\n/// will cause undefined behavior if the code is reached.\n///\n/// [`panic!`]: ../std/macro.panic.html\n/// [`unreachable_unchecked`]: ../std/hint/fn.unreachable_unchecked.html\n/// [`std::hint`]: ../std/hint/index.html\n///\n/// # Panics\n///\n/// This will always [`panic!`]\n///\n/// [`panic!`]: ../std/macro.panic.html\n///\n/// # Examples\n///\n/// Match arms:\n///\n/// ```\n/// # #[allow(dead_code)]\n/// fn foo(x: Option\u003ci32\u003e) {\n///     match x {\n///         Some(n) if n \u003e= 0 =\u003e println!(\"Some(Non-negative)\"),\n///         Some(n) if n \u003c  0 =\u003e println!(\"Some(Negative)\"),\n///         Some(_)           =\u003e unreachable!(), // compile error if commented out\n///         None              =\u003e println!(\"None\")\n///     }\n/// }\n/// ```\n///\n/// Iterators:\n///\n/// ```\n/// # #[allow(dead_code)]\n/// fn divide_by_three(x: u32) -\u003e u32 { // one of the poorest implementations of x/3\n///     for i in 0.. {\n///         if 3*i \u003c i { panic!(\"u32 overflow\"); }\n///         if x \u003c 3*i { return i-1; }\n///     }\n///     unreachable!();\n/// }\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! unreachable {\n    () =\u003e ({\n        panic!(\"internal error: entered unreachable code\")\n    });\n    ($msg:expr) =\u003e ({\n        $crate::unreachable!(\"{}\", $msg)\n    });\n    ($msg:expr,) =\u003e ({\n        $crate::unreachable!($msg)\n    });\n    ($fmt:expr, $($arg:tt)*) =\u003e ({\n        panic!($crate::concat!(\"internal error: entered unreachable code: \", $fmt), $($arg)*)\n    });\n}\n\n/// Indicates unimplemented code by panicking with a message of \"not implemented\".\n///\n/// This allows your code to type-check, which is useful if you are prototyping or\n/// implementing a trait that requires multiple methods which you don't plan of using all of.\n///\n/// The difference between `unimplemented!` and [`todo!`](macro.todo.html) is that while `todo!`\n/// conveys an intent of implementing the functionality later and the message is \"not yet\n/// implemented\", `unimplemented!` makes no such claims. Its message is \"not implemented\".\n/// Also some IDEs will mark `todo!`s.\n///\n/// # Panics\n///\n/// This will always [panic!](macro.panic.html) because `unimplemented!` is just a\n/// shorthand for `panic!` with a fixed, specific message.\n///\n/// Like `panic!`, this macro has a second form for displaying custom values.\n///\n/// # Examples\n///\n/// Say we have a trait `Foo`:\n///\n/// ```\n/// trait Foo {\n///     fn bar(\u0026self) -\u003e u8;\n///     fn baz(\u0026self);\n///     fn qux(\u0026self) -\u003e Result\u003cu64, ()\u003e;\n/// }\n/// ```\n///\n/// We want to implement `Foo` for 'MyStruct', but for some reason it only makes sense\n/// to implement the `bar()` function. `baz()` and `qux()` will still need to be defined\n/// in our implementation of `Foo`, but we can use `unimplemented!` in their definitions\n/// to allow our code to compile.\n///\n/// We still want to have our program stop running if the unimplemented methods are\n/// reached.\n///\n/// ```\n/// # trait Foo {\n/// #     fn bar(\u0026self) -\u003e u8;\n/// #     fn baz(\u0026self);\n/// #     fn qux(\u0026self) -\u003e Result\u003cu64, ()\u003e;\n/// # }\n/// struct MyStruct;\n///\n/// impl Foo for MyStruct {\n///     fn bar(\u0026self) -\u003e u8 {\n///         1 + 1\n///     }\n///\n///     fn baz(\u0026self) {\n///         // It makes no sense to `baz` a `MyStruct`, so we have no logic here\n///         // at all.\n///         // This will display \"thread 'main' panicked at 'not implemented'\".\n///         unimplemented!();\n///     }\n///\n///     fn qux(\u0026self) -\u003e Result\u003cu64, ()\u003e {\n///         // We have some logic here,\n///         // We can add a message to unimplemented! to display our omission.\n///         // This will display:\n///         // \"thread 'main' panicked at 'not implemented: MyStruct isn't quxable'\".\n///         unimplemented!(\"MyStruct isn't quxable\");\n///     }\n/// }\n///\n/// fn main() {\n///     let s = MyStruct;\n///     s.bar();\n/// }\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! unimplemented {\n    () =\u003e (panic!(\"not implemented\"));\n    ($($arg:tt)+) =\u003e (panic!(\"not implemented: {}\", $crate::format_args!($($arg)+)));\n}\n\n/// Indicates unfinished code.\n///\n/// This can be useful if you are prototyping and are just looking to have your\n/// code typecheck.\n///\n/// The difference between [`unimplemented!`] and `todo!` is that while `todo!` conveys\n/// an intent of implementing the functionality later and the message is \"not yet\n/// implemented\", `unimplemented!` makes no such claims. Its message is \"not implemented\".\n/// Also some IDEs will mark `todo!`s.\n///\n/// [`unimplemented!`]: macro.unimplemented.html\n///\n/// # Panics\n///\n/// This will always [panic!](macro.panic.html)\n///\n/// # Examples\n///\n/// Here's an example of some in-progress code. We have a trait `Foo`:\n///\n/// ```\n/// trait Foo {\n///     fn bar(\u0026self);\n///     fn baz(\u0026self);\n/// }\n/// ```\n///\n/// We want to implement `Foo` on one of our types, but we also want to work on\n/// just `bar()` first. In order for our code to compile, we need to implement\n/// `baz()`, so we can use `todo!`:\n///\n/// ```\n/// # trait Foo {\n/// #     fn bar(\u0026self);\n/// #     fn baz(\u0026self);\n/// # }\n/// struct MyStruct;\n///\n/// impl Foo for MyStruct {\n///     fn bar(\u0026self) {\n///         // implementation goes here\n///     }\n///\n///     fn baz(\u0026self) {\n///         // let's not worry about implementing baz() for now\n///         todo!();\n///     }\n/// }\n///\n/// fn main() {\n///     let s = MyStruct;\n///     s.bar();\n///\n///     // we aren't even using baz(), so this is fine.\n/// }\n/// ```\n#[macro_export]\n#[stable(feature = \"todo_macro\", since = \"1.40.0\")]\nmacro_rules! todo {\n    () =\u003e (panic!(\"not yet implemented\"));\n    ($($arg:tt)+) =\u003e (panic!(\"not yet implemented: {}\", $crate::format_args!($($arg)+)));\n}\n\n/// Definitions of built-in macros.\n///\n/// Most of the macro properties (stability, visibility, etc.) are taken from the source code here,\n/// with exception of expansion functions transforming macro inputs into outputs,\n/// those functions are provided by the compiler.\npub(crate) mod builtin {\n\n    /// Causes compilation to fail with the given error message when encountered.\n    ///\n    /// This macro should be used when a crate uses a conditional compilation strategy to provide\n    /// better error messages for erroneous conditions. It's the compiler-level form of [`panic!`],\n    /// but emits an error during *compilation* rather than at *runtime*.\n    ///\n    /// # Examples\n    ///\n    /// Two such examples are macros and `#[cfg]` environments.\n    ///\n    /// Emit better compiler error if a macro is passed invalid values. Without the final branch,\n    /// the compiler would still emit an error, but the error's message would not mention the two\n    /// valid values.\n    ///\n    /// ```compile_fail\n    /// macro_rules! give_me_foo_or_bar {\n    ///     (foo) =\u003e {};\n    ///     (bar) =\u003e {};\n    ///     ($x:ident) =\u003e {\n    ///         compile_error!(\"This macro only accepts `foo` or `bar`\");\n    ///     }\n    /// }\n    ///\n    /// give_me_foo_or_bar!(neither);\n    /// // ^ will fail at compile time with message \"This macro only accepts `foo` or `bar`\"\n    /// ```\n    ///\n    /// Emit compiler error if one of a number of features isn't available.\n    ///\n    /// ```compile_fail\n    /// #[cfg(not(any(feature = \"foo\", feature = \"bar\")))]\n    /// compile_error!(\"Either feature \\\"foo\\\" or \\\"bar\\\" must be enabled for this crate.\");\n    /// ```\n    ///\n    /// [`panic!`]: ../std/macro.panic.html\n    #[stable(feature = \"compile_error_macro\", since = \"1.20.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! compile_error {\n        ($msg:expr) =\u003e {{ /* compiler built-in */ }};\n        ($msg:expr,) =\u003e {{ /* compiler built-in */ }};\n    }\n\n    /// Constructs parameters for the other string-formatting macros.\n    ///\n    /// This macro functions by taking a formatting string literal containing\n    /// `{}` for each additional argument passed. `format_args!` prepares the\n    /// additional parameters to ensure the output can be interpreted as a string\n    /// and canonicalizes the arguments into a single type. Any value that implements\n    /// the [`Display`] trait can be passed to `format_args!`, as can any\n    /// [`Debug`] implementation be passed to a `{:?}` within the formatting string.\n    ///\n    /// This macro produces a value of type [`fmt::Arguments`]. This value can be\n    /// passed to the macros within [`std::fmt`] for performing useful redirection.\n    /// All other formatting macros ([`format!`], [`write!`], [`println!`], etc) are\n    /// proxied through this one. `format_args!`, unlike its derived macros, avoids\n    /// heap allocations.\n    ///\n    /// You can use the [`fmt::Arguments`] value that `format_args!` returns\n    /// in `Debug` and `Display` contexts as seen below. The example also shows\n    /// that `Debug` and `Display` format to the same thing: the interpolated\n    /// format string in `format_args!`.\n    ///\n    /// ```rust\n    /// let debug = format!(\"{:?}\", format_args!(\"{} foo {:?}\", 1, 2));\n    /// let display = format!(\"{}\", format_args!(\"{} foo {:?}\", 1, 2));\n    /// assert_eq!(\"1 foo 2\", display);\n    /// assert_eq!(display, debug);\n    /// ```\n    ///\n    /// For more information, see the documentation in [`std::fmt`].\n    ///\n    /// [`Display`]: ../std/fmt/trait.Display.html\n    /// [`Debug`]: ../std/fmt/trait.Debug.html\n    /// [`fmt::Arguments`]: ../std/fmt/struct.Arguments.html\n    /// [`std::fmt`]: ../std/fmt/index.html\n    /// [`format!`]: ../std/macro.format.html\n    /// [`write!`]: ../std/macro.write.html\n    /// [`println!`]: ../std/macro.println.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// let s = fmt::format(format_args!(\"hello {}\", \"world\"));\n    /// assert_eq!(s, format!(\"hello {}\", \"world\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[allow_internal_unstable(fmt_internals)]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! format_args {\n        ($fmt:expr) =\u003e {{ /* compiler built-in */ }};\n        ($fmt:expr, $($args:tt)*) =\u003e {{ /* compiler built-in */ }};\n    }\n\n    /// Same as `format_args`, but adds a newline in the end.\n    #[unstable(\n        feature = \"format_args_nl\",\n        issue = \"none\",\n        reason = \"`format_args_nl` is only for internal \\\n                  language use and is subject to change\"\n    )]\n    #[allow_internal_unstable(fmt_internals)]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! format_args_nl {\n        ($fmt:expr) =\u003e {{ /* compiler built-in */ }};\n        ($fmt:expr, $($args:tt)*) =\u003e {{ /* compiler built-in */ }};\n    }\n\n    /// Inspects an environment variable at compile time.\n    ///\n    /// This macro will expand to the value of the named environment variable at\n    /// compile time, yielding an expression of type `\u0026'static str`.\n    ///\n    /// If the environment variable is not defined, then a compilation error\n    /// will be emitted. To not emit a compile error, use the [`option_env!`]\n    /// macro instead.\n    ///\n    /// [`option_env!`]: ../std/macro.option_env.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let path: \u0026'static str = env!(\"PATH\");\n    /// println!(\"the $PATH variable at the time of compiling was: {}\", path);\n    /// ```\n    ///\n    /// You can customize the error message by passing a string as the second\n    /// parameter:\n    ///\n    /// ```compile_fail\n    /// let doc: \u0026'static str = env!(\"documentation\", \"what's that?!\");\n    /// ```\n    ///\n    /// If the `documentation` environment variable is not defined, you'll get\n    /// the following error:\n    ///\n    /// ```text\n    /// error: what's that?!\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! env {\n        ($name:expr) =\u003e {{ /* compiler built-in */ }};\n        ($name:expr,) =\u003e {{ /* compiler built-in */ }};\n    }\n\n    /// Optionally inspects an environment variable at compile time.\n    ///\n    /// If the named environment variable is present at compile time, this will\n    /// expand into an expression of type `Option\u003c\u0026'static str\u003e` whose value is\n    /// `Some` of the value of the environment variable. If the environment\n    /// variable is not present, then this will expand to `None`. See\n    /// [`Option\u003cT\u003e`][option] for more information on this type.\n    ///\n    /// A compile time error is never emitted when using this macro regardless\n    /// of whether the environment variable is present or not.\n    ///\n    /// [option]: ../std/option/enum.Option.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let key: Option\u003c\u0026'static str\u003e = option_env!(\"SECRET_KEY\");\n    /// println!(\"the secret key might be: {:?}\", key);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! option_env {\n        ($name:expr) =\u003e {{ /* compiler built-in */ }};\n        ($name:expr,) =\u003e {{ /* compiler built-in */ }};\n    }\n\n    /// Concatenates identifiers into one identifier.\n    ///\n    /// This macro takes any number of comma-separated identifiers, and\n    /// concatenates them all into one, yielding an expression which is a new\n    /// identifier. Note that hygiene makes it such that this macro cannot\n    /// capture local variables. Also, as a general rule, macros are only\n    /// allowed in item, statement or expression position. That means while\n    /// you may use this macro for referring to existing variables, functions or\n    /// modules etc, you cannot define a new one with it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(concat_idents)]\n    ///\n    /// # fn main() {\n    /// fn foobar() -\u003e u32 { 23 }\n    ///\n    /// let f = concat_idents!(foo, bar);\n    /// println!(\"{}\", f());\n    ///\n    /// // fn concat_idents!(new, fun, name) { } // not usable in this way!\n    /// # }\n    /// ```\n    #[unstable(\n        feature = \"concat_idents\",\n        issue = \"29599\",\n        reason = \"`concat_idents` is not stable enough for use and is subject to change\"\n    )]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! concat_idents {\n        ($($e:ident),+) =\u003e {{ /* compiler built-in */ }};\n        ($($e:ident,)+) =\u003e {{ /* compiler built-in */ }};\n    }\n\n    /// Concatenates literals into a static string slice.\n    ///\n    /// This macro takes any number of comma-separated literals, yielding an\n    /// expression of type `\u0026'static str` which represents all of the literals\n    /// concatenated left-to-right.\n    ///\n    /// Integer and floating point literals are stringified in order to be\n    /// concatenated.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let s = concat!(\"test\", 10, 'b', true);\n    /// assert_eq!(s, \"test10btrue\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! concat {\n        ($($e:expr),*) =\u003e {{ /* compiler built-in */ }};\n        ($($e:expr,)*) =\u003e {{ /* compiler built-in */ }};\n    }\n\n    /// Expands to the line number on which it was invoked.\n    ///\n    /// With [`column!`] and [`file!`], these macros provide debugging information for\n    /// developers about the location within the source.\n    ///\n    /// The expanded expression has type `u32` and is 1-based, so the first line\n    /// in each file evaluates to 1, the second to 2, etc. This is consistent\n    /// with error messages by common compilers or popular editors.\n    /// The returned line is *not necessarily* the line of the `line!` invocation itself,\n    /// but rather the first macro invocation leading up to the invocation\n    /// of the `line!` macro.\n    ///\n    /// [`column!`]: macro.column.html\n    /// [`file!`]: macro.file.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let current_line = line!();\n    /// println!(\"defined on line: {}\", current_line);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! line {\n        () =\u003e {\n            /* compiler built-in */\n        };\n    }\n\n    /// Expands to the column number at which it was invoked.\n    ///\n    /// With [`line!`] and [`file!`], these macros provide debugging information for\n    /// developers about the location within the source.\n    ///\n    /// The expanded expression has type `u32` and is 1-based, so the first column\n    /// in each line evaluates to 1, the second to 2, etc. This is consistent\n    /// with error messages by common compilers or popular editors.\n    /// The returned column is *not necessarily* the line of the `column!` invocation itself,\n    /// but rather the first macro invocation leading up to the invocation\n    /// of the `column!` macro.\n    ///\n    /// [`line!`]: macro.line.html\n    /// [`file!`]: macro.file.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let current_col = column!();\n    /// println!(\"defined on column: {}\", current_col);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! column {\n        () =\u003e {\n            /* compiler built-in */\n        };\n    }\n\n    /// Expands to the file name in which it was invoked.\n    ///\n    /// With [`line!`] and [`column!`], these macros provide debugging information for\n    /// developers about the location within the source.\n    ///\n    ///\n    /// The expanded expression has type `\u0026'static str`, and the returned file\n    /// is not the invocation of the `file!` macro itself, but rather the\n    /// first macro invocation leading up to the invocation of the `file!`\n    /// macro.\n    ///\n    /// [`line!`]: macro.line.html\n    /// [`column!`]: macro.column.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let this_file = file!();\n    /// println!(\"defined in file: {}\", this_file);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! file {\n        () =\u003e {\n            /* compiler built-in */\n        };\n    }\n\n    /// Stringifies its arguments.\n    ///\n    /// This macro will yield an expression of type `\u0026'static str` which is the\n    /// stringification of all the tokens passed to the macro. No restrictions\n    /// are placed on the syntax of the macro invocation itself.\n    ///\n    /// Note that the expanded results of the input tokens may change in the\n    /// future. You should be careful if you rely on the output.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let one_plus_one = stringify!(1 + 1);\n    /// assert_eq!(one_plus_one, \"1 + 1\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! stringify {\n        ($($t:tt)*) =\u003e {\n            /* compiler built-in */\n        };\n    }\n\n    /// Includes a utf8-encoded file as a string.\n    ///\n    /// The file is located relative to the current file (similarly to how\n    /// modules are found). The provided path is interpreted in a platform-specific\n    /// way at compile time. So, for instance, an invocation with a Windows path\n    /// containing backslashes `\\` would not compile correctly on Unix.\n    ///\n    /// This macro will yield an expression of type `\u0026'static str` which is the\n    /// contents of the file.\n    ///\n    /// # Examples\n    ///\n    /// Assume there are two files in the same directory with the following\n    /// contents:\n    ///\n    /// File 'spanish.in':\n    ///\n    /// ```text\n    /// adiós\n    /// ```\n    ///\n    /// File 'main.rs':\n    ///\n    /// ```ignore (cannot-doctest-external-file-dependency)\n    /// fn main() {\n    ///     let my_str = include_str!(\"spanish.in\");\n    ///     assert_eq!(my_str, \"adiós\\n\");\n    ///     print!(\"{}\", my_str);\n    /// }\n    /// ```\n    ///\n    /// Compiling 'main.rs' and running the resulting binary will print \"adiós\".\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! include_str {\n        ($file:expr) =\u003e {{ /* compiler built-in */ }};\n        ($file:expr,) =\u003e {{ /* compiler built-in */ }};\n    }\n\n    /// Includes a file as a reference to a byte array.\n    ///\n    /// The file is located relative to the current file (similarly to how\n    /// modules are found). The provided path is interpreted in a platform-specific\n    /// way at compile time. So, for instance, an invocation with a Windows path\n    /// containing backslashes `\\` would not compile correctly on Unix.\n    ///\n    /// This macro will yield an expression of type `\u0026'static [u8; N]` which is\n    /// the contents of the file.\n    ///\n    /// # Examples\n    ///\n    /// Assume there are two files in the same directory with the following\n    /// contents:\n    ///\n    /// File 'spanish.in':\n    ///\n    /// ```text\n    /// adiós\n    /// ```\n    ///\n    /// File 'main.rs':\n    ///\n    /// ```ignore (cannot-doctest-external-file-dependency)\n    /// fn main() {\n    ///     let bytes = include_bytes!(\"spanish.in\");\n    ///     assert_eq!(bytes, b\"adi\\xc3\\xb3s\\n\");\n    ///     print!(\"{}\", String::from_utf8_lossy(bytes));\n    /// }\n    /// ```\n    ///\n    /// Compiling 'main.rs' and running the resulting binary will print \"adiós\".\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! include_bytes {\n        ($file:expr) =\u003e {{ /* compiler built-in */ }};\n        ($file:expr,) =\u003e {{ /* compiler built-in */ }};\n    }\n\n    /// Expands to a string that represents the current module path.\n    ///\n    /// The current module path can be thought of as the hierarchy of modules\n    /// leading back up to the crate root. The first component of the path\n    /// returned is the name of the crate currently being compiled.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// mod test {\n    ///     pub fn foo() {\n    ///         assert!(module_path!().ends_with(\"test\"));\n    ///     }\n    /// }\n    ///\n    /// test::foo();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! module_path {\n        () =\u003e {\n            /* compiler built-in */\n        };\n    }\n\n    /// Evaluates boolean combinations of configuration flags at compile-time.\n    ///\n    /// In addition to the `#[cfg]` attribute, this macro is provided to allow\n    /// boolean expression evaluation of configuration flags. This frequently\n    /// leads to less duplicated code.\n    ///\n    /// The syntax given to this macro is the same syntax as the [`cfg`]\n    /// attribute.\n    ///\n    /// `cfg!`, unlike `#[cfg]`, does not remove any code and only evaluates to true or false. For\n    /// example, all blocks in an if/else expression need to be valid when `cfg!` is used for\n    /// the condition, regardless of what `cfg!` is evaluating.\n    ///\n    /// [`cfg`]: ../reference/conditional-compilation.html#the-cfg-attribute\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let my_directory = if cfg!(windows) {\n    ///     \"windows-specific-directory\"\n    /// } else {\n    ///     \"unix-directory\"\n    /// };\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! cfg {\n        ($($cfg:tt)*) =\u003e {\n            /* compiler built-in */\n        };\n    }\n\n    /// Parses a file as an expression or an item according to the context.\n    ///\n    /// The file is located relative to the current file (similarly to how\n    /// modules are found). The provided path is interpreted in a platform-specific\n    /// way at compile time. So, for instance, an invocation with a Windows path\n    /// containing backslashes `\\` would not compile correctly on Unix.\n    ///\n    /// Using this macro is often a bad idea, because if the file is\n    /// parsed as an expression, it is going to be placed in the\n    /// surrounding code unhygienically. This could result in variables\n    /// or functions being different from what the file expected if\n    /// there are variables or functions that have the same name in\n    /// the current file.\n    ///\n    /// # Examples\n    ///\n    /// Assume there are two files in the same directory with the following\n    /// contents:\n    ///\n    /// File 'monkeys.in':\n    ///\n    /// ```ignore (only-for-syntax-highlight)\n    /// ['🙈', '🙊', '🙉']\n    ///     .iter()\n    ///     .cycle()\n    ///     .take(6)\n    ///     .collect::\u003cString\u003e()\n    /// ```\n    ///\n    /// File 'main.rs':\n    ///\n    /// ```ignore (cannot-doctest-external-file-dependency)\n    /// fn main() {\n    ///     let my_string = include!(\"monkeys.in\");\n    ///     assert_eq!(\"🙈🙊🙉🙈🙊🙉\", my_string);\n    ///     println!(\"{}\", my_string);\n    /// }\n    /// ```\n    ///\n    /// Compiling 'main.rs' and running the resulting binary will print\n    /// \"🙈🙊🙉🙈🙊🙉\".\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! include {\n        ($file:expr) =\u003e {{ /* compiler built-in */ }};\n        ($file:expr,) =\u003e {{ /* compiler built-in */ }};\n    }\n\n    /// Asserts that a boolean expression is `true` at runtime.\n    ///\n    /// This will invoke the [`panic!`] macro if the provided expression cannot be\n    /// evaluated to `true` at runtime.\n    ///\n    /// # Uses\n    ///\n    /// Assertions are always checked in both debug and release builds, and cannot\n    /// be disabled. See [`debug_assert!`] for assertions that are not enabled in\n    /// release builds by default.\n    ///\n    /// Unsafe code may rely on `assert!` to enforce run-time invariants that, if\n    /// violated could lead to unsafety.\n    ///\n    /// Other use-cases of `assert!` include testing and enforcing run-time\n    /// invariants in safe code (whose violation cannot result in unsafety).\n    ///\n    /// # Custom Messages\n    ///\n    /// This macro has a second form, where a custom panic message can\n    /// be provided with or without arguments for formatting. See [`std::fmt`]\n    /// for syntax for this form.\n    ///\n    /// [`panic!`]: macro.panic.html\n    /// [`debug_assert!`]: macro.debug_assert.html\n    /// [`std::fmt`]: ../std/fmt/index.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// // the panic message for these assertions is the stringified value of the\n    /// // expression given.\n    /// assert!(true);\n    ///\n    /// fn some_computation() -\u003e bool { true } // a very simple function\n    ///\n    /// assert!(some_computation());\n    ///\n    /// // assert with a custom message\n    /// let x = true;\n    /// assert!(x, \"x wasn't true!\");\n    ///\n    /// let a = 3; let b = 27;\n    /// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! assert {\n        ($cond:expr) =\u003e {{ /* compiler built-in */ }};\n        ($cond:expr,) =\u003e {{ /* compiler built-in */ }};\n        ($cond:expr, $($arg:tt)+) =\u003e {{ /* compiler built-in */ }};\n    }\n\n    /// Inline assembly.\n    ///\n    /// Read the [unstable book] for the usage.\n    ///\n    /// [unstable book]: ../unstable-book/library-features/asm.html\n    #[unstable(\n        feature = \"asm\",\n        issue = \"72016\",\n        reason = \"inline assembly is not stable enough for use and is subject to change\"\n    )]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! asm {\n        (\"assembly template\",\n            $(operands,)*\n            $(options($(option),*))?\n        ) =\u003e {\n            /* compiler built-in */\n        };\n    }\n\n    /// LLVM-style inline assembly.\n    ///\n    /// Read the [unstable book] for the usage.\n    ///\n    /// [unstable book]: ../unstable-book/library-features/llvm-asm.html\n    #[unstable(\n        feature = \"llvm_asm\",\n        issue = \"70173\",\n        reason = \"prefer using the new asm! syntax instead\"\n    )]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! llvm_asm {\n        (\"assembly template\"\n                        : $(\"output\"(operand),)*\n                        : $(\"input\"(operand),)*\n                        : $(\"clobbers\",)*\n                        : $(\"options\",)*) =\u003e {\n            /* compiler built-in */\n        };\n    }\n\n    /// Module-level inline assembly.\n    #[unstable(\n        feature = \"global_asm\",\n        issue = \"35119\",\n        reason = \"`global_asm!` is not stable enough for use and is subject to change\"\n    )]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! global_asm {\n        (\"assembly\") =\u003e {\n            /* compiler built-in */\n        };\n    }\n\n    /// Prints passed tokens into the standard output.\n    #[unstable(\n        feature = \"log_syntax\",\n        issue = \"29598\",\n        reason = \"`log_syntax!` is not stable enough for use and is subject to change\"\n    )]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! log_syntax {\n        ($($arg:tt)*) =\u003e {\n            /* compiler built-in */\n        };\n    }\n\n    /// Enables or disables tracing functionality used for debugging other macros.\n    #[unstable(\n        feature = \"trace_macros\",\n        issue = \"29598\",\n        reason = \"`trace_macros` is not stable enough for use and is subject to change\"\n    )]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! trace_macros {\n        (true) =\u003e {{ /* compiler built-in */ }};\n        (false) =\u003e {{ /* compiler built-in */ }};\n    }\n\n    /// Attribute macro applied to a function to turn it into a unit test.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[allow_internal_unstable(test, rustc_attrs)]\n    #[rustc_builtin_macro]\n    pub macro test($item:item) {\n        /* compiler built-in */\n    }\n\n    /// Attribute macro applied to a function to turn it into a benchmark test.\n    #[unstable(\n        feature = \"test\",\n        issue = \"50297\",\n        soft,\n        reason = \"`bench` is a part of custom test frameworks which are unstable\"\n    )]\n    #[allow_internal_unstable(test, rustc_attrs)]\n    #[rustc_builtin_macro]\n    pub macro bench($item:item) {\n        /* compiler built-in */\n    }\n\n    /// An implementation detail of the `#[test]` and `#[bench]` macros.\n    #[unstable(\n        feature = \"custom_test_frameworks\",\n        issue = \"50297\",\n        reason = \"custom test frameworks are an unstable feature\"\n    )]\n    #[allow_internal_unstable(test, rustc_attrs)]\n    #[rustc_builtin_macro]\n    pub macro test_case($item:item) {\n        /* compiler built-in */\n    }\n\n    /// Attribute macro applied to a static to register it as a global allocator.\n    #[stable(feature = \"global_allocator\", since = \"1.28.0\")]\n    #[allow_internal_unstable(rustc_attrs)]\n    #[rustc_builtin_macro]\n    pub macro global_allocator($item:item) {\n        /* compiler built-in */\n    }\n\n    /// Keeps the item it's applied to if the passed path is accessible, and removes it otherwise.\n    #[unstable(\n        feature = \"cfg_accessible\",\n        issue = \"64797\",\n        reason = \"`cfg_accessible` is not fully implemented\"\n    )]\n    #[rustc_builtin_macro]\n    pub macro cfg_accessible($item:item) {\n        /* compiler built-in */\n    }\n\n    /// Unstable implementation detail of the `rustc` compiler, do not use.\n    #[rustc_builtin_macro]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[allow_internal_unstable(core_intrinsics, libstd_sys_internals)]\n    pub macro RustcDecodable($item:item) {\n        /* compiler built-in */\n    }\n\n    /// Unstable implementation detail of the `rustc` compiler, do not use.\n    #[rustc_builtin_macro]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[allow_internal_unstable(core_intrinsics)]\n    pub macro RustcEncodable($item:item) {\n        /* compiler built-in */\n    }\n}\n","traces":[{"line":61,"address":[4211440],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[4211468],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[4211500],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[4211543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[4211555,4211765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[4211583,4211617,4211797],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":3,"coverable":6},{"path":["/","usr","local","rustup","toolchains","1.45.2-x86_64-unknown-linux-gnu","lib","rustlib","src","rust","src","libcore","ops","function.rs"],"content":"/// The version of the call operator that takes an immutable receiver.\n///\n/// Instances of `Fn` can be called repeatedly without mutating state.\n///\n/// *This trait (`Fn`) is not to be confused with [function pointers]\n/// (`fn`).*\n///\n/// `Fn` is implemented automatically by closures which only take immutable\n/// references to captured variables or don't capture anything at all, as well\n/// as (safe) [function pointers] (with some caveats, see their documentation\n/// for more details). Additionally, for any type `F` that implements `Fn`, `\u0026F`\n/// implements `Fn`, too.\n///\n/// Since both [`FnMut`] and [`FnOnce`] are supertraits of `Fn`, any\n/// instance of `Fn` can be used as a parameter where a [`FnMut`] or [`FnOnce`]\n/// is expected.\n///\n/// Use `Fn` as a bound when you want to accept a parameter of function-like\n/// type and need to call it repeatedly and without mutating state (e.g., when\n/// calling it concurrently). If you do not need such strict requirements, use\n/// [`FnMut`] or [`FnOnce`] as bounds.\n///\n/// See the [chapter on closures in *The Rust Programming Language*][book] for\n/// some more information on this topic.\n///\n/// Also of note is the special syntax for `Fn` traits (e.g.\n/// `Fn(usize, bool) -\u003e usize`). Those interested in the technical details of\n/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n///\n/// [book]: ../../book/ch13-01-closures.html\n/// [`FnMut`]: trait.FnMut.html\n/// [`FnOnce`]: trait.FnOnce.html\n/// [function pointers]: ../../std/primitive.fn.html\n/// [nomicon]: ../../nomicon/hrtb.html\n///\n/// # Examples\n///\n/// ## Calling a closure\n///\n/// ```\n/// let square = |x| x * x;\n/// assert_eq!(square(5), 25);\n/// ```\n///\n/// ## Using a `Fn` parameter\n///\n/// ```\n/// fn call_with_one\u003cF\u003e(func: F) -\u003e usize\n///     where F: Fn(usize) -\u003e usize {\n///     func(1)\n/// }\n///\n/// let double = |x| x * 2;\n/// assert_eq!(call_with_one(double), 2);\n/// ```\n#[lang = \"fn\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_paren_sugar]\n#[rustc_on_unimplemented(\n    on(\n        Args = \"()\",\n        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"\n    ),\n    message = \"expected a `{Fn}\u003c{Args}\u003e` closure, found `{Self}`\",\n    label = \"expected an `Fn\u003c{Args}\u003e` closure, found `{Self}`\"\n)]\n#[fundamental] // so that regex can rely that `\u0026str: !FnMut`\n#[must_use = \"closures are lazy and do nothing unless called\"]\npub trait Fn\u003cArgs\u003e: FnMut\u003cArgs\u003e {\n    /// Performs the call operation.\n    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n    extern \"rust-call\" fn call(\u0026self, args: Args) -\u003e Self::Output;\n}\n\n/// The version of the call operator that takes a mutable receiver.\n///\n/// Instances of `FnMut` can be called repeatedly and may mutate state.\n///\n/// `FnMut` is implemented automatically by closures which take mutable\n/// references to captured variables, as well as all types that implement\n/// [`Fn`], e.g., (safe) [function pointers] (since `FnMut` is a supertrait of\n/// [`Fn`]). Additionally, for any type `F` that implements `FnMut`, `\u0026mut F`\n/// implements `FnMut`, too.\n///\n/// Since [`FnOnce`] is a supertrait of `FnMut`, any instance of `FnMut` can be\n/// used where a [`FnOnce`] is expected, and since [`Fn`] is a subtrait of\n/// `FnMut`, any instance of [`Fn`] can be used where `FnMut` is expected.\n///\n/// Use `FnMut` as a bound when you want to accept a parameter of function-like\n/// type and need to call it repeatedly, while allowing it to mutate state.\n/// If you don't want the parameter to mutate state, use [`Fn`] as a\n/// bound; if you don't need to call it repeatedly, use [`FnOnce`].\n///\n/// See the [chapter on closures in *The Rust Programming Language*][book] for\n/// some more information on this topic.\n///\n/// Also of note is the special syntax for `Fn` traits (e.g.\n/// `Fn(usize, bool) -\u003e usize`). Those interested in the technical details of\n/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n///\n/// [book]: ../../book/ch13-01-closures.html\n/// [`Fn`]: trait.Fn.html\n/// [`FnOnce`]: trait.FnOnce.html\n/// [function pointers]: ../../std/primitive.fn.html\n/// [nomicon]: ../../nomicon/hrtb.html\n///\n/// # Examples\n///\n/// ## Calling a mutably capturing closure\n///\n/// ```\n/// let mut x = 5;\n/// {\n///     let mut square_x = || x *= x;\n///     square_x();\n/// }\n/// assert_eq!(x, 25);\n/// ```\n///\n/// ## Using a `FnMut` parameter\n///\n/// ```\n/// fn do_twice\u003cF\u003e(mut func: F)\n///     where F: FnMut()\n/// {\n///     func();\n///     func();\n/// }\n///\n/// let mut x: usize = 1;\n/// {\n///     let add_two_to_x = || x += 2;\n///     do_twice(add_two_to_x);\n/// }\n///\n/// assert_eq!(x, 5);\n/// ```\n#[lang = \"fn_mut\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_paren_sugar]\n#[rustc_on_unimplemented(\n    on(\n        Args = \"()\",\n        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"\n    ),\n    message = \"expected a `{FnMut}\u003c{Args}\u003e` closure, found `{Self}`\",\n    label = \"expected an `FnMut\u003c{Args}\u003e` closure, found `{Self}`\"\n)]\n#[fundamental] // so that regex can rely that `\u0026str: !FnMut`\n#[must_use = \"closures are lazy and do nothing unless called\"]\npub trait FnMut\u003cArgs\u003e: FnOnce\u003cArgs\u003e {\n    /// Performs the call operation.\n    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n    extern \"rust-call\" fn call_mut(\u0026mut self, args: Args) -\u003e Self::Output;\n}\n\n/// The version of the call operator that takes a by-value receiver.\n///\n/// Instances of `FnOnce` can be called, but might not be callable multiple\n/// times. Because of this, if the only thing known about a type is that it\n/// implements `FnOnce`, it can only be called once.\n///\n/// `FnOnce` is implemented automatically by closure that might consume captured\n/// variables, as well as all types that implement [`FnMut`], e.g., (safe)\n/// [function pointers] (since `FnOnce` is a supertrait of [`FnMut`]).\n///\n/// Since both [`Fn`] and [`FnMut`] are subtraits of `FnOnce`, any instance of\n/// [`Fn`] or [`FnMut`] can be used where a `FnOnce` is expected.\n///\n/// Use `FnOnce` as a bound when you want to accept a parameter of function-like\n/// type and only need to call it once. If you need to call the parameter\n/// repeatedly, use [`FnMut`] as a bound; if you also need it to not mutate\n/// state, use [`Fn`].\n///\n/// See the [chapter on closures in *The Rust Programming Language*][book] for\n/// some more information on this topic.\n///\n/// Also of note is the special syntax for `Fn` traits (e.g.\n/// `Fn(usize, bool) -\u003e usize`). Those interested in the technical details of\n/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n///\n/// [book]: ../../book/ch13-01-closures.html\n/// [`Fn`]: trait.Fn.html\n/// [`FnMut`]: trait.FnMut.html\n/// [function pointers]: ../../std/primitive.fn.html\n/// [nomicon]: ../../nomicon/hrtb.html\n///\n/// # Examples\n///\n/// ## Using a `FnOnce` parameter\n///\n/// ```\n/// fn consume_with_relish\u003cF\u003e(func: F)\n///     where F: FnOnce() -\u003e String\n/// {\n///     // `func` consumes its captured variables, so it cannot be run more\n///     // than once.\n///     println!(\"Consumed: {}\", func());\n///\n///     println!(\"Delicious!\");\n///\n///     // Attempting to invoke `func()` again will throw a `use of moved\n///     // value` error for `func`.\n/// }\n///\n/// let x = String::from(\"x\");\n/// let consume_and_return_x = move || x;\n/// consume_with_relish(consume_and_return_x);\n///\n/// // `consume_and_return_x` can no longer be invoked at this point\n/// ```\n#[lang = \"fn_once\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_paren_sugar]\n#[rustc_on_unimplemented(\n    on(\n        Args = \"()\",\n        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"\n    ),\n    message = \"expected a `{FnOnce}\u003c{Args}\u003e` closure, found `{Self}`\",\n    label = \"expected an `FnOnce\u003c{Args}\u003e` closure, found `{Self}`\"\n)]\n#[fundamental] // so that regex can rely that `\u0026str: !FnMut`\n#[must_use = \"closures are lazy and do nothing unless called\"]\npub trait FnOnce\u003cArgs\u003e {\n    /// The returned type after the call operator is used.\n    #[stable(feature = \"fn_once_output\", since = \"1.12.0\")]\n    type Output;\n\n    /// Performs the call operation.\n    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n    extern \"rust-call\" fn call_once(self, args: Args) -\u003e Self::Output;\n}\n\nmod impls {\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl\u003cA, F: ?Sized\u003e Fn\u003cA\u003e for \u0026F\n    where\n        F: Fn\u003cA\u003e,\n    {\n        extern \"rust-call\" fn call(\u0026self, args: A) -\u003e F::Output {\n            (**self).call(args)\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl\u003cA, F: ?Sized\u003e FnMut\u003cA\u003e for \u0026F\n    where\n        F: Fn\u003cA\u003e,\n    {\n        extern \"rust-call\" fn call_mut(\u0026mut self, args: A) -\u003e F::Output {\n            (**self).call(args)\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl\u003cA, F: ?Sized\u003e FnOnce\u003cA\u003e for \u0026F\n    where\n        F: Fn\u003cA\u003e,\n    {\n        type Output = F::Output;\n\n        extern \"rust-call\" fn call_once(self, args: A) -\u003e F::Output {\n            (*self).call(args)\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl\u003cA, F: ?Sized\u003e FnMut\u003cA\u003e for \u0026mut F\n    where\n        F: FnMut\u003cA\u003e,\n    {\n        extern \"rust-call\" fn call_mut(\u0026mut self, args: A) -\u003e F::Output {\n            (*self).call_mut(args)\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl\u003cA, F: ?Sized\u003e FnOnce\u003cA\u003e for \u0026mut F\n    where\n        F: FnMut\u003cA\u003e,\n    {\n        type Output = F::Output;\n        extern \"rust-call\" fn call_once(self, args: A) -\u003e F::Output {\n            (*self).call_mut(args)\n        }\n    }\n}\n","traces":[{"line":232,"address":[4212105,4212096,4212073,4212064,4212144,4212158],"length":1,"stats":{"Line":2},"fn_name":"call_once\u003cclosure-0,()\u003e"}],"covered":1,"coverable":1},{"path":["/","usr","local","rustup","toolchains","1.45.2-x86_64-unknown-linux-gnu","lib","rustlib","src","rust","src","libcore","ptr","mod.rs"],"content":"//! Manually manage memory through raw pointers.\n//!\n//! *[See also the pointer primitive types](../../std/primitive.pointer.html).*\n//!\n//! # Safety\n//!\n//! Many functions in this module take raw pointers as arguments and read from\n//! or write to them. For this to be safe, these pointers must be *valid*.\n//! Whether a pointer is valid depends on the operation it is used for\n//! (read or write), and the extent of the memory that is accessed (i.e.,\n//! how many bytes are read/written). Most functions use `*mut T` and `*const T`\n//! to access only a single value, in which case the documentation omits the size\n//! and implicitly assumes it to be `size_of::\u003cT\u003e()` bytes.\n//!\n//! The precise rules for validity are not determined yet. The guarantees that are\n//! provided at this point are very minimal:\n//!\n//! * A [null] pointer is *never* valid, not even for accesses of [size zero][zst].\n//! * All pointers (except for the null pointer) are valid for all operations of\n//!   [size zero][zst].\n//! * For a pointer to be valid, it is necessary, but not always sufficient, that the pointer\n//!   be *dereferenceable*: the memory range of the given size starting at the pointer must all be\n//!   within the bounds of a single allocated object. Note that in Rust,\n//!   every (stack-allocated) variable is considered a separate allocated object.\n//! * All accesses performed by functions in this module are *non-atomic* in the sense\n//!   of [atomic operations] used to synchronize between threads. This means it is\n//!   undefined behavior to perform two concurrent accesses to the same location from different\n//!   threads unless both accesses only read from memory. Notice that this explicitly\n//!   includes [`read_volatile`] and [`write_volatile`]: Volatile accesses cannot\n//!   be used for inter-thread synchronization.\n//! * The result of casting a reference to a pointer is valid for as long as the\n//!   underlying object is live and no reference (just raw pointers) is used to\n//!   access the same memory.\n//!\n//! These axioms, along with careful use of [`offset`] for pointer arithmetic,\n//! are enough to correctly implement many useful things in unsafe code. Stronger guarantees\n//! will be provided eventually, as the [aliasing] rules are being determined. For more\n//! information, see the [book] as well as the section in the reference devoted\n//! to [undefined behavior][ub].\n//!\n//! ## Alignment\n//!\n//! Valid raw pointers as defined above are not necessarily properly aligned (where\n//! \"proper\" alignment is defined by the pointee type, i.e., `*const T` must be\n//! aligned to `mem::align_of::\u003cT\u003e()`). However, most functions require their\n//! arguments to be properly aligned, and will explicitly state\n//! this requirement in their documentation. Notable exceptions to this are\n//! [`read_unaligned`] and [`write_unaligned`].\n//!\n//! When a function requires proper alignment, it does so even if the access\n//! has size 0, i.e., even if memory is not actually touched. Consider using\n//! [`NonNull::dangling`] in such cases.\n//!\n//! [aliasing]: ../../nomicon/aliasing.html\n//! [book]: ../../book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer\n//! [ub]: ../../reference/behavior-considered-undefined.html\n//! [null]: ./fn.null.html\n//! [zst]: ../../nomicon/exotic-sizes.html#zero-sized-types-zsts\n//! [atomic operations]: ../../std/sync/atomic/index.html\n//! [`copy`]: ../../std/ptr/fn.copy.html\n//! [`offset`]: ../../std/primitive.pointer.html#method.offset\n//! [`read_unaligned`]: ./fn.read_unaligned.html\n//! [`write_unaligned`]: ./fn.write_unaligned.html\n//! [`read_volatile`]: ./fn.read_volatile.html\n//! [`write_volatile`]: ./fn.write_volatile.html\n//! [`NonNull::dangling`]: ./struct.NonNull.html#method.dangling\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::cmp::Ordering;\nuse crate::fmt;\nuse crate::hash;\nuse crate::intrinsics::{self, is_aligned_and_not_null, is_nonoverlapping};\nuse crate::mem::{self, MaybeUninit};\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(inline)]\npub use crate::intrinsics::copy_nonoverlapping;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(inline)]\npub use crate::intrinsics::copy;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(inline)]\npub use crate::intrinsics::write_bytes;\n\nmod non_null;\n#[stable(feature = \"nonnull\", since = \"1.25.0\")]\npub use non_null::NonNull;\n\nmod unique;\n#[unstable(feature = \"ptr_internals\", issue = \"none\")]\npub use unique::Unique;\n\nmod const_ptr;\nmod mut_ptr;\n\n/// Executes the destructor (if any) of the pointed-to value.\n///\n/// This is semantically equivalent to calling [`ptr::read`] and discarding\n/// the result, but has the following advantages:\n///\n/// * It is *required* to use `drop_in_place` to drop unsized types like\n///   trait objects, because they can't be read out onto the stack and\n///   dropped normally.\n///\n/// * It is friendlier to the optimizer to do this over [`ptr::read`] when\n///   dropping manually allocated memory (e.g., when writing Box/Rc/Vec),\n///   as the compiler doesn't need to prove that it's sound to elide the\n///   copy.\n///\n/// * It can be used to drop [pinned] data when `T` is not `repr(packed)`\n///   (pinned data must not be moved before it is dropped).\n///\n/// Unaligned values cannot be dropped in place, they must be copied to an aligned\n/// location first using [`ptr::read_unaligned`]. For packed structs, this move is\n/// done automatically by the compiler. This means the fields of packed structs\n/// are not dropped in-place.\n///\n/// [`ptr::read`]: ../ptr/fn.read.html\n/// [`ptr::read_unaligned`]: ../ptr/fn.read_unaligned.html\n/// [pinned]: ../pin/index.html\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `to_drop` must be [valid] for both reads and writes.\n///\n/// * `to_drop` must be properly aligned.\n///\n/// * The value `to_drop` points to must be valid for dropping, which may mean it must uphold\n///   additional invariants - this is type-dependent.\n///\n/// Additionally, if `T` is not [`Copy`], using the pointed-to value after\n/// calling `drop_in_place` can cause undefined behavior. Note that `*to_drop =\n/// foo` counts as a use because it will cause the value to be dropped\n/// again. [`write`] can be used to overwrite data without causing it to be\n/// dropped.\n///\n/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n///\n/// [valid]: ../ptr/index.html#safety\n/// [`Copy`]: ../marker/trait.Copy.html\n/// [`write`]: ../ptr/fn.write.html\n///\n/// # Examples\n///\n/// Manually remove the last item from a vector:\n///\n/// ```\n/// use std::ptr;\n/// use std::rc::Rc;\n///\n/// let last = Rc::new(1);\n/// let weak = Rc::downgrade(\u0026last);\n///\n/// let mut v = vec![Rc::new(0), last];\n///\n/// unsafe {\n///     // Get a raw pointer to the last element in `v`.\n///     let ptr = \u0026mut v[1] as *mut _;\n///     // Shorten `v` to prevent the last item from being dropped. We do that first,\n///     // to prevent issues if the `drop_in_place` below panics.\n///     v.set_len(1);\n///     // Without a call `drop_in_place`, the last item would never be dropped,\n///     // and the memory it manages would be leaked.\n///     ptr::drop_in_place(ptr);\n/// }\n///\n/// assert_eq!(v, \u0026[0.into()]);\n///\n/// // Ensure that the last item was dropped.\n/// assert!(weak.upgrade().is_none());\n/// ```\n///\n/// Notice that the compiler performs this copy automatically when dropping packed structs,\n/// i.e., you do not usually have to worry about such issues unless you call `drop_in_place`\n/// manually.\n#[stable(feature = \"drop_in_place\", since = \"1.8.0\")]\n#[lang = \"drop_in_place\"]\n#[allow(unconditional_recursion)]\npub unsafe fn drop_in_place\u003cT: ?Sized\u003e(to_drop: *mut T) {\n    // Code here does not matter - this is replaced by the\n    // real drop glue by the compiler.\n    drop_in_place(to_drop)\n}\n\n/// Creates a null raw pointer.\n///\n/// # Examples\n///\n/// ```\n/// use std::ptr;\n///\n/// let p: *const i32 = ptr::null();\n/// assert!(p.is_null());\n/// ```\n#[inline(always)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_promotable]\n#[rustc_const_stable(feature = \"const_ptr_null\", since = \"1.32.0\")]\npub const fn null\u003cT\u003e() -\u003e *const T {\n    0 as *const T\n}\n\n/// Creates a null mutable raw pointer.\n///\n/// # Examples\n///\n/// ```\n/// use std::ptr;\n///\n/// let p: *mut i32 = ptr::null_mut();\n/// assert!(p.is_null());\n/// ```\n#[inline(always)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_promotable]\n#[rustc_const_stable(feature = \"const_ptr_null\", since = \"1.32.0\")]\npub const fn null_mut\u003cT\u003e() -\u003e *mut T {\n    0 as *mut T\n}\n\n#[repr(C)]\npub(crate) union Repr\u003cT\u003e {\n    pub(crate) rust: *const [T],\n    rust_mut: *mut [T],\n    pub(crate) raw: FatPtr\u003cT\u003e,\n}\n\n#[repr(C)]\npub(crate) struct FatPtr\u003cT\u003e {\n    data: *const T,\n    pub(crate) len: usize,\n}\n\n/// Forms a raw slice from a pointer and a length.\n///\n/// The `len` argument is the number of **elements**, not the number of bytes.\n///\n/// This function is safe, but actually using the return value is unsafe.\n/// See the documentation of [`from_raw_parts`] for slice safety requirements.\n///\n/// [`from_raw_parts`]: ../../std/slice/fn.from_raw_parts.html\n///\n/// # Examples\n///\n/// ```rust\n/// use std::ptr;\n///\n/// // create a slice pointer when starting out with a pointer to the first element\n/// let x = [5, 6, 7];\n/// let raw_pointer = x.as_ptr();\n/// let slice = ptr::slice_from_raw_parts(raw_pointer, 3);\n/// assert_eq!(unsafe { \u0026*slice }[2], 7);\n/// ```\n#[inline]\n#[stable(feature = \"slice_from_raw_parts\", since = \"1.42.0\")]\n#[rustc_const_unstable(feature = \"const_slice_from_raw_parts\", issue = \"67456\")]\npub const fn slice_from_raw_parts\u003cT\u003e(data: *const T, len: usize) -\u003e *const [T] {\n    // SAFETY: Accessing the value from the `Repr` union is safe since *const [T]\n    // and FatPtr have the same memory layouts. Only std can make this\n    // guarantee.\n    unsafe { Repr { raw: FatPtr { data, len } }.rust }\n}\n\n/// Performs the same functionality as [`slice_from_raw_parts`], except that a\n/// raw mutable slice is returned, as opposed to a raw immutable slice.\n///\n/// See the documentation of [`slice_from_raw_parts`] for more details.\n///\n/// This function is safe, but actually using the return value is unsafe.\n/// See the documentation of [`from_raw_parts_mut`] for slice safety requirements.\n///\n/// [`slice_from_raw_parts`]: fn.slice_from_raw_parts.html\n/// [`from_raw_parts_mut`]: ../../std/slice/fn.from_raw_parts_mut.html\n///\n/// # Examples\n///\n/// ```rust\n/// use std::ptr;\n///\n/// let x = \u0026mut [5, 6, 7];\n/// let raw_pointer = x.as_mut_ptr();\n/// let slice = ptr::slice_from_raw_parts_mut(raw_pointer, 3);\n///\n/// unsafe {\n///     (*slice)[2] = 99; // assign a value at an index in the slice\n/// };\n///\n/// assert_eq!(unsafe { \u0026*slice }[2], 99);\n/// ```\n#[inline]\n#[stable(feature = \"slice_from_raw_parts\", since = \"1.42.0\")]\n#[rustc_const_unstable(feature = \"const_slice_from_raw_parts\", issue = \"67456\")]\npub const fn slice_from_raw_parts_mut\u003cT\u003e(data: *mut T, len: usize) -\u003e *mut [T] {\n    // SAFETY: Accessing the value from the `Repr` union is safe since *mut [T]\n    // and FatPtr have the same memory layouts\n    unsafe { Repr { raw: FatPtr { data, len } }.rust_mut }\n}\n\n/// Swaps the values at two mutable locations of the same type, without\n/// deinitializing either.\n///\n/// But for the following two exceptions, this function is semantically\n/// equivalent to [`mem::swap`]:\n///\n/// * It operates on raw pointers instead of references. When references are\n///   available, [`mem::swap`] should be preferred.\n///\n/// * The two pointed-to values may overlap. If the values do overlap, then the\n///   overlapping region of memory from `x` will be used. This is demonstrated\n///   in the second example below.\n///\n/// [`mem::swap`]: ../mem/fn.swap.html\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * Both `x` and `y` must be [valid] for both reads and writes.\n///\n/// * Both `x` and `y` must be properly aligned.\n///\n/// Note that even if `T` has size `0`, the pointers must be non-NULL and properly aligned.\n///\n/// [valid]: ../ptr/index.html#safety\n///\n/// # Examples\n///\n/// Swapping two non-overlapping regions:\n///\n/// ```\n/// use std::ptr;\n///\n/// let mut array = [0, 1, 2, 3];\n///\n/// let x = array[0..].as_mut_ptr() as *mut [u32; 2]; // this is `array[0..2]`\n/// let y = array[2..].as_mut_ptr() as *mut [u32; 2]; // this is `array[2..4]`\n///\n/// unsafe {\n///     ptr::swap(x, y);\n///     assert_eq!([2, 3, 0, 1], array);\n/// }\n/// ```\n///\n/// Swapping two overlapping regions:\n///\n/// ```\n/// use std::ptr;\n///\n/// let mut array = [0, 1, 2, 3];\n///\n/// let x = array[0..].as_mut_ptr() as *mut [u32; 3]; // this is `array[0..3]`\n/// let y = array[1..].as_mut_ptr() as *mut [u32; 3]; // this is `array[1..4]`\n///\n/// unsafe {\n///     ptr::swap(x, y);\n///     // The indices `1..3` of the slice overlap between `x` and `y`.\n///     // Reasonable results would be for to them be `[2, 3]`, so that indices `0..3` are\n///     // `[1, 2, 3]` (matching `y` before the `swap`); or for them to be `[0, 1]`\n///     // so that indices `1..4` are `[0, 1, 2]` (matching `x` before the `swap`).\n///     // This implementation is defined to make the latter choice.\n///     assert_eq!([1, 0, 1, 2], array);\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn swap\u003cT\u003e(x: *mut T, y: *mut T) {\n    // Give ourselves some scratch space to work with.\n    // We do not have to worry about drops: `MaybeUninit` does nothing when dropped.\n    let mut tmp = MaybeUninit::\u003cT\u003e::uninit();\n\n    // Perform the swap\n    copy_nonoverlapping(x, tmp.as_mut_ptr(), 1);\n    copy(y, x, 1); // `x` and `y` may overlap\n    copy_nonoverlapping(tmp.as_ptr(), y, 1);\n}\n\n/// Swaps `count * size_of::\u003cT\u003e()` bytes between the two regions of memory\n/// beginning at `x` and `y`. The two regions must *not* overlap.\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * Both `x` and `y` must be [valid] for both reads and writes of `count *\n///   size_of::\u003cT\u003e()` bytes.\n///\n/// * Both `x` and `y` must be properly aligned.\n///\n/// * The region of memory beginning at `x` with a size of `count *\n///   size_of::\u003cT\u003e()` bytes must *not* overlap with the region of memory\n///   beginning at `y` with the same size.\n///\n/// Note that even if the effectively copied size (`count * size_of::\u003cT\u003e()`) is `0`,\n/// the pointers must be non-NULL and properly aligned.\n///\n/// [valid]: ../ptr/index.html#safety\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::ptr;\n///\n/// let mut x = [1, 2, 3, 4];\n/// let mut y = [7, 8, 9];\n///\n/// unsafe {\n///     ptr::swap_nonoverlapping(x.as_mut_ptr(), y.as_mut_ptr(), 2);\n/// }\n///\n/// assert_eq!(x, [7, 8, 3, 4]);\n/// assert_eq!(y, [1, 2, 9]);\n/// ```\n#[inline]\n#[stable(feature = \"swap_nonoverlapping\", since = \"1.27.0\")]\npub unsafe fn swap_nonoverlapping\u003cT\u003e(x: *mut T, y: *mut T, count: usize) {\n    debug_assert!(is_aligned_and_not_null(x), \"attempt to swap unaligned or null pointer\");\n    debug_assert!(is_aligned_and_not_null(y), \"attempt to swap unaligned or null pointer\");\n    debug_assert!(is_nonoverlapping(x, y, count), \"attempt to swap overlapping memory\");\n\n    let x = x as *mut u8;\n    let y = y as *mut u8;\n    let len = mem::size_of::\u003cT\u003e() * count;\n    swap_nonoverlapping_bytes(x, y, len)\n}\n\n#[inline]\npub(crate) unsafe fn swap_nonoverlapping_one\u003cT\u003e(x: *mut T, y: *mut T) {\n    // For types smaller than the block optimization below,\n    // just swap directly to avoid pessimizing codegen.\n    if mem::size_of::\u003cT\u003e() \u003c 32 {\n        let z = read(x);\n        copy_nonoverlapping(y, x, 1);\n        write(y, z);\n    } else {\n        swap_nonoverlapping(x, y, 1);\n    }\n}\n\n#[inline]\nunsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n    // The approach here is to utilize simd to swap x \u0026 y efficiently. Testing reveals\n    // that swapping either 32 bytes or 64 bytes at a time is most efficient for Intel\n    // Haswell E processors. LLVM is more able to optimize if we give a struct a\n    // #[repr(simd)], even if we don't actually use this struct directly.\n    //\n    // FIXME repr(simd) broken on emscripten and redox\n    #[cfg_attr(not(any(target_os = \"emscripten\", target_os = \"redox\")), repr(simd))]\n    struct Block(u64, u64, u64, u64);\n    struct UnalignedBlock(u64, u64, u64, u64);\n\n    let block_size = mem::size_of::\u003cBlock\u003e();\n\n    // Loop through x \u0026 y, copying them `Block` at a time\n    // The optimizer should unroll the loop fully for most types\n    // N.B. We can't use a for loop as the `range` impl calls `mem::swap` recursively\n    let mut i = 0;\n    while i + block_size \u003c= len {\n        // Create some uninitialized memory as scratch space\n        // Declaring `t` here avoids aligning the stack when this loop is unused\n        let mut t = mem::MaybeUninit::\u003cBlock\u003e::uninit();\n        let t = t.as_mut_ptr() as *mut u8;\n        let x = x.add(i);\n        let y = y.add(i);\n\n        // Swap a block of bytes of x \u0026 y, using t as a temporary buffer\n        // This should be optimized into efficient SIMD operations where available\n        copy_nonoverlapping(x, t, block_size);\n        copy_nonoverlapping(y, x, block_size);\n        copy_nonoverlapping(t, y, block_size);\n        i += block_size;\n    }\n\n    if i \u003c len {\n        // Swap any remaining bytes\n        let mut t = mem::MaybeUninit::\u003cUnalignedBlock\u003e::uninit();\n        let rem = len - i;\n\n        let t = t.as_mut_ptr() as *mut u8;\n        let x = x.add(i);\n        let y = y.add(i);\n\n        copy_nonoverlapping(x, t, rem);\n        copy_nonoverlapping(y, x, rem);\n        copy_nonoverlapping(t, y, rem);\n    }\n}\n\n/// Moves `src` into the pointed `dst`, returning the previous `dst` value.\n///\n/// Neither value is dropped.\n///\n/// This function is semantically equivalent to [`mem::replace`] except that it\n/// operates on raw pointers instead of references. When references are\n/// available, [`mem::replace`] should be preferred.\n///\n/// [`mem::replace`]: ../mem/fn.replace.html\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `dst` must be [valid] for both reads and writes.\n///\n/// * `dst` must be properly aligned.\n///\n/// * `dst` must point to a properly initialized value of type `T`.\n///\n/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n///\n/// [valid]: ../ptr/index.html#safety\n///\n/// # Examples\n///\n/// ```\n/// use std::ptr;\n///\n/// let mut rust = vec!['b', 'u', 's', 't'];\n///\n/// // `mem::replace` would have the same effect without requiring the unsafe\n/// // block.\n/// let b = unsafe {\n///     ptr::replace(\u0026mut rust[0], 'r')\n/// };\n///\n/// assert_eq!(b, 'b');\n/// assert_eq!(rust, \u0026['r', 'u', 's', 't']);\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn replace\u003cT\u003e(dst: *mut T, mut src: T) -\u003e T {\n    mem::swap(\u0026mut *dst, \u0026mut src); // cannot overlap\n    src\n}\n\n/// Reads the value from `src` without moving it. This leaves the\n/// memory in `src` unchanged.\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `src` must be [valid] for reads.\n///\n/// * `src` must be properly aligned. Use [`read_unaligned`] if this is not the\n///   case.\n///\n/// * `src` must point to a properly initialized value of type `T`.\n///\n/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let x = 12;\n/// let y = \u0026x as *const i32;\n///\n/// unsafe {\n///     assert_eq!(std::ptr::read(y), 12);\n/// }\n/// ```\n///\n/// Manually implement [`mem::swap`]:\n///\n/// ```\n/// use std::ptr;\n///\n/// fn swap\u003cT\u003e(a: \u0026mut T, b: \u0026mut T) {\n///     unsafe {\n///         // Create a bitwise copy of the value at `a` in `tmp`.\n///         let tmp = ptr::read(a);\n///\n///         // Exiting at this point (either by explicitly returning or by\n///         // calling a function which panics) would cause the value in `tmp` to\n///         // be dropped while the same value is still referenced by `a`. This\n///         // could trigger undefined behavior if `T` is not `Copy`.\n///\n///         // Create a bitwise copy of the value at `b` in `a`.\n///         // This is safe because mutable references cannot alias.\n///         ptr::copy_nonoverlapping(b, a, 1);\n///\n///         // As above, exiting here could trigger undefined behavior because\n///         // the same value is referenced by `a` and `b`.\n///\n///         // Move `tmp` into `b`.\n///         ptr::write(b, tmp);\n///\n///         // `tmp` has been moved (`write` takes ownership of its second argument),\n///         // so nothing is dropped implicitly here.\n///     }\n/// }\n///\n/// let mut foo = \"foo\".to_owned();\n/// let mut bar = \"bar\".to_owned();\n///\n/// swap(\u0026mut foo, \u0026mut bar);\n///\n/// assert_eq!(foo, \"bar\");\n/// assert_eq!(bar, \"foo\");\n/// ```\n///\n/// ## Ownership of the Returned Value\n///\n/// `read` creates a bitwise copy of `T`, regardless of whether `T` is [`Copy`].\n/// If `T` is not [`Copy`], using both the returned value and the value at\n/// `*src` can violate memory safety. Note that assigning to `*src` counts as a\n/// use because it will attempt to drop the value at `*src`.\n///\n/// [`write`] can be used to overwrite data without causing it to be dropped.\n///\n/// ```\n/// use std::ptr;\n///\n/// let mut s = String::from(\"foo\");\n/// unsafe {\n///     // `s2` now points to the same underlying memory as `s`.\n///     let mut s2: String = ptr::read(\u0026s);\n///\n///     assert_eq!(s2, \"foo\");\n///\n///     // Assigning to `s2` causes its original value to be dropped. Beyond\n///     // this point, `s` must no longer be used, as the underlying memory has\n///     // been freed.\n///     s2 = String::default();\n///     assert_eq!(s2, \"\");\n///\n///     // Assigning to `s` would cause the old value to be dropped again,\n///     // resulting in undefined behavior.\n///     // s = String::from(\"bar\"); // ERROR\n///\n///     // `ptr::write` can be used to overwrite a value without dropping it.\n///     ptr::write(\u0026mut s, String::from(\"bar\"));\n/// }\n///\n/// assert_eq!(s, \"bar\");\n/// ```\n///\n/// [`mem::swap`]: ../mem/fn.swap.html\n/// [valid]: ../ptr/index.html#safety\n/// [`Copy`]: ../marker/trait.Copy.html\n/// [`read_unaligned`]: ./fn.read_unaligned.html\n/// [`write`]: ./fn.write.html\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn read\u003cT\u003e(src: *const T) -\u003e T {\n    // `copy_nonoverlapping` takes care of debug_assert.\n    let mut tmp = MaybeUninit::\u003cT\u003e::uninit();\n    copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n    tmp.assume_init()\n}\n\n/// Reads the value from `src` without moving it. This leaves the\n/// memory in `src` unchanged.\n///\n/// Unlike [`read`], `read_unaligned` works with unaligned pointers.\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `src` must be [valid] for reads.\n///\n/// * `src` must point to a properly initialized value of type `T`.\n///\n/// Like [`read`], `read_unaligned` creates a bitwise copy of `T`, regardless of\n/// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the returned\n/// value and the value at `*src` can [violate memory safety][read-ownership].\n///\n/// Note that even if `T` has size `0`, the pointer must be non-NULL.\n///\n/// [`Copy`]: ../marker/trait.Copy.html\n/// [`read`]: ./fn.read.html\n/// [`write_unaligned`]: ./fn.write_unaligned.html\n/// [read-ownership]: ./fn.read.html#ownership-of-the-returned-value\n/// [valid]: ../ptr/index.html#safety\n///\n/// ## On `packed` structs\n///\n/// It is currently impossible to create raw pointers to unaligned fields\n/// of a packed struct.\n///\n/// Attempting to create a raw pointer to an `unaligned` struct field with\n/// an expression such as `\u0026packed.unaligned as *const FieldType` creates an\n/// intermediate unaligned reference before converting that to a raw pointer.\n/// That this reference is temporary and immediately cast is inconsequential\n/// as the compiler always expects references to be properly aligned.\n/// As a result, using `\u0026packed.unaligned as *const FieldType` causes immediate\n/// *undefined behavior* in your program.\n///\n/// An example of what not to do and how this relates to `read_unaligned` is:\n///\n/// ```no_run\n/// #[repr(packed, C)]\n/// struct Packed {\n///     _padding: u8,\n///     unaligned: u32,\n/// }\n///\n/// let packed = Packed {\n///     _padding: 0x00,\n///     unaligned: 0x01020304,\n/// };\n///\n/// let v = unsafe {\n///     // Here we attempt to take the address of a 32-bit integer which is not aligned.\n///     let unaligned =\n///         // A temporary unaligned reference is created here which results in\n///         // undefined behavior regardless of whether the reference is used or not.\n///         \u0026packed.unaligned\n///         // Casting to a raw pointer doesn't help; the mistake already happened.\n///         as *const u32;\n///\n///     let v = std::ptr::read_unaligned(unaligned);\n///\n///     v\n/// };\n/// ```\n///\n/// Accessing unaligned fields directly with e.g. `packed.unaligned` is safe however.\n// FIXME: Update docs based on outcome of RFC #2582 and friends.\n///\n/// # Examples\n///\n/// Read an usize value from a byte buffer:\n///\n/// ```\n/// use std::mem;\n///\n/// fn read_usize(x: \u0026[u8]) -\u003e usize {\n///     assert!(x.len() \u003e= mem::size_of::\u003cusize\u003e());\n///\n///     let ptr = x.as_ptr() as *const usize;\n///\n///     unsafe { ptr.read_unaligned() }\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\npub unsafe fn read_unaligned\u003cT\u003e(src: *const T) -\u003e T {\n    // `copy_nonoverlapping` takes care of debug_assert.\n    let mut tmp = MaybeUninit::\u003cT\u003e::uninit();\n    copy_nonoverlapping(src as *const u8, tmp.as_mut_ptr() as *mut u8, mem::size_of::\u003cT\u003e());\n    tmp.assume_init()\n}\n\n/// Overwrites a memory location with the given value without reading or\n/// dropping the old value.\n///\n/// `write` does not drop the contents of `dst`. This is safe, but it could leak\n/// allocations or resources, so care should be taken not to overwrite an object\n/// that should be dropped.\n///\n/// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n/// location pointed to by `dst`.\n///\n/// This is appropriate for initializing uninitialized memory, or overwriting\n/// memory that has previously been [`read`] from.\n///\n/// [`read`]: ./fn.read.html\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `dst` must be [valid] for writes.\n///\n/// * `dst` must be properly aligned. Use [`write_unaligned`] if this is not the\n///   case.\n///\n/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n///\n/// [valid]: ../ptr/index.html#safety\n/// [`write_unaligned`]: ./fn.write_unaligned.html\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let mut x = 0;\n/// let y = \u0026mut x as *mut i32;\n/// let z = 12;\n///\n/// unsafe {\n///     std::ptr::write(y, z);\n///     assert_eq!(std::ptr::read(y), 12);\n/// }\n/// ```\n///\n/// Manually implement [`mem::swap`]:\n///\n/// ```\n/// use std::ptr;\n///\n/// fn swap\u003cT\u003e(a: \u0026mut T, b: \u0026mut T) {\n///     unsafe {\n///         // Create a bitwise copy of the value at `a` in `tmp`.\n///         let tmp = ptr::read(a);\n///\n///         // Exiting at this point (either by explicitly returning or by\n///         // calling a function which panics) would cause the value in `tmp` to\n///         // be dropped while the same value is still referenced by `a`. This\n///         // could trigger undefined behavior if `T` is not `Copy`.\n///\n///         // Create a bitwise copy of the value at `b` in `a`.\n///         // This is safe because mutable references cannot alias.\n///         ptr::copy_nonoverlapping(b, a, 1);\n///\n///         // As above, exiting here could trigger undefined behavior because\n///         // the same value is referenced by `a` and `b`.\n///\n///         // Move `tmp` into `b`.\n///         ptr::write(b, tmp);\n///\n///         // `tmp` has been moved (`write` takes ownership of its second argument),\n///         // so nothing is dropped implicitly here.\n///     }\n/// }\n///\n/// let mut foo = \"foo\".to_owned();\n/// let mut bar = \"bar\".to_owned();\n///\n/// swap(\u0026mut foo, \u0026mut bar);\n///\n/// assert_eq!(foo, \"bar\");\n/// assert_eq!(bar, \"foo\");\n/// ```\n///\n/// [`mem::swap`]: ../mem/fn.swap.html\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn write\u003cT\u003e(dst: *mut T, src: T) {\n    debug_assert!(is_aligned_and_not_null(dst), \"attempt to write to unaligned or null pointer\");\n    intrinsics::move_val_init(\u0026mut *dst, src)\n}\n\n/// Overwrites a memory location with the given value without reading or\n/// dropping the old value.\n///\n/// Unlike [`write`], the pointer may be unaligned.\n///\n/// `write_unaligned` does not drop the contents of `dst`. This is safe, but it\n/// could leak allocations or resources, so care should be taken not to overwrite\n/// an object that should be dropped.\n///\n/// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n/// location pointed to by `dst`.\n///\n/// This is appropriate for initializing uninitialized memory, or overwriting\n/// memory that has previously been read with [`read_unaligned`].\n///\n/// [`write`]: ./fn.write.html\n/// [`read_unaligned`]: ./fn.read_unaligned.html\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `dst` must be [valid] for writes.\n///\n/// Note that even if `T` has size `0`, the pointer must be non-NULL.\n///\n/// [valid]: ../ptr/index.html#safety\n///\n/// ## On `packed` structs\n///\n/// It is currently impossible to create raw pointers to unaligned fields\n/// of a packed struct.\n///\n/// Attempting to create a raw pointer to an `unaligned` struct field with\n/// an expression such as `\u0026packed.unaligned as *const FieldType` creates an\n/// intermediate unaligned reference before converting that to a raw pointer.\n/// That this reference is temporary and immediately cast is inconsequential\n/// as the compiler always expects references to be properly aligned.\n/// As a result, using `\u0026packed.unaligned as *const FieldType` causes immediate\n/// *undefined behavior* in your program.\n///\n/// An example of what not to do and how this relates to `write_unaligned` is:\n///\n/// ```no_run\n/// #[repr(packed, C)]\n/// struct Packed {\n///     _padding: u8,\n///     unaligned: u32,\n/// }\n///\n/// let v = 0x01020304;\n/// let mut packed: Packed = unsafe { std::mem::zeroed() };\n///\n/// let v = unsafe {\n///     // Here we attempt to take the address of a 32-bit integer which is not aligned.\n///     let unaligned =\n///         // A temporary unaligned reference is created here which results in\n///         // undefined behavior regardless of whether the reference is used or not.\n///         \u0026mut packed.unaligned\n///         // Casting to a raw pointer doesn't help; the mistake already happened.\n///         as *mut u32;\n///\n///     std::ptr::write_unaligned(unaligned, v);\n///\n///     v\n/// };\n/// ```\n///\n/// Accessing unaligned fields directly with e.g. `packed.unaligned` is safe however.\n// FIXME: Update docs based on outcome of RFC #2582 and friends.\n///\n/// # Examples\n///\n/// Write an usize value to a byte buffer:\n///\n/// ```\n/// use std::mem;\n///\n/// fn write_usize(x: \u0026mut [u8], val: usize) {\n///     assert!(x.len() \u003e= mem::size_of::\u003cusize\u003e());\n///\n///     let ptr = x.as_mut_ptr() as *mut usize;\n///\n///     unsafe { ptr.write_unaligned(val) }\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\npub unsafe fn write_unaligned\u003cT\u003e(dst: *mut T, src: T) {\n    // `copy_nonoverlapping` takes care of debug_assert.\n    copy_nonoverlapping(\u0026src as *const T as *const u8, dst as *mut u8, mem::size_of::\u003cT\u003e());\n    mem::forget(src);\n}\n\n/// Performs a volatile read of the value from `src` without moving it. This\n/// leaves the memory in `src` unchanged.\n///\n/// Volatile operations are intended to act on I/O memory, and are guaranteed\n/// to not be elided or reordered by the compiler across other volatile\n/// operations.\n///\n/// [`write_volatile`]: ./fn.write_volatile.html\n///\n/// # Notes\n///\n/// Rust does not currently have a rigorously and formally defined memory model,\n/// so the precise semantics of what \"volatile\" means here is subject to change\n/// over time. That being said, the semantics will almost always end up pretty\n/// similar to [C11's definition of volatile][c11].\n///\n/// The compiler shouldn't change the relative order or number of volatile\n/// memory operations. However, volatile memory operations on zero-sized types\n/// (e.g., if a zero-sized type is passed to `read_volatile`) are noops\n/// and may be ignored.\n///\n/// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `src` must be [valid] for reads.\n///\n/// * `src` must be properly aligned.\n///\n/// * `src` must point to a properly initialized value of type `T`.\n///\n/// Like [`read`], `read_volatile` creates a bitwise copy of `T`, regardless of\n/// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the returned\n/// value and the value at `*src` can [violate memory safety][read-ownership].\n/// However, storing non-[`Copy`] types in volatile memory is almost certainly\n/// incorrect.\n///\n/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n///\n/// [valid]: ../ptr/index.html#safety\n/// [`Copy`]: ../marker/trait.Copy.html\n/// [`read`]: ./fn.read.html\n/// [read-ownership]: ./fn.read.html#ownership-of-the-returned-value\n///\n/// Just like in C, whether an operation is volatile has no bearing whatsoever\n/// on questions involving concurrent access from multiple threads. Volatile\n/// accesses behave exactly like non-atomic accesses in that regard. In particular,\n/// a race between a `read_volatile` and any write operation to the same location\n/// is undefined behavior.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let x = 12;\n/// let y = \u0026x as *const i32;\n///\n/// unsafe {\n///     assert_eq!(std::ptr::read_volatile(y), 12);\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"volatile\", since = \"1.9.0\")]\npub unsafe fn read_volatile\u003cT\u003e(src: *const T) -\u003e T {\n    debug_assert!(is_aligned_and_not_null(src), \"attempt to read from unaligned or null pointer\");\n    intrinsics::volatile_load(src)\n}\n\n/// Performs a volatile write of a memory location with the given value without\n/// reading or dropping the old value.\n///\n/// Volatile operations are intended to act on I/O memory, and are guaranteed\n/// to not be elided or reordered by the compiler across other volatile\n/// operations.\n///\n/// `write_volatile` does not drop the contents of `dst`. This is safe, but it\n/// could leak allocations or resources, so care should be taken not to overwrite\n/// an object that should be dropped.\n///\n/// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n/// location pointed to by `dst`.\n///\n/// [`read_volatile`]: ./fn.read_volatile.html\n///\n/// # Notes\n///\n/// Rust does not currently have a rigorously and formally defined memory model,\n/// so the precise semantics of what \"volatile\" means here is subject to change\n/// over time. That being said, the semantics will almost always end up pretty\n/// similar to [C11's definition of volatile][c11].\n///\n/// The compiler shouldn't change the relative order or number of volatile\n/// memory operations. However, volatile memory operations on zero-sized types\n/// (e.g., if a zero-sized type is passed to `write_volatile`) are noops\n/// and may be ignored.\n///\n/// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `dst` must be [valid] for writes.\n///\n/// * `dst` must be properly aligned.\n///\n/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n///\n/// [valid]: ../ptr/index.html#safety\n///\n/// Just like in C, whether an operation is volatile has no bearing whatsoever\n/// on questions involving concurrent access from multiple threads. Volatile\n/// accesses behave exactly like non-atomic accesses in that regard. In particular,\n/// a race between a `write_volatile` and any other operation (reading or writing)\n/// on the same location is undefined behavior.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let mut x = 0;\n/// let y = \u0026mut x as *mut i32;\n/// let z = 12;\n///\n/// unsafe {\n///     std::ptr::write_volatile(y, z);\n///     assert_eq!(std::ptr::read_volatile(y), 12);\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"volatile\", since = \"1.9.0\")]\npub unsafe fn write_volatile\u003cT\u003e(dst: *mut T, src: T) {\n    debug_assert!(is_aligned_and_not_null(dst), \"attempt to write to unaligned or null pointer\");\n    intrinsics::volatile_store(dst, src);\n}\n\n/// Align pointer `p`.\n///\n/// Calculate offset (in terms of elements of `stride` stride) that has to be applied\n/// to pointer `p` so that pointer `p` would get aligned to `a`.\n///\n/// Note: This implementation has been carefully tailored to not panic. It is UB for this to panic.\n/// The only real change that can be made here is change of `INV_TABLE_MOD_16` and associated\n/// constants.\n///\n/// If we ever decide to make it possible to call the intrinsic with `a` that is not a\n/// power-of-two, it will probably be more prudent to just change to a naive implementation rather\n/// than trying to adapt this to accommodate that change.\n///\n/// Any questions go to @nagisa.\n#[lang = \"align_offset\"]\npub(crate) unsafe fn align_offset\u003cT: Sized\u003e(p: *const T, a: usize) -\u003e usize {\n    /// Calculate multiplicative modular inverse of `x` modulo `m`.\n    ///\n    /// This implementation is tailored for align_offset and has following preconditions:\n    ///\n    /// * `m` is a power-of-two;\n    /// * `x \u003c m`; (if `x ≥ m`, pass in `x % m` instead)\n    ///\n    /// Implementation of this function shall not panic. Ever.\n    #[inline]\n    fn mod_inv(x: usize, m: usize) -\u003e usize {\n        /// Multiplicative modular inverse table modulo 2⁴ = 16.\n        ///\n        /// Note, that this table does not contain values where inverse does not exist (i.e., for\n        /// `0⁻¹ mod 16`, `2⁻¹ mod 16`, etc.)\n        const INV_TABLE_MOD_16: [u8; 8] = [1, 11, 13, 7, 9, 3, 5, 15];\n        /// Modulo for which the `INV_TABLE_MOD_16` is intended.\n        const INV_TABLE_MOD: usize = 16;\n        /// INV_TABLE_MOD²\n        const INV_TABLE_MOD_SQUARED: usize = INV_TABLE_MOD * INV_TABLE_MOD;\n\n        let table_inverse = INV_TABLE_MOD_16[(x \u0026 (INV_TABLE_MOD - 1)) \u003e\u003e 1] as usize;\n        if m \u003c= INV_TABLE_MOD {\n            table_inverse \u0026 (m - 1)\n        } else {\n            // We iterate \"up\" using the following formula:\n            //\n            // $$ xy ≡ 1 (mod 2ⁿ) → xy (2 - xy) ≡ 1 (mod 2²ⁿ) $$\n            //\n            // until 2²ⁿ ≥ m. Then we can reduce to our desired `m` by taking the result `mod m`.\n            let mut inverse = table_inverse;\n            let mut going_mod = INV_TABLE_MOD_SQUARED;\n            loop {\n                // y = y * (2 - xy) mod n\n                //\n                // Note, that we use wrapping operations here intentionally – the original formula\n                // uses e.g., subtraction `mod n`. It is entirely fine to do them `mod\n                // usize::max_value()` instead, because we take the result `mod n` at the end\n                // anyway.\n                inverse = inverse.wrapping_mul(2usize.wrapping_sub(x.wrapping_mul(inverse)));\n                if going_mod \u003e= m {\n                    return inverse \u0026 (m - 1);\n                }\n                going_mod = going_mod.wrapping_mul(going_mod);\n            }\n        }\n    }\n\n    let stride = mem::size_of::\u003cT\u003e();\n    let a_minus_one = a.wrapping_sub(1);\n    let pmoda = p as usize \u0026 a_minus_one;\n\n    if pmoda == 0 {\n        // Already aligned. Yay!\n        return 0;\n    }\n\n    if stride \u003c= 1 {\n        return if stride == 0 {\n            // If the pointer is not aligned, and the element is zero-sized, then no amount of\n            // elements will ever align the pointer.\n            !0\n        } else {\n            a.wrapping_sub(pmoda)\n        };\n    }\n\n    let smoda = stride \u0026 a_minus_one;\n    // a is power-of-two so cannot be 0. stride = 0 is handled above.\n    let gcdpow = intrinsics::cttz_nonzero(stride).min(intrinsics::cttz_nonzero(a));\n    let gcd = 1usize \u003c\u003c gcdpow;\n\n    if p as usize \u0026 (gcd.wrapping_sub(1)) == 0 {\n        // This branch solves for the following linear congruence equation:\n        //\n        // ` p + so = 0 mod a `\n        //\n        // `p` here is the pointer value, `s` - stride of `T`, `o` offset in `T`s, and `a` - the\n        // requested alignment.\n        //\n        // With `g = gcd(a, s)`, and the above asserting that `p` is also divisible by `g`, we can\n        // denote `a' = a/g`, `s' = s/g`, `p' = p/g`, then this becomes equivalent to:\n        //\n        // ` p' + s'o = 0 mod a' `\n        // ` o = (a' - (p' mod a')) * (s'^-1 mod a') `\n        //\n        // The first term is \"the relative alignment of `p` to `a`\" (divided by the `g`), the second\n        // term is \"how does incrementing `p` by `s` bytes change the relative alignment of `p`\" (again\n        // divided by `g`).\n        // Division by `g` is necessary to make the inverse well formed if `a` and `s` are not\n        // co-prime.\n        //\n        // Furthermore, the result produced by this solution is not \"minimal\", so it is necessary\n        // to take the result `o mod lcm(s, a)`. We can replace `lcm(s, a)` with just a `a'`.\n        let a2 = a \u003e\u003e gcdpow;\n        let a2minus1 = a2.wrapping_sub(1);\n        let s2 = smoda \u003e\u003e gcdpow;\n        let minusp2 = a2.wrapping_sub(pmoda \u003e\u003e gcdpow);\n        return (minusp2.wrapping_mul(mod_inv(s2, a2))) \u0026 a2minus1;\n    }\n\n    // Cannot be aligned at all.\n    usize::max_value()\n}\n\n/// Compares raw pointers for equality.\n///\n/// This is the same as using the `==` operator, but less generic:\n/// the arguments have to be `*const T` raw pointers,\n/// not anything that implements `PartialEq`.\n///\n/// This can be used to compare `\u0026T` references (which coerce to `*const T` implicitly)\n/// by their address rather than comparing the values they point to\n/// (which is what the `PartialEq for \u0026T` implementation does).\n///\n/// # Examples\n///\n/// ```\n/// use std::ptr;\n///\n/// let five = 5;\n/// let other_five = 5;\n/// let five_ref = \u0026five;\n/// let same_five_ref = \u0026five;\n/// let other_five_ref = \u0026other_five;\n///\n/// assert!(five_ref == same_five_ref);\n/// assert!(ptr::eq(five_ref, same_five_ref));\n///\n/// assert!(five_ref == other_five_ref);\n/// assert!(!ptr::eq(five_ref, other_five_ref));\n/// ```\n///\n/// Slices are also compared by their length (fat pointers):\n///\n/// ```\n/// let a = [1, 2, 3];\n/// assert!(std::ptr::eq(\u0026a[..3], \u0026a[..3]));\n/// assert!(!std::ptr::eq(\u0026a[..2], \u0026a[..3]));\n/// assert!(!std::ptr::eq(\u0026a[0..2], \u0026a[1..3]));\n/// ```\n///\n/// Traits are also compared by their implementation:\n///\n/// ```\n/// #[repr(transparent)]\n/// struct Wrapper { member: i32 }\n///\n/// trait Trait {}\n/// impl Trait for Wrapper {}\n/// impl Trait for i32 {}\n///\n/// let wrapper = Wrapper { member: 10 };\n///\n/// // Pointers have equal addresses.\n/// assert!(std::ptr::eq(\n///     \u0026wrapper as *const Wrapper as *const u8,\n///     \u0026wrapper.member as *const i32 as *const u8\n/// ));\n///\n/// // Objects have equal addresses, but `Trait` has different implementations.\n/// assert!(!std::ptr::eq(\n///     \u0026wrapper as \u0026dyn Trait,\n///     \u0026wrapper.member as \u0026dyn Trait,\n/// ));\n/// assert!(!std::ptr::eq(\n///     \u0026wrapper as \u0026dyn Trait as *const dyn Trait,\n///     \u0026wrapper.member as \u0026dyn Trait as *const dyn Trait,\n/// ));\n///\n/// // Converting the reference to a `*const u8` compares by address.\n/// assert!(std::ptr::eq(\n///     \u0026wrapper as \u0026dyn Trait as *const dyn Trait as *const u8,\n///     \u0026wrapper.member as \u0026dyn Trait as *const dyn Trait as *const u8,\n/// ));\n/// ```\n#[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n#[inline]\npub fn eq\u003cT: ?Sized\u003e(a: *const T, b: *const T) -\u003e bool {\n    a == b\n}\n\n/// Hash a raw pointer.\n///\n/// This can be used to hash a `\u0026T` reference (which coerces to `*const T` implicitly)\n/// by its address rather than the value it points to\n/// (which is what the `Hash for \u0026T` implementation does).\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::hash_map::DefaultHasher;\n/// use std::hash::{Hash, Hasher};\n/// use std::ptr;\n///\n/// let five = 5;\n/// let five_ref = \u0026five;\n///\n/// let mut hasher = DefaultHasher::new();\n/// ptr::hash(five_ref, \u0026mut hasher);\n/// let actual = hasher.finish();\n///\n/// let mut hasher = DefaultHasher::new();\n/// (five_ref as *const i32).hash(\u0026mut hasher);\n/// let expected = hasher.finish();\n///\n/// assert_eq!(actual, expected);\n/// ```\n#[stable(feature = \"ptr_hash\", since = \"1.35.0\")]\npub fn hash\u003cT: ?Sized, S: hash::Hasher\u003e(hashee: *const T, into: \u0026mut S) {\n    use crate::hash::Hash;\n    hashee.hash(into);\n}\n\n// Impls for function pointers\nmacro_rules! fnptr_impls_safety_abi {\n    ($FnTy: ty, $($Arg: ident),*) =\u003e {\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl\u003cRet, $($Arg),*\u003e PartialEq for $FnTy {\n            #[inline]\n            fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n                *self as usize == *other as usize\n            }\n        }\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl\u003cRet, $($Arg),*\u003e Eq for $FnTy {}\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl\u003cRet, $($Arg),*\u003e PartialOrd for $FnTy {\n            #[inline]\n            fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n                (*self as usize).partial_cmp(\u0026(*other as usize))\n            }\n        }\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl\u003cRet, $($Arg),*\u003e Ord for $FnTy {\n            #[inline]\n            fn cmp(\u0026self, other: \u0026Self) -\u003e Ordering {\n                (*self as usize).cmp(\u0026(*other as usize))\n            }\n        }\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl\u003cRet, $($Arg),*\u003e hash::Hash for $FnTy {\n            fn hash\u003cHH: hash::Hasher\u003e(\u0026self, state: \u0026mut HH) {\n                state.write_usize(*self as usize)\n            }\n        }\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl\u003cRet, $($Arg),*\u003e fmt::Pointer for $FnTy {\n            fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                fmt::Pointer::fmt(\u0026(*self as *const ()), f)\n            }\n        }\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl\u003cRet, $($Arg),*\u003e fmt::Debug for $FnTy {\n            fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                fmt::Pointer::fmt(\u0026(*self as *const ()), f)\n            }\n        }\n    }\n}\n\nmacro_rules! fnptr_impls_args {\n    ($($Arg: ident),+) =\u003e {\n        fnptr_impls_safety_abi! { extern \"Rust\" fn($($Arg),+) -\u003e Ret, $($Arg),+ }\n        fnptr_impls_safety_abi! { extern \"C\" fn($($Arg),+) -\u003e Ret, $($Arg),+ }\n        fnptr_impls_safety_abi! { extern \"C\" fn($($Arg),+ , ...) -\u003e Ret, $($Arg),+ }\n        fnptr_impls_safety_abi! { unsafe extern \"Rust\" fn($($Arg),+) -\u003e Ret, $($Arg),+ }\n        fnptr_impls_safety_abi! { unsafe extern \"C\" fn($($Arg),+) -\u003e Ret, $($Arg),+ }\n        fnptr_impls_safety_abi! { unsafe extern \"C\" fn($($Arg),+ , ...) -\u003e Ret, $($Arg),+ }\n    };\n    () =\u003e {\n        // No variadic functions with 0 parameters\n        fnptr_impls_safety_abi! { extern \"Rust\" fn() -\u003e Ret, }\n        fnptr_impls_safety_abi! { extern \"C\" fn() -\u003e Ret, }\n        fnptr_impls_safety_abi! { unsafe extern \"Rust\" fn() -\u003e Ret, }\n        fnptr_impls_safety_abi! { unsafe extern \"C\" fn() -\u003e Ret, }\n    };\n}\n\nfnptr_impls_args! {}\nfnptr_impls_args! { A }\nfnptr_impls_args! { A, B }\nfnptr_impls_args! { A, B, C }\nfnptr_impls_args! { A, B, C, D }\nfnptr_impls_args! { A, B, C, D, E }\nfnptr_impls_args! { A, B, C, D, E, F }\nfnptr_impls_args! { A, B, C, D, E, F, G }\nfnptr_impls_args! { A, B, C, D, E, F, G, H }\nfnptr_impls_args! { A, B, C, D, E, F, G, H, I }\nfnptr_impls_args! { A, B, C, D, E, F, G, H, I, J }\nfnptr_impls_args! { A, B, C, D, E, F, G, H, I, J, K }\nfnptr_impls_args! { A, B, C, D, E, F, G, H, I, J, K, L }\n","traces":[{"line":184,"address":[4212208,4212217,4212222],"length":1,"stats":{"Line":0},"fn_name":"drop_in_place\u003cclosure-0\u003e"}],"covered":0,"coverable":1},{"path":["/","usr","local","rustup","toolchains","1.45.2-x86_64-unknown-linux-gnu","lib","rustlib","src","rust","src","libstd","macros.rs"],"content":"//! Standard library macros\n//!\n//! This modules contains a set of macros which are exported from the standard\n//! library. Each macro is available for use when linking against the standard\n//! library.\n\n#[doc(include = \"../libcore/macros/panic.md\")]\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow_internal_unstable(libstd_sys_internals)]\nmacro_rules! panic {\n    () =\u003e ({ $crate::panic!(\"explicit panic\") });\n    ($msg:expr) =\u003e ({ $crate::rt::begin_panic($msg) });\n    ($msg:expr,) =\u003e ({ $crate::panic!($msg) });\n    ($fmt:expr, $($arg:tt)+) =\u003e ({\n        $crate::rt::begin_panic_fmt(\u0026$crate::format_args!($fmt, $($arg)+))\n    });\n}\n\n/// Prints to the standard output.\n///\n/// Equivalent to the [`println!`] macro except that a newline is not printed at\n/// the end of the message.\n///\n/// Note that stdout is frequently line-buffered by default so it may be\n/// necessary to use [`io::stdout().flush()`][flush] to ensure the output is emitted\n/// immediately.\n///\n/// Use `print!` only for the primary output of your program. Use\n/// [`eprint!`] instead to print error and progress messages.\n///\n/// [`println!`]: ../std/macro.println.html\n/// [flush]: ../std/io/trait.Write.html#tymethod.flush\n/// [`eprint!`]: ../std/macro.eprint.html\n///\n/// # Panics\n///\n/// Panics if writing to `io::stdout()` fails.\n///\n/// # Examples\n///\n/// ```\n/// use std::io::{self, Write};\n///\n/// print!(\"this \");\n/// print!(\"will \");\n/// print!(\"be \");\n/// print!(\"on \");\n/// print!(\"the \");\n/// print!(\"same \");\n/// print!(\"line \");\n///\n/// io::stdout().flush().unwrap();\n///\n/// print!(\"this string has a newline, why not choose println! instead?\\n\");\n///\n/// io::stdout().flush().unwrap();\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow_internal_unstable(print_internals)]\nmacro_rules! print {\n    ($($arg:tt)*) =\u003e ($crate::io::_print($crate::format_args!($($arg)*)));\n}\n\n/// Prints to the standard output, with a newline.\n///\n/// On all platforms, the newline is the LINE FEED character (`\\n`/`U+000A`) alone\n/// (no additional CARRIAGE RETURN (`\\r`/`U+000D`)).\n///\n/// Use the [`format!`] syntax to write data to the standard output.\n/// See [`std::fmt`] for more information.\n///\n/// Use `println!` only for the primary output of your program. Use\n/// [`eprintln!`] instead to print error and progress messages.\n///\n/// [`format!`]: ../std/macro.format.html\n/// [`std::fmt`]: ../std/fmt/index.html\n/// [`eprintln!`]: ../std/macro.eprintln.html\n/// # Panics\n///\n/// Panics if writing to `io::stdout` fails.\n///\n/// # Examples\n///\n/// ```\n/// println!(); // prints just a newline\n/// println!(\"hello there!\");\n/// println!(\"format {} arguments\", \"some\");\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow_internal_unstable(print_internals, format_args_nl)]\nmacro_rules! println {\n    () =\u003e ($crate::print!(\"\\n\"));\n    ($($arg:tt)*) =\u003e ({\n        $crate::io::_print($crate::format_args_nl!($($arg)*));\n    })\n}\n\n/// Prints to the standard error.\n///\n/// Equivalent to the [`print!`] macro, except that output goes to\n/// [`io::stderr`] instead of `io::stdout`. See [`print!`] for\n/// example usage.\n///\n/// Use `eprint!` only for error and progress messages. Use `print!`\n/// instead for the primary output of your program.\n///\n/// [`io::stderr`]: ../std/io/struct.Stderr.html\n/// [`print!`]: ../std/macro.print.html\n///\n/// # Panics\n///\n/// Panics if writing to `io::stderr` fails.\n///\n/// # Examples\n///\n/// ```\n/// eprint!(\"Error: Could not complete task\");\n/// ```\n#[macro_export]\n#[stable(feature = \"eprint\", since = \"1.19.0\")]\n#[allow_internal_unstable(print_internals)]\nmacro_rules! eprint {\n    ($($arg:tt)*) =\u003e ($crate::io::_eprint($crate::format_args!($($arg)*)));\n}\n\n/// Prints to the standard error, with a newline.\n///\n/// Equivalent to the [`println!`] macro, except that output goes to\n/// [`io::stderr`] instead of `io::stdout`. See [`println!`] for\n/// example usage.\n///\n/// Use `eprintln!` only for error and progress messages. Use `println!`\n/// instead for the primary output of your program.\n///\n/// [`io::stderr`]: ../std/io/struct.Stderr.html\n/// [`println!`]: ../std/macro.println.html\n///\n/// # Panics\n///\n/// Panics if writing to `io::stderr` fails.\n///\n/// # Examples\n///\n/// ```\n/// eprintln!(\"Error: Could not complete task\");\n/// ```\n#[macro_export]\n#[stable(feature = \"eprint\", since = \"1.19.0\")]\n#[allow_internal_unstable(print_internals, format_args_nl)]\nmacro_rules! eprintln {\n    () =\u003e ($crate::eprint!(\"\\n\"));\n    ($($arg:tt)*) =\u003e ({\n        $crate::io::_eprint($crate::format_args_nl!($($arg)*));\n    })\n}\n\n/// Prints and returns the value of a given expression for quick and dirty\n/// debugging.\n///\n/// An example:\n///\n/// ```rust\n/// let a = 2;\n/// let b = dbg!(a * 2) + 1;\n/// //      ^-- prints: [src/main.rs:2] a * 2 = 4\n/// assert_eq!(b, 5);\n/// ```\n///\n/// The macro works by using the `Debug` implementation of the type of\n/// the given expression to print the value to [stderr] along with the\n/// source location of the macro invocation as well as the source code\n/// of the expression.\n///\n/// Invoking the macro on an expression moves and takes ownership of it\n/// before returning the evaluated expression unchanged. If the type\n/// of the expression does not implement `Copy` and you don't want\n/// to give up ownership, you can instead borrow with `dbg!(\u0026expr)`\n/// for some expression `expr`.\n///\n/// The `dbg!` macro works exactly the same in release builds.\n/// This is useful when debugging issues that only occur in release\n/// builds or when debugging in release mode is significantly faster.\n///\n/// Note that the macro is intended as a debugging tool and therefore you\n/// should avoid having uses of it in version control for long periods.\n/// Use cases involving debug output that should be added to version control\n/// are better served by macros such as [`debug!`] from the [`log`] crate.\n///\n/// # Stability\n///\n/// The exact output printed by this macro should not be relied upon\n/// and is subject to future changes.\n///\n/// # Panics\n///\n/// Panics if writing to `io::stderr` fails.\n///\n/// # Further examples\n///\n/// With a method call:\n///\n/// ```rust\n/// fn foo(n: usize) {\n///     if let Some(_) = dbg!(n.checked_sub(4)) {\n///         // ...\n///     }\n/// }\n///\n/// foo(3)\n/// ```\n///\n/// This prints to [stderr]:\n///\n/// ```text,ignore\n/// [src/main.rs:4] n.checked_sub(4) = None\n/// ```\n///\n/// Naive factorial implementation:\n///\n/// ```rust\n/// fn factorial(n: u32) -\u003e u32 {\n///     if dbg!(n \u003c= 1) {\n///         dbg!(1)\n///     } else {\n///         dbg!(n * factorial(n - 1))\n///     }\n/// }\n///\n/// dbg!(factorial(4));\n/// ```\n///\n/// This prints to [stderr]:\n///\n/// ```text,ignore\n/// [src/main.rs:3] n \u003c= 1 = false\n/// [src/main.rs:3] n \u003c= 1 = false\n/// [src/main.rs:3] n \u003c= 1 = false\n/// [src/main.rs:3] n \u003c= 1 = true\n/// [src/main.rs:4] 1 = 1\n/// [src/main.rs:5] n * factorial(n - 1) = 2\n/// [src/main.rs:5] n * factorial(n - 1) = 6\n/// [src/main.rs:5] n * factorial(n - 1) = 24\n/// [src/main.rs:11] factorial(4) = 24\n/// ```\n///\n/// The `dbg!(..)` macro moves the input:\n///\n/// ```compile_fail\n/// /// A wrapper around `usize` which importantly is not Copyable.\n/// #[derive(Debug)]\n/// struct NoCopy(usize);\n///\n/// let a = NoCopy(42);\n/// let _ = dbg!(a); // \u003c-- `a` is moved here.\n/// let _ = dbg!(a); // \u003c-- `a` is moved again; error!\n/// ```\n///\n/// You can also use `dbg!()` without a value to just print the\n/// file and line whenever it's reached.\n///\n/// Finally, if you want to `dbg!(..)` multiple values, it will treat them as\n/// a tuple (and return it, too):\n///\n/// ```\n/// assert_eq!(dbg!(1usize, 2u32), (1, 2));\n/// ```\n///\n/// However, a single argument with a trailing comma will still not be treated\n/// as a tuple, following the convention of ignoring trailing commas in macro\n/// invocations. You can use a 1-tuple directly if you need one:\n///\n/// ```\n/// assert_eq!(1, dbg!(1u32,)); // trailing comma ignored\n/// assert_eq!((1,), dbg!((1u32,))); // 1-tuple\n/// ```\n///\n/// [stderr]: https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)\n/// [`debug!`]: https://docs.rs/log/*/log/macro.debug.html\n/// [`log`]: https://crates.io/crates/log\n#[macro_export]\n#[stable(feature = \"dbg_macro\", since = \"1.32.0\")]\nmacro_rules! dbg {\n    () =\u003e {\n        $crate::eprintln!(\"[{}:{}]\", $crate::file!(), $crate::line!());\n    };\n    ($val:expr) =\u003e {\n        // Use of `match` here is intentional because it affects the lifetimes\n        // of temporaries - https://stackoverflow.com/a/48732525/1063961\n        match $val {\n            tmp =\u003e {\n                $crate::eprintln!(\"[{}:{}] {} = {:#?}\",\n                    $crate::file!(), $crate::line!(), $crate::stringify!($val), \u0026tmp);\n                tmp\n            }\n        }\n    };\n    // Trailing comma with single argument is ignored\n    ($val:expr,) =\u003e { $crate::dbg!($val) };\n    ($($val:expr),+ $(,)?) =\u003e {\n        ($($crate::dbg!($val)),+,)\n    };\n}\n\n#[cfg(test)]\nmacro_rules! assert_approx_eq {\n    ($a:expr, $b:expr) =\u003e {{\n        let (a, b) = (\u0026$a, \u0026$b);\n        assert!((*a - *b).abs() \u003c 1.0e-6, \"{} is not approximately equal to {}\", *a, *b);\n    }};\n}\n","traces":[{"line":16,"address":[4211813,4211717],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":1},{"path":["/","usr","local","rustup","toolchains","1.45.2-x86_64-unknown-linux-gnu","lib","rustlib","src","rust","src","libstd","process.rs"],"content":"//! A module for working with processes.\n//!\n//! This module is mostly concerned with spawning and interacting with child\n//! processes, but it also provides [`abort`] and [`exit`] for terminating the\n//! current process.\n//!\n//! # Spawning a process\n//!\n//! The [`Command`] struct is used to configure and spawn processes:\n//!\n//! ```no_run\n//! use std::process::Command;\n//!\n//! let output = Command::new(\"echo\")\n//!                      .arg(\"Hello world\")\n//!                      .output()\n//!                      .expect(\"Failed to execute command\");\n//!\n//! assert_eq!(b\"Hello world\\n\", output.stdout.as_slice());\n//! ```\n//!\n//! Several methods on [`Command`], such as [`spawn`] or [`output`], can be used\n//! to spawn a process. In particular, [`output`] spawns the child process and\n//! waits until the process terminates, while [`spawn`] will return a [`Child`]\n//! that represents the spawned child process.\n//!\n//! # Handling I/O\n//!\n//! The [`stdout`], [`stdin`], and [`stderr`] of a child process can be\n//! configured by passing an [`Stdio`] to the corresponding method on\n//! [`Command`]. Once spawned, they can be accessed from the [`Child`]. For\n//! example, piping output from one command into another command can be done\n//! like so:\n//!\n//! ```no_run\n//! use std::process::{Command, Stdio};\n//!\n//! // stdout must be configured with `Stdio::piped` in order to use\n//! // `echo_child.stdout`\n//! let echo_child = Command::new(\"echo\")\n//!     .arg(\"Oh no, a tpyo!\")\n//!     .stdout(Stdio::piped())\n//!     .spawn()\n//!     .expect(\"Failed to start echo process\");\n//!\n//! // Note that `echo_child` is moved here, but we won't be needing\n//! // `echo_child` anymore\n//! let echo_out = echo_child.stdout.expect(\"Failed to open echo stdout\");\n//!\n//! let mut sed_child = Command::new(\"sed\")\n//!     .arg(\"s/tpyo/typo/\")\n//!     .stdin(Stdio::from(echo_out))\n//!     .stdout(Stdio::piped())\n//!     .spawn()\n//!     .expect(\"Failed to start sed process\");\n//!\n//! let output = sed_child.wait_with_output().expect(\"Failed to wait on sed\");\n//! assert_eq!(b\"Oh no, a typo!\\n\", output.stdout.as_slice());\n//! ```\n//!\n//! Note that [`ChildStderr`] and [`ChildStdout`] implement [`Read`] and\n//! [`ChildStdin`] implements [`Write`]:\n//!\n//! ```no_run\n//! use std::process::{Command, Stdio};\n//! use std::io::Write;\n//!\n//! let mut child = Command::new(\"/bin/cat\")\n//!     .stdin(Stdio::piped())\n//!     .stdout(Stdio::piped())\n//!     .spawn()\n//!     .expect(\"failed to execute child\");\n//!\n//! {\n//!     // limited borrow of stdin\n//!     let stdin = child.stdin.as_mut().expect(\"failed to get stdin\");\n//!     stdin.write_all(b\"test\").expect(\"failed to write to stdin\");\n//! }\n//!\n//! let output = child\n//!     .wait_with_output()\n//!     .expect(\"failed to wait on child\");\n//!\n//! assert_eq!(b\"test\", output.stdout.as_slice());\n//! ```\n//!\n//! [`abort`]: fn.abort.html\n//! [`exit`]: fn.exit.html\n//!\n//! [`Command`]: struct.Command.html\n//! [`spawn`]: struct.Command.html#method.spawn\n//! [`output`]: struct.Command.html#method.output\n//!\n//! [`Child`]: struct.Child.html\n//! [`ChildStdin`]: struct.ChildStdin.html\n//! [`ChildStdout`]: struct.ChildStdout.html\n//! [`ChildStderr`]: struct.ChildStderr.html\n//! [`Stdio`]: struct.Stdio.html\n//!\n//! [`stdout`]: struct.Command.html#method.stdout\n//! [`stdin`]: struct.Command.html#method.stdin\n//! [`stderr`]: struct.Command.html#method.stderr\n//!\n//! [`Write`]: ../io/trait.Write.html\n//! [`Read`]: ../io/trait.Read.html\n\n#![stable(feature = \"process\", since = \"1.0.0\")]\n\nuse crate::io::prelude::*;\n\nuse crate::ffi::OsStr;\nuse crate::fmt;\nuse crate::fs;\nuse crate::io::{self, Initializer, IoSlice, IoSliceMut};\nuse crate::path::Path;\nuse crate::str;\nuse crate::sys::pipe::{read2, AnonPipe};\nuse crate::sys::process as imp;\nuse crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n\n/// Representation of a running or exited child process.\n///\n/// This structure is used to represent and manage child processes. A child\n/// process is created via the [`Command`] struct, which configures the\n/// spawning process and can itself be constructed using a builder-style\n/// interface.\n///\n/// There is no implementation of [`Drop`] for child processes,\n/// so if you do not ensure the `Child` has exited then it will continue to\n/// run, even after the `Child` handle to the child process has gone out of\n/// scope.\n///\n/// Calling [`wait`](#method.wait) (or other functions that wrap around it) will make\n/// the parent process wait until the child has actually exited before\n/// continuing.\n///\n/// # Warning\n///\n/// On some system, calling [`wait`] or similar is necessary for the OS to\n/// release resources. A process that terminated but has not been waited on is\n/// still around as a \"zombie\". Leaving too many zombies around may exhaust\n/// global resources (for example process IDs).\n///\n/// The standard library does *not* automatically wait on child processes (not\n/// even if the `Child` is dropped), it is up to the application developer to do\n/// so. As a consequence, dropping `Child` handles without waiting on them first\n/// is not recommended in long-running applications.\n///\n/// # Examples\n///\n/// ```should_panic\n/// use std::process::Command;\n///\n/// let mut child = Command::new(\"/bin/cat\")\n///                         .arg(\"file.txt\")\n///                         .spawn()\n///                         .expect(\"failed to execute child\");\n///\n/// let ecode = child.wait()\n///                  .expect(\"failed to wait on child\");\n///\n/// assert!(ecode.success());\n/// ```\n///\n/// [`Command`]: struct.Command.html\n/// [`Drop`]: ../../core/ops/trait.Drop.html\n/// [`wait`]: #method.wait\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct Child {\n    handle: imp::Process,\n\n    /// The handle for writing to the child's standard input (stdin), if it has\n    /// been captured.\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub stdin: Option\u003cChildStdin\u003e,\n\n    /// The handle for reading from the child's standard output (stdout), if it\n    /// has been captured.\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub stdout: Option\u003cChildStdout\u003e,\n\n    /// The handle for reading from the child's standard error (stderr), if it\n    /// has been captured.\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub stderr: Option\u003cChildStderr\u003e,\n}\n\nimpl AsInner\u003cimp::Process\u003e for Child {\n    fn as_inner(\u0026self) -\u003e \u0026imp::Process {\n        \u0026self.handle\n    }\n}\n\nimpl FromInner\u003c(imp::Process, imp::StdioPipes)\u003e for Child {\n    fn from_inner((handle, io): (imp::Process, imp::StdioPipes)) -\u003e Child {\n        Child {\n            handle,\n            stdin: io.stdin.map(ChildStdin::from_inner),\n            stdout: io.stdout.map(ChildStdout::from_inner),\n            stderr: io.stderr.map(ChildStderr::from_inner),\n        }\n    }\n}\n\nimpl IntoInner\u003cimp::Process\u003e for Child {\n    fn into_inner(self) -\u003e imp::Process {\n        self.handle\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Child {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.debug_struct(\"Child\")\n            .field(\"stdin\", \u0026self.stdin)\n            .field(\"stdout\", \u0026self.stdout)\n            .field(\"stderr\", \u0026self.stderr)\n            .finish()\n    }\n}\n\n/// A handle to a child process's standard input (stdin).\n///\n/// This struct is used in the [`stdin`] field on [`Child`].\n///\n/// When an instance of `ChildStdin` is [dropped], the `ChildStdin`'s underlying\n/// file handle will be closed. If the child process was blocked on input prior\n/// to being dropped, it will become unblocked after dropping.\n///\n/// [`Child`]: struct.Child.html\n/// [`stdin`]: struct.Child.html#structfield.stdin\n/// [dropped]: ../ops/trait.Drop.html\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct ChildStdin {\n    inner: AnonPipe,\n}\n\n#[stable(feature = \"process\", since = \"1.0.0\")]\nimpl Write for ChildStdin {\n    fn write(\u0026mut self, buf: \u0026[u8]) -\u003e io::Result\u003cusize\u003e {\n        self.inner.write(buf)\n    }\n\n    fn write_vectored(\u0026mut self, bufs: \u0026[IoSlice\u003c'_\u003e]) -\u003e io::Result\u003cusize\u003e {\n        self.inner.write_vectored(bufs)\n    }\n\n    fn is_write_vectored(\u0026self) -\u003e bool {\n        self.inner.is_write_vectored()\n    }\n\n    fn flush(\u0026mut self) -\u003e io::Result\u003c()\u003e {\n        Ok(())\n    }\n}\n\nimpl AsInner\u003cAnonPipe\u003e for ChildStdin {\n    fn as_inner(\u0026self) -\u003e \u0026AnonPipe {\n        \u0026self.inner\n    }\n}\n\nimpl IntoInner\u003cAnonPipe\u003e for ChildStdin {\n    fn into_inner(self) -\u003e AnonPipe {\n        self.inner\n    }\n}\n\nimpl FromInner\u003cAnonPipe\u003e for ChildStdin {\n    fn from_inner(pipe: AnonPipe) -\u003e ChildStdin {\n        ChildStdin { inner: pipe }\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for ChildStdin {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.pad(\"ChildStdin { .. }\")\n    }\n}\n\n/// A handle to a child process's standard output (stdout).\n///\n/// This struct is used in the [`stdout`] field on [`Child`].\n///\n/// When an instance of `ChildStdout` is [dropped], the `ChildStdout`'s\n/// underlying file handle will be closed.\n///\n/// [`Child`]: struct.Child.html\n/// [`stdout`]: struct.Child.html#structfield.stdout\n/// [dropped]: ../ops/trait.Drop.html\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct ChildStdout {\n    inner: AnonPipe,\n}\n\n#[stable(feature = \"process\", since = \"1.0.0\")]\nimpl Read for ChildStdout {\n    fn read(\u0026mut self, buf: \u0026mut [u8]) -\u003e io::Result\u003cusize\u003e {\n        self.inner.read(buf)\n    }\n\n    fn read_vectored(\u0026mut self, bufs: \u0026mut [IoSliceMut\u003c'_\u003e]) -\u003e io::Result\u003cusize\u003e {\n        self.inner.read_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_read_vectored(\u0026self) -\u003e bool {\n        self.inner.is_read_vectored()\n    }\n\n    #[inline]\n    unsafe fn initializer(\u0026self) -\u003e Initializer {\n        Initializer::nop()\n    }\n}\n\nimpl AsInner\u003cAnonPipe\u003e for ChildStdout {\n    fn as_inner(\u0026self) -\u003e \u0026AnonPipe {\n        \u0026self.inner\n    }\n}\n\nimpl IntoInner\u003cAnonPipe\u003e for ChildStdout {\n    fn into_inner(self) -\u003e AnonPipe {\n        self.inner\n    }\n}\n\nimpl FromInner\u003cAnonPipe\u003e for ChildStdout {\n    fn from_inner(pipe: AnonPipe) -\u003e ChildStdout {\n        ChildStdout { inner: pipe }\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for ChildStdout {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.pad(\"ChildStdout { .. }\")\n    }\n}\n\n/// A handle to a child process's stderr.\n///\n/// This struct is used in the [`stderr`] field on [`Child`].\n///\n/// When an instance of `ChildStderr` is [dropped], the `ChildStderr`'s\n/// underlying file handle will be closed.\n///\n/// [`Child`]: struct.Child.html\n/// [`stderr`]: struct.Child.html#structfield.stderr\n/// [dropped]: ../ops/trait.Drop.html\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct ChildStderr {\n    inner: AnonPipe,\n}\n\n#[stable(feature = \"process\", since = \"1.0.0\")]\nimpl Read for ChildStderr {\n    fn read(\u0026mut self, buf: \u0026mut [u8]) -\u003e io::Result\u003cusize\u003e {\n        self.inner.read(buf)\n    }\n\n    fn read_vectored(\u0026mut self, bufs: \u0026mut [IoSliceMut\u003c'_\u003e]) -\u003e io::Result\u003cusize\u003e {\n        self.inner.read_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_read_vectored(\u0026self) -\u003e bool {\n        self.inner.is_read_vectored()\n    }\n\n    #[inline]\n    unsafe fn initializer(\u0026self) -\u003e Initializer {\n        Initializer::nop()\n    }\n}\n\nimpl AsInner\u003cAnonPipe\u003e for ChildStderr {\n    fn as_inner(\u0026self) -\u003e \u0026AnonPipe {\n        \u0026self.inner\n    }\n}\n\nimpl IntoInner\u003cAnonPipe\u003e for ChildStderr {\n    fn into_inner(self) -\u003e AnonPipe {\n        self.inner\n    }\n}\n\nimpl FromInner\u003cAnonPipe\u003e for ChildStderr {\n    fn from_inner(pipe: AnonPipe) -\u003e ChildStderr {\n        ChildStderr { inner: pipe }\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for ChildStderr {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.pad(\"ChildStderr { .. }\")\n    }\n}\n\n/// A process builder, providing fine-grained control\n/// over how a new process should be spawned.\n///\n/// A default configuration can be\n/// generated using `Command::new(program)`, where `program` gives a path to the\n/// program to be executed. Additional builder methods allow the configuration\n/// to be changed (for example, by adding arguments) prior to spawning:\n///\n/// ```\n/// use std::process::Command;\n///\n/// let output = if cfg!(target_os = \"windows\") {\n///     Command::new(\"cmd\")\n///             .args(\u0026[\"/C\", \"echo hello\"])\n///             .output()\n///             .expect(\"failed to execute process\")\n/// } else {\n///     Command::new(\"sh\")\n///             .arg(\"-c\")\n///             .arg(\"echo hello\")\n///             .output()\n///             .expect(\"failed to execute process\")\n/// };\n///\n/// let hello = output.stdout;\n/// ```\n///\n/// `Command` can be reused to spawn multiple processes. The builder methods\n/// change the command without needing to immediately spawn the process.\n///\n/// ```no_run\n/// use std::process::Command;\n///\n/// let mut echo_hello = Command::new(\"sh\");\n/// echo_hello.arg(\"-c\")\n///           .arg(\"echo hello\");\n/// let hello_1 = echo_hello.output().expect(\"failed to execute process\");\n/// let hello_2 = echo_hello.output().expect(\"failed to execute process\");\n/// ```\n///\n/// Similarly, you can call builder methods after spawning a process and then\n/// spawn a new process with the modified settings.\n///\n/// ```no_run\n/// use std::process::Command;\n///\n/// let mut list_dir = Command::new(\"ls\");\n///\n/// // Execute `ls` in the current directory of the program.\n/// list_dir.status().expect(\"process failed to execute\");\n///\n/// println!();\n///\n/// // Change `ls` to execute in the root directory.\n/// list_dir.current_dir(\"/\");\n///\n/// // And then execute `ls` again but in the root directory.\n/// list_dir.status().expect(\"process failed to execute\");\n/// ```\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct Command {\n    inner: imp::Command,\n}\n\nimpl Command {\n    /// Constructs a new `Command` for launching the program at\n    /// path `program`, with the following default configuration:\n    ///\n    /// * No arguments to the program\n    /// * Inherit the current process's environment\n    /// * Inherit the current process's working directory\n    /// * Inherit stdin/stdout/stderr for `spawn` or `status`, but create pipes for `output`\n    ///\n    /// Builder methods are provided to change these defaults and\n    /// otherwise configure the process.\n    ///\n    /// If `program` is not an absolute path, the `PATH` will be searched in\n    /// an OS-defined way.\n    ///\n    /// The search path to be used may be controlled by setting the\n    /// `PATH` environment variable on the Command,\n    /// but this has some implementation limitations on Windows\n    /// (see issue #37519).\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"sh\")\n    ///         .spawn()\n    ///         .expect(\"sh command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn new\u003cS: AsRef\u003cOsStr\u003e\u003e(program: S) -\u003e Command {\n        Command { inner: imp::Command::new(program.as_ref()) }\n    }\n\n    /// Adds an argument to pass to the program.\n    ///\n    /// Only one argument can be passed per use. So instead of:\n    ///\n    /// ```no_run\n    /// # std::process::Command::new(\"sh\")\n    /// .arg(\"-C /path/to/repo\")\n    /// # ;\n    /// ```\n    ///\n    /// usage would be:\n    ///\n    /// ```no_run\n    /// # std::process::Command::new(\"sh\")\n    /// .arg(\"-C\")\n    /// .arg(\"/path/to/repo\")\n    /// # ;\n    /// ```\n    ///\n    /// To pass multiple arguments see [`args`].\n    ///\n    /// [`args`]: #method.args\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"ls\")\n    ///         .arg(\"-l\")\n    ///         .arg(\"-a\")\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn arg\u003cS: AsRef\u003cOsStr\u003e\u003e(\u0026mut self, arg: S) -\u003e \u0026mut Command {\n        self.inner.arg(arg.as_ref());\n        self\n    }\n\n    /// Adds multiple arguments to pass to the program.\n    ///\n    /// To pass a single argument see [`arg`].\n    ///\n    /// [`arg`]: #method.arg\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"ls\")\n    ///         .args(\u0026[\"-l\", \"-a\"])\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn args\u003cI, S\u003e(\u0026mut self, args: I) -\u003e \u0026mut Command\n    where\n        I: IntoIterator\u003cItem = S\u003e,\n        S: AsRef\u003cOsStr\u003e,\n    {\n        for arg in args {\n            self.arg(arg.as_ref());\n        }\n        self\n    }\n\n    /// Inserts or updates an environment variable mapping.\n    ///\n    /// Note that environment variable names are case-insensitive (but case-preserving) on Windows,\n    /// and case-sensitive on all other platforms.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"ls\")\n    ///         .env(\"PATH\", \"/bin\")\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn env\u003cK, V\u003e(\u0026mut self, key: K, val: V) -\u003e \u0026mut Command\n    where\n        K: AsRef\u003cOsStr\u003e,\n        V: AsRef\u003cOsStr\u003e,\n    {\n        self.inner.env_mut().set(key.as_ref(), val.as_ref());\n        self\n    }\n\n    /// Adds or updates multiple environment variable mappings.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    /// use std::env;\n    /// use std::collections::HashMap;\n    ///\n    /// let filtered_env : HashMap\u003cString, String\u003e =\n    ///     env::vars().filter(|\u0026(ref k, _)|\n    ///         k == \"TERM\" || k == \"TZ\" || k == \"LANG\" || k == \"PATH\"\n    ///     ).collect();\n    ///\n    /// Command::new(\"printenv\")\n    ///         .stdin(Stdio::null())\n    ///         .stdout(Stdio::inherit())\n    ///         .env_clear()\n    ///         .envs(\u0026filtered_env)\n    ///         .spawn()\n    ///         .expect(\"printenv failed to start\");\n    /// ```\n    #[stable(feature = \"command_envs\", since = \"1.19.0\")]\n    pub fn envs\u003cI, K, V\u003e(\u0026mut self, vars: I) -\u003e \u0026mut Command\n    where\n        I: IntoIterator\u003cItem = (K, V)\u003e,\n        K: AsRef\u003cOsStr\u003e,\n        V: AsRef\u003cOsStr\u003e,\n    {\n        for (ref key, ref val) in vars {\n            self.inner.env_mut().set(key.as_ref(), val.as_ref());\n        }\n        self\n    }\n\n    /// Removes an environment variable mapping.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"ls\")\n    ///         .env_remove(\"PATH\")\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn env_remove\u003cK: AsRef\u003cOsStr\u003e\u003e(\u0026mut self, key: K) -\u003e \u0026mut Command {\n        self.inner.env_mut().remove(key.as_ref());\n        self\n    }\n\n    /// Clears the entire environment map for the child process.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"ls\")\n    ///         .env_clear()\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn env_clear(\u0026mut self) -\u003e \u0026mut Command {\n        self.inner.env_mut().clear();\n        self\n    }\n\n    /// Sets the working directory for the child process.\n    ///\n    /// # Platform-specific behavior\n    ///\n    /// If the program path is relative (e.g., `\"./script.sh\"`), it's ambiguous\n    /// whether it should be interpreted relative to the parent's working\n    /// directory or relative to `current_dir`. The behavior in this case is\n    /// platform specific and unstable, and it's recommended to use\n    /// [`canonicalize`] to get an absolute program path instead.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"ls\")\n    ///         .current_dir(\"/bin\")\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    ///\n    /// [`canonicalize`]: ../fs/fn.canonicalize.html\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn current_dir\u003cP: AsRef\u003cPath\u003e\u003e(\u0026mut self, dir: P) -\u003e \u0026mut Command {\n        self.inner.cwd(dir.as_ref().as_ref());\n        self\n    }\n\n    /// Configuration for the child process's standard input (stdin) handle.\n    ///\n    /// Defaults to [`inherit`] when used with `spawn` or `status`, and\n    /// defaults to [`piped`] when used with `output`.\n    ///\n    /// [`inherit`]: struct.Stdio.html#method.inherit\n    /// [`piped`]: struct.Stdio.html#method.piped\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// Command::new(\"ls\")\n    ///         .stdin(Stdio::null())\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn stdin\u003cT: Into\u003cStdio\u003e\u003e(\u0026mut self, cfg: T) -\u003e \u0026mut Command {\n        self.inner.stdin(cfg.into().0);\n        self\n    }\n\n    /// Configuration for the child process's standard output (stdout) handle.\n    ///\n    /// Defaults to [`inherit`] when used with `spawn` or `status`, and\n    /// defaults to [`piped`] when used with `output`.\n    ///\n    /// [`inherit`]: struct.Stdio.html#method.inherit\n    /// [`piped`]: struct.Stdio.html#method.piped\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// Command::new(\"ls\")\n    ///         .stdout(Stdio::null())\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn stdout\u003cT: Into\u003cStdio\u003e\u003e(\u0026mut self, cfg: T) -\u003e \u0026mut Command {\n        self.inner.stdout(cfg.into().0);\n        self\n    }\n\n    /// Configuration for the child process's standard error (stderr) handle.\n    ///\n    /// Defaults to [`inherit`] when used with `spawn` or `status`, and\n    /// defaults to [`piped`] when used with `output`.\n    ///\n    /// [`inherit`]: struct.Stdio.html#method.inherit\n    /// [`piped`]: struct.Stdio.html#method.piped\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// Command::new(\"ls\")\n    ///         .stderr(Stdio::null())\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn stderr\u003cT: Into\u003cStdio\u003e\u003e(\u0026mut self, cfg: T) -\u003e \u0026mut Command {\n        self.inner.stderr(cfg.into().0);\n        self\n    }\n\n    /// Executes the command as a child process, returning a handle to it.\n    ///\n    /// By default, stdin, stdout and stderr are inherited from the parent.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"ls\")\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn spawn(\u0026mut self) -\u003e io::Result\u003cChild\u003e {\n        self.inner.spawn(imp::Stdio::Inherit, true).map(Child::from_inner)\n    }\n\n    /// Executes the command as a child process, waiting for it to finish and\n    /// collecting all of its output.\n    ///\n    /// By default, stdout and stderr are captured (and used to provide the\n    /// resulting output). Stdin is not inherited from the parent and any\n    /// attempt by the child process to read from the stdin stream will result\n    /// in the stream immediately closing.\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::process::Command;\n    /// use std::io::{self, Write};\n    /// let output = Command::new(\"/bin/cat\")\n    ///                      .arg(\"file.txt\")\n    ///                      .output()\n    ///                      .expect(\"failed to execute process\");\n    ///\n    /// println!(\"status: {}\", output.status);\n    /// io::stdout().write_all(\u0026output.stdout).unwrap();\n    /// io::stderr().write_all(\u0026output.stderr).unwrap();\n    ///\n    /// assert!(output.status.success());\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn output(\u0026mut self) -\u003e io::Result\u003cOutput\u003e {\n        self.inner\n            .spawn(imp::Stdio::MakePipe, false)\n            .map(Child::from_inner)\n            .and_then(|p| p.wait_with_output())\n    }\n\n    /// Executes a command as a child process, waiting for it to finish and\n    /// collecting its exit status.\n    ///\n    /// By default, stdin, stdout and stderr are inherited from the parent.\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::process::Command;\n    ///\n    /// let status = Command::new(\"/bin/cat\")\n    ///                      .arg(\"file.txt\")\n    ///                      .status()\n    ///                      .expect(\"failed to execute process\");\n    ///\n    /// println!(\"process exited with: {}\", status);\n    ///\n    /// assert!(status.success());\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn status(\u0026mut self) -\u003e io::Result\u003cExitStatus\u003e {\n        self.inner\n            .spawn(imp::Stdio::Inherit, true)\n            .map(Child::from_inner)\n            .and_then(|mut p| p.wait())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for Command {\n    /// Format the program and arguments of a Command for display. Any\n    /// non-utf8 data is lossily converted using the utf8 replacement\n    /// character.\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        self.inner.fmt(f)\n    }\n}\n\nimpl AsInner\u003cimp::Command\u003e for Command {\n    fn as_inner(\u0026self) -\u003e \u0026imp::Command {\n        \u0026self.inner\n    }\n}\n\nimpl AsInnerMut\u003cimp::Command\u003e for Command {\n    fn as_inner_mut(\u0026mut self) -\u003e \u0026mut imp::Command {\n        \u0026mut self.inner\n    }\n}\n\n/// The output of a finished process.\n///\n/// This is returned in a Result by either the [`output`] method of a\n/// [`Command`], or the [`wait_with_output`] method of a [`Child`]\n/// process.\n///\n/// [`Command`]: struct.Command.html\n/// [`Child`]: struct.Child.html\n/// [`output`]: struct.Command.html#method.output\n/// [`wait_with_output`]: struct.Child.html#method.wait_with_output\n#[derive(PartialEq, Eq, Clone)]\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct Output {\n    /// The status (exit code) of the process.\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub status: ExitStatus,\n    /// The data that the process wrote to stdout.\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub stdout: Vec\u003cu8\u003e,\n    /// The data that the process wrote to stderr.\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub stderr: Vec\u003cu8\u003e,\n}\n\n// If either stderr or stdout are valid utf8 strings it prints the valid\n// strings, otherwise it prints the byte sequence instead\n#[stable(feature = \"process_output_debug\", since = \"1.7.0\")]\nimpl fmt::Debug for Output {\n    fn fmt(\u0026self, fmt: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        let stdout_utf8 = str::from_utf8(\u0026self.stdout);\n        let stdout_debug: \u0026dyn fmt::Debug = match stdout_utf8 {\n            Ok(ref str) =\u003e str,\n            Err(_) =\u003e \u0026self.stdout,\n        };\n\n        let stderr_utf8 = str::from_utf8(\u0026self.stderr);\n        let stderr_debug: \u0026dyn fmt::Debug = match stderr_utf8 {\n            Ok(ref str) =\u003e str,\n            Err(_) =\u003e \u0026self.stderr,\n        };\n\n        fmt.debug_struct(\"Output\")\n            .field(\"status\", \u0026self.status)\n            .field(\"stdout\", stdout_debug)\n            .field(\"stderr\", stderr_debug)\n            .finish()\n    }\n}\n\n/// Describes what to do with a standard I/O stream for a child process when\n/// passed to the [`stdin`], [`stdout`], and [`stderr`] methods of [`Command`].\n///\n/// [`stdin`]: struct.Command.html#method.stdin\n/// [`stdout`]: struct.Command.html#method.stdout\n/// [`stderr`]: struct.Command.html#method.stderr\n/// [`Command`]: struct.Command.html\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct Stdio(imp::Stdio);\n\nimpl Stdio {\n    /// A new pipe should be arranged to connect the parent and child processes.\n    ///\n    /// # Examples\n    ///\n    /// With stdout:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let output = Command::new(\"echo\")\n    ///     .arg(\"Hello, world!\")\n    ///     .stdout(Stdio::piped())\n    ///     .output()\n    ///     .expect(\"Failed to execute command\");\n    ///\n    /// assert_eq!(String::from_utf8_lossy(\u0026output.stdout), \"Hello, world!\\n\");\n    /// // Nothing echoed to console\n    /// ```\n    ///\n    /// With stdin:\n    ///\n    /// ```no_run\n    /// use std::io::Write;\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let mut child = Command::new(\"rev\")\n    ///     .stdin(Stdio::piped())\n    ///     .stdout(Stdio::piped())\n    ///     .spawn()\n    ///     .expect(\"Failed to spawn child process\");\n    ///\n    /// {\n    ///     let stdin = child.stdin.as_mut().expect(\"Failed to open stdin\");\n    ///     stdin.write_all(\"Hello, world!\".as_bytes()).expect(\"Failed to write to stdin\");\n    /// }\n    ///\n    /// let output = child.wait_with_output().expect(\"Failed to read stdout\");\n    /// assert_eq!(String::from_utf8_lossy(\u0026output.stdout), \"!dlrow ,olleH\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn piped() -\u003e Stdio {\n        Stdio(imp::Stdio::MakePipe)\n    }\n\n    /// The child inherits from the corresponding parent descriptor.\n    ///\n    /// # Examples\n    ///\n    /// With stdout:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let output = Command::new(\"echo\")\n    ///     .arg(\"Hello, world!\")\n    ///     .stdout(Stdio::inherit())\n    ///     .output()\n    ///     .expect(\"Failed to execute command\");\n    ///\n    /// assert_eq!(String::from_utf8_lossy(\u0026output.stdout), \"\");\n    /// // \"Hello, world!\" echoed to console\n    /// ```\n    ///\n    /// With stdin:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    /// use std::io::{self, Write};\n    ///\n    /// let output = Command::new(\"rev\")\n    ///     .stdin(Stdio::inherit())\n    ///     .stdout(Stdio::piped())\n    ///     .output()\n    ///     .expect(\"Failed to execute command\");\n    ///\n    /// print!(\"You piped in the reverse of: \");\n    /// io::stdout().write_all(\u0026output.stdout).unwrap();\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn inherit() -\u003e Stdio {\n        Stdio(imp::Stdio::Inherit)\n    }\n\n    /// This stream will be ignored. This is the equivalent of attaching the\n    /// stream to `/dev/null`\n    ///\n    /// # Examples\n    ///\n    /// With stdout:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let output = Command::new(\"echo\")\n    ///     .arg(\"Hello, world!\")\n    ///     .stdout(Stdio::null())\n    ///     .output()\n    ///     .expect(\"Failed to execute command\");\n    ///\n    /// assert_eq!(String::from_utf8_lossy(\u0026output.stdout), \"\");\n    /// // Nothing echoed to console\n    /// ```\n    ///\n    /// With stdin:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let output = Command::new(\"rev\")\n    ///     .stdin(Stdio::null())\n    ///     .stdout(Stdio::piped())\n    ///     .output()\n    ///     .expect(\"Failed to execute command\");\n    ///\n    /// assert_eq!(String::from_utf8_lossy(\u0026output.stdout), \"\");\n    /// // Ignores any piped-in input\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn null() -\u003e Stdio {\n        Stdio(imp::Stdio::Null)\n    }\n}\n\nimpl FromInner\u003cimp::Stdio\u003e for Stdio {\n    fn from_inner(inner: imp::Stdio) -\u003e Stdio {\n        Stdio(inner)\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Stdio {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.pad(\"Stdio { .. }\")\n    }\n}\n\n#[stable(feature = \"stdio_from\", since = \"1.20.0\")]\nimpl From\u003cChildStdin\u003e for Stdio {\n    /// Converts a `ChildStdin` into a `Stdio`\n    ///\n    /// # Examples\n    ///\n    /// `ChildStdin` will be converted to `Stdio` using `Stdio::from` under the hood.\n    ///\n    /// ```rust,no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let reverse = Command::new(\"rev\")\n    ///     .stdin(Stdio::piped())\n    ///     .spawn()\n    ///     .expect(\"failed reverse command\");\n    ///\n    /// let _echo = Command::new(\"echo\")\n    ///     .arg(\"Hello, world!\")\n    ///     .stdout(reverse.stdin.unwrap()) // Converted into a Stdio here\n    ///     .output()\n    ///     .expect(\"failed echo command\");\n    ///\n    /// // \"!dlrow ,olleH\" echoed to console\n    /// ```\n    fn from(child: ChildStdin) -\u003e Stdio {\n        Stdio::from_inner(child.into_inner().into())\n    }\n}\n\n#[stable(feature = \"stdio_from\", since = \"1.20.0\")]\nimpl From\u003cChildStdout\u003e for Stdio {\n    /// Converts a `ChildStdout` into a `Stdio`\n    ///\n    /// # Examples\n    ///\n    /// `ChildStdout` will be converted to `Stdio` using `Stdio::from` under the hood.\n    ///\n    /// ```rust,no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let hello = Command::new(\"echo\")\n    ///     .arg(\"Hello, world!\")\n    ///     .stdout(Stdio::piped())\n    ///     .spawn()\n    ///     .expect(\"failed echo command\");\n    ///\n    /// let reverse = Command::new(\"rev\")\n    ///     .stdin(hello.stdout.unwrap())  // Converted into a Stdio here\n    ///     .output()\n    ///     .expect(\"failed reverse command\");\n    ///\n    /// assert_eq!(reverse.stdout, b\"!dlrow ,olleH\\n\");\n    /// ```\n    fn from(child: ChildStdout) -\u003e Stdio {\n        Stdio::from_inner(child.into_inner().into())\n    }\n}\n\n#[stable(feature = \"stdio_from\", since = \"1.20.0\")]\nimpl From\u003cChildStderr\u003e for Stdio {\n    /// Converts a `ChildStderr` into a `Stdio`\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let reverse = Command::new(\"rev\")\n    ///     .arg(\"non_existing_file.txt\")\n    ///     .stderr(Stdio::piped())\n    ///     .spawn()\n    ///     .expect(\"failed reverse command\");\n    ///\n    /// let cat = Command::new(\"cat\")\n    ///     .arg(\"-\")\n    ///     .stdin(reverse.stderr.unwrap()) // Converted into a Stdio here\n    ///     .output()\n    ///     .expect(\"failed echo command\");\n    ///\n    /// assert_eq!(\n    ///     String::from_utf8_lossy(\u0026cat.stdout),\n    ///     \"rev: cannot open non_existing_file.txt: No such file or directory\\n\"\n    /// );\n    /// ```\n    fn from(child: ChildStderr) -\u003e Stdio {\n        Stdio::from_inner(child.into_inner().into())\n    }\n}\n\n#[stable(feature = \"stdio_from\", since = \"1.20.0\")]\nimpl From\u003cfs::File\u003e for Stdio {\n    /// Converts a `File` into a `Stdio`\n    ///\n    /// # Examples\n    ///\n    /// `File` will be converted to `Stdio` using `Stdio::from` under the hood.\n    ///\n    /// ```rust,no_run\n    /// use std::fs::File;\n    /// use std::process::Command;\n    ///\n    /// // With the `foo.txt` file containing `Hello, world!\"\n    /// let file = File::open(\"foo.txt\").unwrap();\n    ///\n    /// let reverse = Command::new(\"rev\")\n    ///     .stdin(file)  // Implicit File conversion into a Stdio\n    ///     .output()\n    ///     .expect(\"failed reverse command\");\n    ///\n    /// assert_eq!(reverse.stdout, b\"!dlrow ,olleH\");\n    /// ```\n    fn from(file: fs::File) -\u003e Stdio {\n        Stdio::from_inner(file.into_inner().into())\n    }\n}\n\n/// Describes the result of a process after it has terminated.\n///\n/// This `struct` is used to represent the exit status of a child process.\n/// Child processes are created via the [`Command`] struct and their exit\n/// status is exposed through the [`status`] method, or the [`wait`] method\n/// of a [`Child`] process.\n///\n/// [`Command`]: struct.Command.html\n/// [`Child`]: struct.Child.html\n/// [`status`]: struct.Command.html#method.status\n/// [`wait`]: struct.Child.html#method.wait\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct ExitStatus(imp::ExitStatus);\n\nimpl ExitStatus {\n    /// Was termination successful? Signal termination is not considered a\n    /// success, and success is defined as a zero exit status.\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// use std::process::Command;\n    ///\n    /// let status = Command::new(\"mkdir\")\n    ///                      .arg(\"projects\")\n    ///                      .status()\n    ///                      .expect(\"failed to execute mkdir\");\n    ///\n    /// if status.success() {\n    ///     println!(\"'projects/' directory created\");\n    /// } else {\n    ///     println!(\"failed to create 'projects/' directory\");\n    /// }\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn success(\u0026self) -\u003e bool {\n        self.0.success()\n    }\n\n    /// Returns the exit code of the process, if any.\n    ///\n    /// On Unix, this will return `None` if the process was terminated\n    /// by a signal; `std::os::unix` provides an extension trait for\n    /// extracting the signal and other details from the `ExitStatus`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// let status = Command::new(\"mkdir\")\n    ///                      .arg(\"projects\")\n    ///                      .status()\n    ///                      .expect(\"failed to execute mkdir\");\n    ///\n    /// match status.code() {\n    ///     Some(code) =\u003e println!(\"Exited with status code: {}\", code),\n    ///     None       =\u003e println!(\"Process terminated by signal\")\n    /// }\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn code(\u0026self) -\u003e Option\u003ci32\u003e {\n        self.0.code()\n    }\n}\n\nimpl AsInner\u003cimp::ExitStatus\u003e for ExitStatus {\n    fn as_inner(\u0026self) -\u003e \u0026imp::ExitStatus {\n        \u0026self.0\n    }\n}\n\nimpl FromInner\u003cimp::ExitStatus\u003e for ExitStatus {\n    fn from_inner(s: imp::ExitStatus) -\u003e ExitStatus {\n        ExitStatus(s)\n    }\n}\n\n#[stable(feature = \"process\", since = \"1.0.0\")]\nimpl fmt::Display for ExitStatus {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        self.0.fmt(f)\n    }\n}\n\n/// This type represents the status code a process can return to its\n/// parent under normal termination.\n///\n/// Numeric values used in this type don't have portable meanings, and\n/// different platforms may mask different amounts of them.\n///\n/// For the platform's canonical successful and unsuccessful codes, see\n/// the [`SUCCESS`] and [`FAILURE`] associated items.\n///\n/// [`SUCCESS`]: #associatedconstant.SUCCESS\n/// [`FAILURE`]: #associatedconstant.FAILURE\n///\n/// **Warning**: While various forms of this were discussed in [RFC #1937],\n/// it was ultimately cut from that RFC, and thus this type is more subject\n/// to change even than the usual unstable item churn.\n///\n/// [RFC #1937]: https://github.com/rust-lang/rfcs/pull/1937\n#[derive(Clone, Copy, Debug)]\n#[unstable(feature = \"process_exitcode_placeholder\", issue = \"48711\")]\npub struct ExitCode(imp::ExitCode);\n\n#[unstable(feature = \"process_exitcode_placeholder\", issue = \"48711\")]\nimpl ExitCode {\n    /// The canonical ExitCode for successful termination on this platform.\n    ///\n    /// Note that a `()`-returning `main` implicitly results in a successful\n    /// termination, so there's no need to return this from `main` unless\n    /// you're also returning other possible codes.\n    #[unstable(feature = \"process_exitcode_placeholder\", issue = \"48711\")]\n    pub const SUCCESS: ExitCode = ExitCode(imp::ExitCode::SUCCESS);\n\n    /// The canonical ExitCode for unsuccessful termination on this platform.\n    ///\n    /// If you're only returning this and `SUCCESS` from `main`, consider\n    /// instead returning `Err(_)` and `Ok(())` respectively, which will\n    /// return the same codes (but will also `eprintln!` the error).\n    #[unstable(feature = \"process_exitcode_placeholder\", issue = \"48711\")]\n    pub const FAILURE: ExitCode = ExitCode(imp::ExitCode::FAILURE);\n}\n\nimpl Child {\n    /// Forces the child process to exit. If the child has already exited, an [`InvalidInput`]\n    /// error is returned.\n    ///\n    /// The mapping to [`ErrorKind`]s is not part of the compatibility contract of the function,\n    /// especially the [`Other`] kind might change to more specific kinds in the future.\n    ///\n    /// This is equivalent to sending a SIGKILL on Unix platforms.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// let mut command = Command::new(\"yes\");\n    /// if let Ok(mut child) = command.spawn() {\n    ///     child.kill().expect(\"command wasn't running\");\n    /// } else {\n    ///     println!(\"yes command didn't start\");\n    /// }\n    /// ```\n    ///\n    /// [`ErrorKind`]: ../io/enum.ErrorKind.html\n    /// [`InvalidInput`]: ../io/enum.ErrorKind.html#variant.InvalidInput\n    /// [`Other`]: ../io/enum.ErrorKind.html#variant.Other\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn kill(\u0026mut self) -\u003e io::Result\u003c()\u003e {\n        self.handle.kill()\n    }\n\n    /// Returns the OS-assigned process identifier associated with this child.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// let mut command = Command::new(\"ls\");\n    /// if let Ok(child) = command.spawn() {\n    ///     println!(\"Child's ID is {}\", child.id());\n    /// } else {\n    ///     println!(\"ls command didn't start\");\n    /// }\n    /// ```\n    #[stable(feature = \"process_id\", since = \"1.3.0\")]\n    pub fn id(\u0026self) -\u003e u32 {\n        self.handle.id()\n    }\n\n    /// Waits for the child to exit completely, returning the status that it\n    /// exited with. This function will continue to have the same return value\n    /// after it has been called at least once.\n    ///\n    /// The stdin handle to the child process, if any, will be closed\n    /// before waiting. This helps avoid deadlock: it ensures that the\n    /// child does not block waiting for input from the parent, while\n    /// the parent waits for the child to exit.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// let mut command = Command::new(\"ls\");\n    /// if let Ok(mut child) = command.spawn() {\n    ///     child.wait().expect(\"command wasn't running\");\n    ///     println!(\"Child has finished its execution!\");\n    /// } else {\n    ///     println!(\"ls command didn't start\");\n    /// }\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn wait(\u0026mut self) -\u003e io::Result\u003cExitStatus\u003e {\n        drop(self.stdin.take());\n        self.handle.wait().map(ExitStatus)\n    }\n\n    /// Attempts to collect the exit status of the child if it has already\n    /// exited.\n    ///\n    /// This function will not block the calling thread and will only\n    /// check to see if the child process has exited or not. If the child has\n    /// exited then on Unix the process ID is reaped. This function is\n    /// guaranteed to repeatedly return a successful exit status so long as the\n    /// child has already exited.\n    ///\n    /// If the child has exited, then `Ok(Some(status))` is returned. If the\n    /// exit status is not available at this time then `Ok(None)` is returned.\n    /// If an error occurs, then that error is returned.\n    ///\n    /// Note that unlike `wait`, this function will not attempt to drop stdin.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// let mut child = Command::new(\"ls\").spawn().unwrap();\n    ///\n    /// match child.try_wait() {\n    ///     Ok(Some(status)) =\u003e println!(\"exited with: {}\", status),\n    ///     Ok(None) =\u003e {\n    ///         println!(\"status not ready yet, let's really wait\");\n    ///         let res = child.wait();\n    ///         println!(\"result: {:?}\", res);\n    ///     }\n    ///     Err(e) =\u003e println!(\"error attempting to wait: {}\", e),\n    /// }\n    /// ```\n    #[stable(feature = \"process_try_wait\", since = \"1.18.0\")]\n    pub fn try_wait(\u0026mut self) -\u003e io::Result\u003cOption\u003cExitStatus\u003e\u003e {\n        Ok(self.handle.try_wait()?.map(ExitStatus))\n    }\n\n    /// Simultaneously waits for the child to exit and collect all remaining\n    /// output on the stdout/stderr handles, returning an `Output`\n    /// instance.\n    ///\n    /// The stdin handle to the child process, if any, will be closed\n    /// before waiting. This helps avoid deadlock: it ensures that the\n    /// child does not block waiting for input from the parent, while\n    /// the parent waits for the child to exit.\n    ///\n    /// By default, stdin, stdout and stderr are inherited from the parent.\n    /// In order to capture the output into this `Result\u003cOutput\u003e` it is\n    /// necessary to create new pipes between parent and child. Use\n    /// `stdout(Stdio::piped())` or `stderr(Stdio::piped())`, respectively.\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let child = Command::new(\"/bin/cat\")\n    ///     .arg(\"file.txt\")\n    ///     .stdout(Stdio::piped())\n    ///     .spawn()\n    ///     .expect(\"failed to execute child\");\n    ///\n    /// let output = child\n    ///     .wait_with_output()\n    ///     .expect(\"failed to wait on child\");\n    ///\n    /// assert!(output.status.success());\n    /// ```\n    ///\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn wait_with_output(mut self) -\u003e io::Result\u003cOutput\u003e {\n        drop(self.stdin.take());\n\n        let (mut stdout, mut stderr) = (Vec::new(), Vec::new());\n        match (self.stdout.take(), self.stderr.take()) {\n            (None, None) =\u003e {}\n            (Some(mut out), None) =\u003e {\n                let res = out.read_to_end(\u0026mut stdout);\n                res.unwrap();\n            }\n            (None, Some(mut err)) =\u003e {\n                let res = err.read_to_end(\u0026mut stderr);\n                res.unwrap();\n            }\n            (Some(out), Some(err)) =\u003e {\n                let res = read2(out.inner, \u0026mut stdout, err.inner, \u0026mut stderr);\n                res.unwrap();\n            }\n        }\n\n        let status = self.wait()?;\n        Ok(Output { status, stdout, stderr })\n    }\n}\n\n/// Terminates the current process with the specified exit code.\n///\n/// This function will never return and will immediately terminate the current\n/// process. The exit code is passed through to the underlying OS and will be\n/// available for consumption by another process.\n///\n/// Note that because this function never returns, and that it terminates the\n/// process, no destructors on the current stack or any other thread's stack\n/// will be run. If a clean shutdown is needed it is recommended to only call\n/// this function at a known point where there are no more destructors left\n/// to run.\n///\n/// ## Platform-specific behavior\n///\n/// **Unix**: On Unix-like platforms, it is unlikely that all 32 bits of `exit`\n/// will be visible to a parent process inspecting the exit code. On most\n/// Unix-like platforms, only the eight least-significant bits are considered.\n///\n/// # Examples\n///\n/// Due to this function’s behavior regarding destructors, a conventional way\n/// to use the function is to extract the actual computation to another\n/// function and compute the exit code from its return value:\n///\n/// ```\n/// fn run_app() -\u003e Result\u003c(), ()\u003e {\n///     // Application logic here\n///     Ok(())\n/// }\n///\n/// fn main() {\n///     std::process::exit(match run_app() {\n///         Ok(_) =\u003e 0,\n///         Err(err) =\u003e {\n///             eprintln!(\"error: {:?}\", err);\n///             1\n///         }\n///     });\n/// }\n/// ```\n///\n/// Due to [platform-specific behavior], the exit code for this example will be\n/// `0` on Linux, but `256` on Windows:\n///\n/// ```no_run\n/// use std::process;\n///\n/// process::exit(0x0100);\n/// ```\n///\n/// [platform-specific behavior]: #platform-specific-behavior\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn exit(code: i32) -\u003e ! {\n    crate::sys_common::cleanup();\n    crate::sys::os::exit(code)\n}\n\n/// Terminates the process in an abnormal fashion.\n///\n/// The function will never return and will immediately terminate the current\n/// process in a platform specific \"abnormal\" manner.\n///\n/// Note that because this function never returns, and that it terminates the\n/// process, no destructors on the current stack or any other thread's stack\n/// will be run.\n///\n/// This is in contrast to the default behaviour of [`panic!`] which unwinds\n/// the current thread's stack and calls all destructors.\n/// When `panic=\"abort\"` is set, either as an argument to `rustc` or in a\n/// crate's Cargo.toml, [`panic!`] and `abort` are similar. However,\n/// [`panic!`] will still call the [panic hook] while `abort` will not.\n///\n/// If a clean shutdown is needed it is recommended to only call\n/// this function at a known point where there are no more destructors left\n/// to run.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::process;\n///\n/// fn main() {\n///     println!(\"aborting\");\n///\n///     process::abort();\n///\n///     // execution never gets here\n/// }\n/// ```\n///\n/// The `abort` function terminates the process, so the destructor will not\n/// get run on the example below:\n///\n/// ```no_run\n/// use std::process;\n///\n/// struct HasDrop;\n///\n/// impl Drop for HasDrop {\n///     fn drop(\u0026mut self) {\n///         println!(\"This will never be printed!\");\n///     }\n/// }\n///\n/// fn main() {\n///     let _x = HasDrop;\n///     process::abort();\n///     // the destructor implemented for HasDrop will never get run\n/// }\n/// ```\n///\n/// [`panic!`]: ../../std/macro.panic.html\n/// [panic hook]: ../../std/panic/fn.set_hook.html\n#[stable(feature = \"process_abort\", since = \"1.17.0\")]\npub fn abort() -\u003e ! {\n    crate::sys::abort_internal();\n}\n\n/// Returns the OS-assigned process identifier associated with this process.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```no_run\n/// use std::process;\n///\n/// println!(\"My pid is {}\", process::id());\n/// ```\n///\n///\n#[stable(feature = \"getpid\", since = \"1.26.0\")]\npub fn id() -\u003e u32 {\n    crate::sys::os::getpid()\n}\n\n/// A trait for implementing arbitrary return types in the `main` function.\n///\n/// The C-main function only supports to return integers as return type.\n/// So, every type implementing the `Termination` trait has to be converted\n/// to an integer.\n///\n/// The default implementations are returning `libc::EXIT_SUCCESS` to indicate\n/// a successful execution. In case of a failure, `libc::EXIT_FAILURE` is returned.\n#[cfg_attr(not(test), lang = \"termination\")]\n#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\n#[rustc_on_unimplemented(\n    message = \"`main` has invalid return type `{Self}`\",\n    label = \"`main` can only return types that implement `{Termination}`\"\n)]\npub trait Termination {\n    /// Is called to get the representation of the value as status code.\n    /// This status code is returned to the operating system.\n    fn report(self) -\u003e i32;\n}\n\n#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\nimpl Termination for () {\n    #[inline]\n    fn report(self) -\u003e i32 {\n        ExitCode::SUCCESS.report()\n    }\n}\n\n#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\nimpl\u003cE: fmt::Debug\u003e Termination for Result\u003c(), E\u003e {\n    fn report(self) -\u003e i32 {\n        match self {\n            Ok(()) =\u003e ().report(),\n            Err(err) =\u003e Err::\u003c!, _\u003e(err).report(),\n        }\n    }\n}\n\n#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\nimpl Termination for ! {\n    fn report(self) -\u003e i32 {\n        self\n    }\n}\n\n#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\nimpl\u003cE: fmt::Debug\u003e Termination for Result\u003c!, E\u003e {\n    fn report(self) -\u003e i32 {\n        let Err(err) = self;\n        eprintln!(\"Error: {:?}\", err);\n        ExitCode::FAILURE.report()\n    }\n}\n\n#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\nimpl Termination for ExitCode {\n    #[inline]\n    fn report(self) -\u003e i32 {\n        self.0.as_i32()\n    }\n}\n\n#[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\", target_env = \"sgx\"))))]\nmod tests {\n    use crate::io::prelude::*;\n\n    use super::{Command, Output, Stdio};\n    use crate::io::ErrorKind;\n    use crate::str;\n\n    // FIXME(#10380) these tests should not all be ignored on android.\n\n    #[test]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn smoke() {\n        let p = if cfg!(target_os = \"windows\") {\n            Command::new(\"cmd\").args(\u0026[\"/C\", \"exit 0\"]).spawn()\n        } else {\n            Command::new(\"true\").spawn()\n        };\n        assert!(p.is_ok());\n        let mut p = p.unwrap();\n        assert!(p.wait().unwrap().success());\n    }\n\n    #[test]\n    #[cfg_attr(target_os = \"android\", ignore)]\n    fn smoke_failure() {\n        match Command::new(\"if-this-is-a-binary-then-the-world-has-ended\").spawn() {\n            Ok(..) =\u003e panic!(),\n            Err(..) =\u003e {}\n        }\n    }\n\n    #[test]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn exit_reported_right() {\n        let p = if cfg!(target_os = \"windows\") {\n            Command::new(\"cmd\").args(\u0026[\"/C\", \"exit 1\"]).spawn()\n        } else {\n            Command::new(\"false\").spawn()\n        };\n        assert!(p.is_ok());\n        let mut p = p.unwrap();\n        assert!(p.wait().unwrap().code() == Some(1));\n        drop(p.wait());\n    }\n\n    #[test]\n    #[cfg(unix)]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn signal_reported_right() {\n        use crate::os::unix::process::ExitStatusExt;\n\n        let mut p =\n            Command::new(\"/bin/sh\").arg(\"-c\").arg(\"read a\").stdin(Stdio::piped()).spawn().unwrap();\n        p.kill().unwrap();\n        match p.wait().unwrap().signal() {\n            Some(9) =\u003e {}\n            result =\u003e panic!(\"not terminated by signal 9 (instead, {:?})\", result),\n        }\n    }\n\n    pub fn run_output(mut cmd: Command) -\u003e String {\n        let p = cmd.spawn();\n        assert!(p.is_ok());\n        let mut p = p.unwrap();\n        assert!(p.stdout.is_some());\n        let mut ret = String::new();\n        p.stdout.as_mut().unwrap().read_to_string(\u0026mut ret).unwrap();\n        assert!(p.wait().unwrap().success());\n        return ret;\n    }\n\n    #[test]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn stdout_works() {\n        if cfg!(target_os = \"windows\") {\n            let mut cmd = Command::new(\"cmd\");\n            cmd.args(\u0026[\"/C\", \"echo foobar\"]).stdout(Stdio::piped());\n            assert_eq!(run_output(cmd), \"foobar\\r\\n\");\n        } else {\n            let mut cmd = Command::new(\"echo\");\n            cmd.arg(\"foobar\").stdout(Stdio::piped());\n            assert_eq!(run_output(cmd), \"foobar\\n\");\n        }\n    }\n\n    #[test]\n    #[cfg_attr(any(windows, target_os = \"android\", target_os = \"vxworks\"), ignore)]\n    fn set_current_dir_works() {\n        let mut cmd = Command::new(\"/bin/sh\");\n        cmd.arg(\"-c\").arg(\"pwd\").current_dir(\"/\").stdout(Stdio::piped());\n        assert_eq!(run_output(cmd), \"/\\n\");\n    }\n\n    #[test]\n    #[cfg_attr(any(windows, target_os = \"android\", target_os = \"vxworks\"), ignore)]\n    fn stdin_works() {\n        let mut p = Command::new(\"/bin/sh\")\n            .arg(\"-c\")\n            .arg(\"read line; echo $line\")\n            .stdin(Stdio::piped())\n            .stdout(Stdio::piped())\n            .spawn()\n            .unwrap();\n        p.stdin.as_mut().unwrap().write(\"foobar\".as_bytes()).unwrap();\n        drop(p.stdin.take());\n        let mut out = String::new();\n        p.stdout.as_mut().unwrap().read_to_string(\u0026mut out).unwrap();\n        assert!(p.wait().unwrap().success());\n        assert_eq!(out, \"foobar\\n\");\n    }\n\n    #[test]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn test_process_status() {\n        let mut status = if cfg!(target_os = \"windows\") {\n            Command::new(\"cmd\").args(\u0026[\"/C\", \"exit 1\"]).status().unwrap()\n        } else {\n            Command::new(\"false\").status().unwrap()\n        };\n        assert!(status.code() == Some(1));\n\n        status = if cfg!(target_os = \"windows\") {\n            Command::new(\"cmd\").args(\u0026[\"/C\", \"exit 0\"]).status().unwrap()\n        } else {\n            Command::new(\"true\").status().unwrap()\n        };\n        assert!(status.success());\n    }\n\n    #[test]\n    fn test_process_output_fail_to_start() {\n        match Command::new(\"/no-binary-by-this-name-should-exist\").output() {\n            Err(e) =\u003e assert_eq!(e.kind(), ErrorKind::NotFound),\n            Ok(..) =\u003e panic!(),\n        }\n    }\n\n    #[test]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn test_process_output_output() {\n        let Output { status, stdout, stderr } = if cfg!(target_os = \"windows\") {\n            Command::new(\"cmd\").args(\u0026[\"/C\", \"echo hello\"]).output().unwrap()\n        } else {\n            Command::new(\"echo\").arg(\"hello\").output().unwrap()\n        };\n        let output_str = str::from_utf8(\u0026stdout).unwrap();\n\n        assert!(status.success());\n        assert_eq!(output_str.trim().to_string(), \"hello\");\n        assert_eq!(stderr, Vec::new());\n    }\n\n    #[test]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn test_process_output_error() {\n        let Output { status, stdout, stderr } = if cfg!(target_os = \"windows\") {\n            Command::new(\"cmd\").args(\u0026[\"/C\", \"mkdir .\"]).output().unwrap()\n        } else {\n            Command::new(\"mkdir\").arg(\"./\").output().unwrap()\n        };\n\n        assert!(status.code() == Some(1));\n        assert_eq!(stdout, Vec::new());\n        assert!(!stderr.is_empty());\n    }\n\n    #[test]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn test_finish_once() {\n        let mut prog = if cfg!(target_os = \"windows\") {\n            Command::new(\"cmd\").args(\u0026[\"/C\", \"exit 1\"]).spawn().unwrap()\n        } else {\n            Command::new(\"false\").spawn().unwrap()\n        };\n        assert!(prog.wait().unwrap().code() == Some(1));\n    }\n\n    #[test]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn test_finish_twice() {\n        let mut prog = if cfg!(target_os = \"windows\") {\n            Command::new(\"cmd\").args(\u0026[\"/C\", \"exit 1\"]).spawn().unwrap()\n        } else {\n            Command::new(\"false\").spawn().unwrap()\n        };\n        assert!(prog.wait().unwrap().code() == Some(1));\n        assert!(prog.wait().unwrap().code() == Some(1));\n    }\n\n    #[test]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn test_wait_with_output_once() {\n        let prog = if cfg!(target_os = \"windows\") {\n            Command::new(\"cmd\").args(\u0026[\"/C\", \"echo hello\"]).stdout(Stdio::piped()).spawn().unwrap()\n        } else {\n            Command::new(\"echo\").arg(\"hello\").stdout(Stdio::piped()).spawn().unwrap()\n        };\n\n        let Output { status, stdout, stderr } = prog.wait_with_output().unwrap();\n        let output_str = str::from_utf8(\u0026stdout).unwrap();\n\n        assert!(status.success());\n        assert_eq!(output_str.trim().to_string(), \"hello\");\n        assert_eq!(stderr, Vec::new());\n    }\n\n    #[cfg(all(unix, not(target_os = \"android\")))]\n    pub fn env_cmd() -\u003e Command {\n        Command::new(\"env\")\n    }\n    #[cfg(target_os = \"android\")]\n    pub fn env_cmd() -\u003e Command {\n        let mut cmd = Command::new(\"/system/bin/sh\");\n        cmd.arg(\"-c\").arg(\"set\");\n        cmd\n    }\n\n    #[cfg(windows)]\n    pub fn env_cmd() -\u003e Command {\n        let mut cmd = Command::new(\"cmd\");\n        cmd.arg(\"/c\").arg(\"set\");\n        cmd\n    }\n\n    #[test]\n    #[cfg_attr(target_os = \"vxworks\", ignore)]\n    fn test_override_env() {\n        use crate::env;\n\n        // In some build environments (such as chrooted Nix builds), `env` can\n        // only be found in the explicitly-provided PATH env variable, not in\n        // default places such as /bin or /usr/bin. So we need to pass through\n        // PATH to our sub-process.\n        let mut cmd = env_cmd();\n        cmd.env_clear().env(\"RUN_TEST_NEW_ENV\", \"123\");\n        if let Some(p) = env::var_os(\"PATH\") {\n            cmd.env(\"PATH\", \u0026p);\n        }\n        let result = cmd.output().unwrap();\n        let output = String::from_utf8_lossy(\u0026result.stdout).to_string();\n\n        assert!(\n            output.contains(\"RUN_TEST_NEW_ENV=123\"),\n            \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\",\n            output\n        );\n    }\n\n    #[test]\n    #[cfg_attr(target_os = \"vxworks\", ignore)]\n    fn test_add_to_env() {\n        let result = env_cmd().env(\"RUN_TEST_NEW_ENV\", \"123\").output().unwrap();\n        let output = String::from_utf8_lossy(\u0026result.stdout).to_string();\n\n        assert!(\n            output.contains(\"RUN_TEST_NEW_ENV=123\"),\n            \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\",\n            output\n        );\n    }\n\n    #[test]\n    #[cfg_attr(target_os = \"vxworks\", ignore)]\n    fn test_capture_env_at_spawn() {\n        use crate::env;\n\n        let mut cmd = env_cmd();\n        cmd.env(\"RUN_TEST_NEW_ENV1\", \"123\");\n\n        // This variable will not be present if the environment has already\n        // been captured above.\n        env::set_var(\"RUN_TEST_NEW_ENV2\", \"456\");\n        let result = cmd.output().unwrap();\n        env::remove_var(\"RUN_TEST_NEW_ENV2\");\n\n        let output = String::from_utf8_lossy(\u0026result.stdout).to_string();\n\n        assert!(\n            output.contains(\"RUN_TEST_NEW_ENV1=123\"),\n            \"didn't find RUN_TEST_NEW_ENV1 inside of:\\n\\n{}\",\n            output\n        );\n        assert!(\n            output.contains(\"RUN_TEST_NEW_ENV2=456\"),\n            \"didn't find RUN_TEST_NEW_ENV2 inside of:\\n\\n{}\",\n            output\n        );\n    }\n\n    // Regression tests for #30858.\n    #[test]\n    fn test_interior_nul_in_progname_is_error() {\n        match Command::new(\"has-some-\\0\\0s-inside\").spawn() {\n            Err(e) =\u003e assert_eq!(e.kind(), ErrorKind::InvalidInput),\n            Ok(_) =\u003e panic!(),\n        }\n    }\n\n    #[test]\n    fn test_interior_nul_in_arg_is_error() {\n        match Command::new(\"echo\").arg(\"has-some-\\0\\0s-inside\").spawn() {\n            Err(e) =\u003e assert_eq!(e.kind(), ErrorKind::InvalidInput),\n            Ok(_) =\u003e panic!(),\n        }\n    }\n\n    #[test]\n    fn test_interior_nul_in_args_is_error() {\n        match Command::new(\"echo\").args(\u0026[\"has-some-\\0\\0s-inside\"]).spawn() {\n            Err(e) =\u003e assert_eq!(e.kind(), ErrorKind::InvalidInput),\n            Ok(_) =\u003e panic!(),\n        }\n    }\n\n    #[test]\n    fn test_interior_nul_in_current_dir_is_error() {\n        match Command::new(\"echo\").current_dir(\"has-some-\\0\\0s-inside\").spawn() {\n            Err(e) =\u003e assert_eq!(e.kind(), ErrorKind::InvalidInput),\n            Ok(_) =\u003e panic!(),\n        }\n    }\n\n    // Regression tests for #30862.\n    #[test]\n    #[cfg_attr(target_os = \"vxworks\", ignore)]\n    fn test_interior_nul_in_env_key_is_error() {\n        match env_cmd().env(\"has-some-\\0\\0s-inside\", \"value\").spawn() {\n            Err(e) =\u003e assert_eq!(e.kind(), ErrorKind::InvalidInput),\n            Ok(_) =\u003e panic!(),\n        }\n    }\n\n    #[test]\n    #[cfg_attr(target_os = \"vxworks\", ignore)]\n    fn test_interior_nul_in_env_value_is_error() {\n        match env_cmd().env(\"key\", \"has-some-\\0\\0s-inside\").spawn() {\n            Err(e) =\u003e assert_eq!(e.kind(), ErrorKind::InvalidInput),\n            Ok(_) =\u003e panic!(),\n        }\n    }\n\n    /// Tests that process creation flags work by debugging a process.\n    /// Other creation flags make it hard or impossible to detect\n    /// behavioral changes in the process.\n    #[test]\n    #[cfg(windows)]\n    fn test_creation_flags() {\n        use crate::os::windows::process::CommandExt;\n        use crate::sys::c::{BOOL, DWORD, INFINITE};\n        #[repr(C, packed)]\n        struct DEBUG_EVENT {\n            pub event_code: DWORD,\n            pub process_id: DWORD,\n            pub thread_id: DWORD,\n            // This is a union in the real struct, but we don't\n            // need this data for the purposes of this test.\n            pub _junk: [u8; 164],\n        }\n\n        extern \"system\" {\n            fn WaitForDebugEvent(lpDebugEvent: *mut DEBUG_EVENT, dwMilliseconds: DWORD) -\u003e BOOL;\n            fn ContinueDebugEvent(\n                dwProcessId: DWORD,\n                dwThreadId: DWORD,\n                dwContinueStatus: DWORD,\n            ) -\u003e BOOL;\n        }\n\n        const DEBUG_PROCESS: DWORD = 1;\n        const EXIT_PROCESS_DEBUG_EVENT: DWORD = 5;\n        const DBG_EXCEPTION_NOT_HANDLED: DWORD = 0x80010001;\n\n        let mut child = Command::new(\"cmd\")\n            .creation_flags(DEBUG_PROCESS)\n            .stdin(Stdio::piped())\n            .spawn()\n            .unwrap();\n        child.stdin.take().unwrap().write_all(b\"exit\\r\\n\").unwrap();\n        let mut events = 0;\n        let mut event = DEBUG_EVENT { event_code: 0, process_id: 0, thread_id: 0, _junk: [0; 164] };\n        loop {\n            if unsafe { WaitForDebugEvent(\u0026mut event as *mut DEBUG_EVENT, INFINITE) } == 0 {\n                panic!(\"WaitForDebugEvent failed!\");\n            }\n            events += 1;\n\n            if event.event_code == EXIT_PROCESS_DEBUG_EVENT {\n                break;\n            }\n\n            if unsafe {\n                ContinueDebugEvent(event.process_id, event.thread_id, DBG_EXCEPTION_NOT_HANDLED)\n            } == 0\n            {\n                panic!(\"ContinueDebugEvent failed!\");\n            }\n        }\n        assert!(events \u003e 0);\n    }\n\n    #[test]\n    fn test_command_implements_send_sync() {\n        fn take_send_sync_type\u003cT: Send + Sync\u003e(_: T) {}\n        take_send_sync_type(Command::new(\"\"))\n    }\n}\n","traces":[{"line":1667,"address":[4212832],"length":1,"stats":{"Line":1},"fn_name":"report"},{"line":1668,"address":[4212838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1669,"address":[4212856,4212851],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1701,"address":[4212864],"length":1,"stats":{"Line":1},"fn_name":"report"},{"line":1702,"address":[4212870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1703,"address":[4212886,4212888],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","usr","local","rustup","toolchains","1.45.2-x86_64-unknown-linux-gnu","lib","rustlib","src","rust","src","libstd","rt.rs"],"content":"//! Runtime services\n//!\n//! The `rt` module provides a narrow set of runtime services,\n//! including the global heap (exported in `heap`) and unwinding and\n//! backtrace support. The APIs in this module are highly unstable,\n//! and should be considered as private implementation details for the\n//! time being.\n\n#![unstable(\n    feature = \"rt\",\n    reason = \"this public module should not exist and is highly likely \\\n              to disappear\",\n    issue = \"none\"\n)]\n#![doc(hidden)]\n\n// Re-export some of our utilities which are expected by other crates.\npub use crate::panicking::{begin_panic, begin_panic_fmt, update_panic_count};\n\n// To reduce the generated code of the new `lang_start`, this function is doing\n// the real work.\n#[cfg(not(test))]\nfn lang_start_internal(\n    main: \u0026(dyn Fn() -\u003e i32 + Sync + crate::panic::RefUnwindSafe),\n    argc: isize,\n    argv: *const *const u8,\n) -\u003e isize {\n    use crate::panic;\n    use crate::sys;\n    use crate::sys_common;\n    use crate::sys_common::thread_info;\n    use crate::thread::Thread;\n\n    sys::init();\n\n    unsafe {\n        let main_guard = sys::thread::guard::init();\n        sys::stack_overflow::init();\n\n        // Next, set up the current Thread with the guard information we just\n        // created. Note that this isn't necessary in general for new threads,\n        // but we just do this to name the main thread and to give it correct\n        // info about the stack bounds.\n        let thread = Thread::new(Some(\"main\".to_owned()));\n        thread_info::set(main_guard, thread);\n\n        // Store our args if necessary in a squirreled away location\n        sys::args::init(argc, argv);\n\n        // Let's run some code!\n        let exit_code = panic::catch_unwind(|| {\n            sys_common::backtrace::__rust_begin_short_backtrace(move || main())\n        });\n\n        sys_common::cleanup();\n        exit_code.unwrap_or(101) as isize\n    }\n}\n\n#[cfg(not(test))]\n#[lang = \"start\"]\nfn lang_start\u003cT: crate::process::Termination + 'static\u003e(\n    main: fn() -\u003e T,\n    argc: isize,\n    argv: *const *const u8,\n) -\u003e isize {\n    lang_start_internal(\u0026move || main().report(), argc, argv)\n}\n","traces":[{"line":62,"address":[4212224],"length":1,"stats":{"Line":1},"fn_name":"lang_start\u003c()\u003e"},{"line":67,"address":[4212329,4212250,4212320],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}\u003c()\u003e"},{"line":68,"address":[4212303,4212308],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":3,"coverable":3},{"path":["/","usr","local","rustup","toolchains","1.45.2-x86_64-unknown-linux-gnu","lib","rustlib","src","rust","src","libstd","sys","unix","process","process_common.rs"],"content":"use crate::os::unix::prelude::*;\n\nuse crate::collections::BTreeMap;\nuse crate::ffi::{CStr, CString, OsStr, OsString};\nuse crate::fmt;\nuse crate::io;\nuse crate::ptr;\nuse crate::sys::fd::FileDesc;\nuse crate::sys::fs::File;\nuse crate::sys::pipe::{self, AnonPipe};\nuse crate::sys_common::process::CommandEnv;\n\n#[cfg(not(target_os = \"fuchsia\"))]\nuse crate::sys::fs::OpenOptions;\n\nuse libc::{c_char, c_int, gid_t, uid_t, EXIT_FAILURE, EXIT_SUCCESS};\n\ncfg_if::cfg_if! {\n    if #[cfg(target_os = \"fuchsia\")] {\n        // fuchsia doesn't have /dev/null\n    } else if #[cfg(target_os = \"redox\")] {\n        const DEV_NULL: \u0026str = \"null:\\0\";\n    } else {\n        const DEV_NULL: \u0026str = \"/dev/null\\0\";\n    }\n}\n\n// Android with api less than 21 define sig* functions inline, so it is not\n// available for dynamic link. Implementing sigemptyset and sigaddset allow us\n// to support older Android version (independent of libc version).\n// The following implementations are based on https://git.io/vSkNf\ncfg_if::cfg_if! {\n    if #[cfg(target_os = \"android\")] {\n        pub unsafe fn sigemptyset(set: *mut libc::sigset_t) -\u003e libc::c_int {\n            set.write_bytes(0u8, 1);\n            return 0;\n        }\n        #[allow(dead_code)]\n        pub unsafe fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -\u003e libc::c_int {\n            use crate::{slice, mem};\n\n            let raw = slice::from_raw_parts_mut(set as *mut u8, mem::size_of::\u003clibc::sigset_t\u003e());\n            let bit = (signum - 1) as usize;\n            raw[bit / 8] |= 1 \u003c\u003c (bit % 8);\n            return 0;\n        }\n    } else {\n        pub use libc::{sigemptyset, sigaddset};\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Command\n////////////////////////////////////////////////////////////////////////////////\n\npub struct Command {\n    // Currently we try hard to ensure that the call to `.exec()` doesn't\n    // actually allocate any memory. While many platforms try to ensure that\n    // memory allocation works after a fork in a multithreaded process, it's\n    // been observed to be buggy and somewhat unreliable, so we do our best to\n    // just not do it at all!\n    //\n    // Along those lines, the `argv` and `envp` raw pointers here are exactly\n    // what's gonna get passed to `execvp`. The `argv` array starts with the\n    // `program` and ends with a NULL, and the `envp` pointer, if present, is\n    // also null-terminated.\n    //\n    // Right now we don't support removing arguments, so there's no much fancy\n    // support there, but we support adding and removing environment variables,\n    // so a side table is used to track where in the `envp` array each key is\n    // located. Whenever we add a key we update it in place if it's already\n    // present, and whenever we remove a key we update the locations of all\n    // other keys.\n    program: CString,\n    args: Vec\u003cCString\u003e,\n    argv: Argv,\n    env: CommandEnv,\n\n    cwd: Option\u003cCString\u003e,\n    uid: Option\u003cuid_t\u003e,\n    gid: Option\u003cgid_t\u003e,\n    saw_nul: bool,\n    closures: Vec\u003cBox\u003cdyn FnMut() -\u003e io::Result\u003c()\u003e + Send + Sync\u003e\u003e,\n    stdin: Option\u003cStdio\u003e,\n    stdout: Option\u003cStdio\u003e,\n    stderr: Option\u003cStdio\u003e,\n}\n\n// Create a new type for argv, so that we can make it `Send` and `Sync`\nstruct Argv(Vec\u003c*const c_char\u003e);\n\n// It is safe to make `Argv` `Send` and `Sync`, because it contains\n// pointers to memory owned by `Command.args`\nunsafe impl Send for Argv {}\nunsafe impl Sync for Argv {}\n\n// passed back to std::process with the pipes connected to the child, if any\n// were requested\npub struct StdioPipes {\n    pub stdin: Option\u003cAnonPipe\u003e,\n    pub stdout: Option\u003cAnonPipe\u003e,\n    pub stderr: Option\u003cAnonPipe\u003e,\n}\n\n// passed to do_exec() with configuration of what the child stdio should look\n// like\npub struct ChildPipes {\n    pub stdin: ChildStdio,\n    pub stdout: ChildStdio,\n    pub stderr: ChildStdio,\n}\n\npub enum ChildStdio {\n    Inherit,\n    Explicit(c_int),\n    Owned(FileDesc),\n\n    // On Fuchsia, null stdio is the default, so we simply don't specify\n    // any actions at the time of spawning.\n    #[cfg(target_os = \"fuchsia\")]\n    Null,\n}\n\npub enum Stdio {\n    Inherit,\n    Null,\n    MakePipe,\n    Fd(FileDesc),\n}\n\nimpl Command {\n    pub fn new(program: \u0026OsStr) -\u003e Command {\n        let mut saw_nul = false;\n        let program = os2c(program, \u0026mut saw_nul);\n        Command {\n            argv: Argv(vec![program.as_ptr(), ptr::null()]),\n            args: vec![program.clone()],\n            program,\n            env: Default::default(),\n            cwd: None,\n            uid: None,\n            gid: None,\n            saw_nul,\n            closures: Vec::new(),\n            stdin: None,\n            stdout: None,\n            stderr: None,\n        }\n    }\n\n    pub fn set_arg_0(\u0026mut self, arg: \u0026OsStr) {\n        // Set a new arg0\n        let arg = os2c(arg, \u0026mut self.saw_nul);\n        debug_assert!(self.argv.0.len() \u003e 1);\n        self.argv.0[0] = arg.as_ptr();\n        self.args[0] = arg;\n    }\n\n    pub fn arg(\u0026mut self, arg: \u0026OsStr) {\n        // Overwrite the trailing NULL pointer in `argv` and then add a new null\n        // pointer.\n        let arg = os2c(arg, \u0026mut self.saw_nul);\n        self.argv.0[self.args.len()] = arg.as_ptr();\n        self.argv.0.push(ptr::null());\n\n        // Also make sure we keep track of the owned value to schedule a\n        // destructor for this memory.\n        self.args.push(arg);\n    }\n\n    pub fn cwd(\u0026mut self, dir: \u0026OsStr) {\n        self.cwd = Some(os2c(dir, \u0026mut self.saw_nul));\n    }\n    pub fn uid(\u0026mut self, id: uid_t) {\n        self.uid = Some(id);\n    }\n    pub fn gid(\u0026mut self, id: gid_t) {\n        self.gid = Some(id);\n    }\n\n    pub fn saw_nul(\u0026self) -\u003e bool {\n        self.saw_nul\n    }\n    pub fn get_argv(\u0026self) -\u003e \u0026Vec\u003c*const c_char\u003e {\n        \u0026self.argv.0\n    }\n\n    pub fn get_program(\u0026self) -\u003e \u0026CStr {\n        \u0026*self.program\n    }\n\n    #[allow(dead_code)]\n    pub fn get_cwd(\u0026self) -\u003e \u0026Option\u003cCString\u003e {\n        \u0026self.cwd\n    }\n    #[allow(dead_code)]\n    pub fn get_uid(\u0026self) -\u003e Option\u003cuid_t\u003e {\n        self.uid\n    }\n    #[allow(dead_code)]\n    pub fn get_gid(\u0026self) -\u003e Option\u003cgid_t\u003e {\n        self.gid\n    }\n\n    pub fn get_closures(\u0026mut self) -\u003e \u0026mut Vec\u003cBox\u003cdyn FnMut() -\u003e io::Result\u003c()\u003e + Send + Sync\u003e\u003e {\n        \u0026mut self.closures\n    }\n\n    pub unsafe fn pre_exec(\u0026mut self, f: Box\u003cdyn FnMut() -\u003e io::Result\u003c()\u003e + Send + Sync\u003e) {\n        self.closures.push(f);\n    }\n\n    pub fn stdin(\u0026mut self, stdin: Stdio) {\n        self.stdin = Some(stdin);\n    }\n\n    pub fn stdout(\u0026mut self, stdout: Stdio) {\n        self.stdout = Some(stdout);\n    }\n\n    pub fn stderr(\u0026mut self, stderr: Stdio) {\n        self.stderr = Some(stderr);\n    }\n\n    pub fn env_mut(\u0026mut self) -\u003e \u0026mut CommandEnv {\n        \u0026mut self.env\n    }\n\n    pub fn capture_env(\u0026mut self) -\u003e Option\u003cCStringArray\u003e {\n        let maybe_env = self.env.capture_if_changed();\n        maybe_env.map(|env| construct_envp(env, \u0026mut self.saw_nul))\n    }\n    #[allow(dead_code)]\n    pub fn env_saw_path(\u0026self) -\u003e bool {\n        self.env.have_changed_path()\n    }\n\n    pub fn setup_io(\n        \u0026self,\n        default: Stdio,\n        needs_stdin: bool,\n    ) -\u003e io::Result\u003c(StdioPipes, ChildPipes)\u003e {\n        let null = Stdio::Null;\n        let default_stdin = if needs_stdin { \u0026default } else { \u0026null };\n        let stdin = self.stdin.as_ref().unwrap_or(default_stdin);\n        let stdout = self.stdout.as_ref().unwrap_or(\u0026default);\n        let stderr = self.stderr.as_ref().unwrap_or(\u0026default);\n        let (their_stdin, our_stdin) = stdin.to_child_stdio(true)?;\n        let (their_stdout, our_stdout) = stdout.to_child_stdio(false)?;\n        let (their_stderr, our_stderr) = stderr.to_child_stdio(false)?;\n        let ours = StdioPipes { stdin: our_stdin, stdout: our_stdout, stderr: our_stderr };\n        let theirs = ChildPipes { stdin: their_stdin, stdout: their_stdout, stderr: their_stderr };\n        Ok((ours, theirs))\n    }\n}\n\nfn os2c(s: \u0026OsStr, saw_nul: \u0026mut bool) -\u003e CString {\n    CString::new(s.as_bytes()).unwrap_or_else(|_e| {\n        *saw_nul = true;\n        CString::new(\"\u003cstring-with-nul\u003e\").unwrap()\n    })\n}\n\n// Helper type to manage ownership of the strings within a C-style array.\npub struct CStringArray {\n    items: Vec\u003cCString\u003e,\n    ptrs: Vec\u003c*const c_char\u003e,\n}\n\nimpl CStringArray {\n    pub fn with_capacity(capacity: usize) -\u003e Self {\n        let mut result = CStringArray {\n            items: Vec::with_capacity(capacity),\n            ptrs: Vec::with_capacity(capacity + 1),\n        };\n        result.ptrs.push(ptr::null());\n        result\n    }\n    pub fn push(\u0026mut self, item: CString) {\n        let l = self.ptrs.len();\n        self.ptrs[l - 1] = item.as_ptr();\n        self.ptrs.push(ptr::null());\n        self.items.push(item);\n    }\n    pub fn as_ptr(\u0026self) -\u003e *const *const c_char {\n        self.ptrs.as_ptr()\n    }\n}\n\nfn construct_envp(env: BTreeMap\u003cOsString, OsString\u003e, saw_nul: \u0026mut bool) -\u003e CStringArray {\n    let mut result = CStringArray::with_capacity(env.len());\n    for (mut k, v) in env {\n        // Reserve additional space for '=' and null terminator\n        k.reserve_exact(v.len() + 2);\n        k.push(\"=\");\n        k.push(\u0026v);\n\n        // Add the new entry into the array\n        if let Ok(item) = CString::new(k.into_vec()) {\n            result.push(item);\n        } else {\n            *saw_nul = true;\n        }\n    }\n\n    result\n}\n\nimpl Stdio {\n    pub fn to_child_stdio(\u0026self, readable: bool) -\u003e io::Result\u003c(ChildStdio, Option\u003cAnonPipe\u003e)\u003e {\n        match *self {\n            Stdio::Inherit =\u003e Ok((ChildStdio::Inherit, None)),\n\n            // Make sure that the source descriptors are not an stdio\n            // descriptor, otherwise the order which we set the child's\n            // descriptors may blow away a descriptor which we are hoping to\n            // save. For example, suppose we want the child's stderr to be the\n            // parent's stdout, and the child's stdout to be the parent's\n            // stderr. No matter which we dup first, the second will get\n            // overwritten prematurely.\n            Stdio::Fd(ref fd) =\u003e {\n                if fd.raw() \u003e= 0 \u0026\u0026 fd.raw() \u003c= libc::STDERR_FILENO {\n                    Ok((ChildStdio::Owned(fd.duplicate()?), None))\n                } else {\n                    Ok((ChildStdio::Explicit(fd.raw()), None))\n                }\n            }\n\n            Stdio::MakePipe =\u003e {\n                let (reader, writer) = pipe::anon_pipe()?;\n                let (ours, theirs) = if readable { (writer, reader) } else { (reader, writer) };\n                Ok((ChildStdio::Owned(theirs.into_fd()), Some(ours)))\n            }\n\n            #[cfg(not(target_os = \"fuchsia\"))]\n            Stdio::Null =\u003e {\n                let mut opts = OpenOptions::new();\n                opts.read(readable);\n                opts.write(!readable);\n                let path = unsafe { CStr::from_ptr(DEV_NULL.as_ptr() as *const _) };\n                let fd = File::open_c(\u0026path, \u0026opts)?;\n                Ok((ChildStdio::Owned(fd.into_fd()), None))\n            }\n\n            #[cfg(target_os = \"fuchsia\")]\n            Stdio::Null =\u003e Ok((ChildStdio::Null, None)),\n        }\n    }\n}\n\nimpl From\u003cAnonPipe\u003e for Stdio {\n    fn from(pipe: AnonPipe) -\u003e Stdio {\n        Stdio::Fd(pipe.into_fd())\n    }\n}\n\nimpl From\u003cFile\u003e for Stdio {\n    fn from(file: File) -\u003e Stdio {\n        Stdio::Fd(file.into_fd())\n    }\n}\n\nimpl ChildStdio {\n    pub fn fd(\u0026self) -\u003e Option\u003cc_int\u003e {\n        match *self {\n            ChildStdio::Inherit =\u003e None,\n            ChildStdio::Explicit(fd) =\u003e Some(fd),\n            ChildStdio::Owned(ref fd) =\u003e Some(fd.raw()),\n\n            #[cfg(target_os = \"fuchsia\")]\n            ChildStdio::Null =\u003e None,\n        }\n    }\n}\n\nimpl fmt::Debug for Command {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        if self.program != self.args[0] {\n            write!(f, \"[{:?}] \", self.program)?;\n        }\n        write!(f, \"{:?}\", self.args[0])?;\n\n        for arg in \u0026self.args[1..] {\n            write!(f, \" {:?}\", arg)?;\n        }\n        Ok(())\n    }\n}\n\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\npub struct ExitCode(u8);\n\nimpl ExitCode {\n    pub const SUCCESS: ExitCode = ExitCode(EXIT_SUCCESS as _);\n    pub const FAILURE: ExitCode = ExitCode(EXIT_FAILURE as _);\n\n    #[inline]\n    pub fn as_i32(\u0026self) -\u003e i32 {\n        self.0 as i32\n    }\n}\n\n#[cfg(all(test, not(target_os = \"emscripten\")))]\nmod tests {\n    use super::*;\n\n    use crate::ffi::OsStr;\n    use crate::mem;\n    use crate::ptr;\n    use crate::sys::cvt;\n\n    macro_rules! t {\n        ($e:expr) =\u003e {\n            match $e {\n                Ok(t) =\u003e t,\n                Err(e) =\u003e panic!(\"received error for `{}`: {}\", stringify!($e), e),\n            }\n        };\n    }\n\n    // See #14232 for more information, but it appears that signal delivery to a\n    // newly spawned process may just be raced in the macOS, so to prevent this\n    // test from being flaky we ignore it on macOS.\n    #[test]\n    #[cfg_attr(target_os = \"macos\", ignore)]\n    // When run under our current QEMU emulation test suite this test fails,\n    // although the reason isn't very clear as to why. For now this test is\n    // ignored there.\n    #[cfg_attr(target_arch = \"arm\", ignore)]\n    #[cfg_attr(target_arch = \"aarch64\", ignore)]\n    fn test_process_mask() {\n        unsafe {\n            // Test to make sure that a signal mask does not get inherited.\n            let mut cmd = Command::new(OsStr::new(\"cat\"));\n\n            let mut set = mem::MaybeUninit::\u003clibc::sigset_t\u003e::uninit();\n            let mut old_set = mem::MaybeUninit::\u003clibc::sigset_t\u003e::uninit();\n            t!(cvt(sigemptyset(set.as_mut_ptr())));\n            t!(cvt(sigaddset(set.as_mut_ptr(), libc::SIGINT)));\n            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, set.as_ptr(), old_set.as_mut_ptr())));\n\n            cmd.stdin(Stdio::MakePipe);\n            cmd.stdout(Stdio::MakePipe);\n\n            let (mut cat, mut pipes) = t!(cmd.spawn(Stdio::Null, true));\n            let stdin_write = pipes.stdin.take().unwrap();\n            let stdout_read = pipes.stdout.take().unwrap();\n\n            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, old_set.as_ptr(), ptr::null_mut())));\n\n            t!(cvt(libc::kill(cat.id() as libc::pid_t, libc::SIGINT)));\n            // We need to wait until SIGINT is definitely delivered. The\n            // easiest way is to write something to cat, and try to read it\n            // back: if SIGINT is unmasked, it'll get delivered when cat is\n            // next scheduled.\n            let _ = stdin_write.write(b\"Hello\");\n            drop(stdin_write);\n\n            // Either EOF or failure (EPIPE) is okay.\n            let mut buf = [0; 5];\n            if let Ok(ret) = stdout_read.read(\u0026mut buf) {\n                assert_eq!(ret, 0);\n            }\n\n            t!(cat.wait());\n        }\n    }\n}\n","traces":[{"line":398,"address":[4212048],"length":1,"stats":{"Line":1},"fn_name":"as_i32"},{"line":399,"address":[4212053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":400,"address":[4212058,4212056],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":3,"coverable":3},{"path":["/","usr","local","rustup","toolchains","1.45.2-x86_64-unknown-linux-gnu","lib","rustlib","src","rust","src","libtest","lib.rs"],"content":"//! Support code for rustc's built in unit-test and micro-benchmarking\n//! framework.\n//!\n//! Almost all user code will only be interested in `Bencher` and\n//! `black_box`. All other interactions (such as writing tests and\n//! benchmarks themselves) should be done via the `#[test]` and\n//! `#[bench]` attributes.\n//!\n//! See the [Testing Chapter](../book/ch11-00-testing.html) of the book for more details.\n\n// Currently, not much of this is meant for users. It is intended to\n// support the simplest interface possible for representing and\n// running tests while providing a base that other test frameworks may\n// build off of.\n\n// N.B., this is also specified in this crate's Cargo.toml, but librustc_ast contains logic specific to\n// this crate, which relies on this attribute (rather than the value of `--crate-name` passed by\n// cargo) to detect this crate.\n\n#![crate_name = \"test\"]\n#![unstable(feature = \"test\", issue = \"50297\")]\n#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\", test(attr(deny(warnings))))]\n#![cfg_attr(any(unix, target_os = \"cloudabi\"), feature(libc))]\n#![feature(rustc_private)]\n#![feature(nll)]\n#![feature(bool_to_option)]\n#![feature(set_stdio)]\n#![feature(panic_unwind)]\n#![feature(staged_api)]\n#![feature(termination_trait_lib)]\n#![feature(test)]\n\n// Public reexports\npub use self::bench::{black_box, Bencher};\npub use self::console::run_tests_console;\npub use self::options::{ColorConfig, Options, OutputFormat, RunIgnored, ShouldPanic};\npub use self::types::TestName::*;\npub use self::types::*;\npub use self::ColorConfig::*;\npub use cli::TestOpts;\n\n// Module to be used by rustc to compile tests in libtest\npub mod test {\n    pub use crate::{\n        assert_test_result,\n        bench::Bencher,\n        cli::{parse_opts, TestOpts},\n        filter_tests,\n        helpers::metrics::{Metric, MetricMap},\n        options::{Options, RunIgnored, RunStrategy, ShouldPanic},\n        run_test, test_main, test_main_static,\n        test_result::{TestResult, TrFailed, TrFailedMsg, TrIgnored, TrOk},\n        time::{TestExecTime, TestTimeOptions},\n        types::{\n            DynTestFn, DynTestName, StaticBenchFn, StaticTestFn, StaticTestName, TestDesc,\n            TestDescAndFn, TestName, TestType,\n        },\n    };\n}\n\nuse std::{\n    env, io,\n    io::prelude::Write,\n    panic::{self, catch_unwind, AssertUnwindSafe, PanicInfo},\n    process::{self, Command, Termination},\n    sync::mpsc::{channel, Sender},\n    sync::{Arc, Mutex},\n    thread,\n    time::{Duration, Instant},\n};\n\npub mod bench;\nmod cli;\nmod console;\nmod event;\nmod formatters;\nmod helpers;\nmod options;\npub mod stats;\nmod test_result;\nmod time;\nmod types;\n\n#[cfg(test)]\nmod tests;\n\nuse event::{CompletedTest, TestEvent};\nuse helpers::concurrency::get_concurrency;\nuse helpers::exit_code::get_exit_code;\nuse helpers::sink::Sink;\nuse options::{Concurrent, RunStrategy};\nuse test_result::*;\nuse time::TestExecTime;\n\n// Process exit code to be used to indicate test failures.\nconst ERROR_EXIT_CODE: i32 = 101;\n\nconst SECONDARY_TEST_INVOKER_VAR: \u0026str = \"__RUST_TEST_INVOKE\";\n\n// The default console test runner. It accepts the command line\n// arguments and a vector of test_descs.\npub fn test_main(args: \u0026[String], tests: Vec\u003cTestDescAndFn\u003e, options: Option\u003cOptions\u003e) {\n    let mut opts = match cli::parse_opts(args) {\n        Some(Ok(o)) =\u003e o,\n        Some(Err(msg)) =\u003e {\n            eprintln!(\"error: {}\", msg);\n            process::exit(ERROR_EXIT_CODE);\n        }\n        None =\u003e return,\n    };\n    if let Some(options) = options {\n        opts.options = options;\n    }\n    if opts.list {\n        if let Err(e) = console::list_tests_console(\u0026opts, tests) {\n            eprintln!(\"error: io error when listing tests: {:?}\", e);\n            process::exit(ERROR_EXIT_CODE);\n        }\n    } else {\n        match console::run_tests_console(\u0026opts, tests) {\n            Ok(true) =\u003e {}\n            Ok(false) =\u003e process::exit(ERROR_EXIT_CODE),\n            Err(e) =\u003e {\n                eprintln!(\"error: io error when listing tests: {:?}\", e);\n                process::exit(ERROR_EXIT_CODE);\n            }\n        }\n    }\n}\n\n/// A variant optimized for invocation with a static test vector.\n/// This will panic (intentionally) when fed any dynamic tests.\n///\n/// This is the entry point for the main function generated by `rustc --test`\n/// when panic=unwind.\npub fn test_main_static(tests: \u0026[\u0026TestDescAndFn]) {\n    let args = env::args().collect::\u003cVec\u003c_\u003e\u003e();\n    let owned_tests: Vec\u003c_\u003e = tests.iter().map(make_owned_test).collect();\n    test_main(\u0026args, owned_tests, None)\n}\n\n/// A variant optimized for invocation with a static test vector.\n/// This will panic (intentionally) when fed any dynamic tests.\n///\n/// Runs tests in panic=abort mode, which involves spawning subprocesses for\n/// tests.\n///\n/// This is the entry point for the main function generated by `rustc --test`\n/// when panic=abort.\npub fn test_main_static_abort(tests: \u0026[\u0026TestDescAndFn]) {\n    // If we're being run in SpawnedSecondary mode, run the test here. run_test\n    // will then exit the process.\n    if let Ok(name) = env::var(SECONDARY_TEST_INVOKER_VAR) {\n        env::remove_var(SECONDARY_TEST_INVOKER_VAR);\n        let test = tests\n            .iter()\n            .filter(|test| test.desc.name.as_slice() == name)\n            .map(make_owned_test)\n            .next()\n            .unwrap_or_else(|| panic!(\"couldn't find a test with the provided name '{}'\", name));\n        let TestDescAndFn { desc, testfn } = test;\n        let testfn = match testfn {\n            StaticTestFn(f) =\u003e f,\n            _ =\u003e panic!(\"only static tests are supported\"),\n        };\n        run_test_in_spawned_subprocess(desc, Box::new(testfn));\n    }\n\n    let args = env::args().collect::\u003cVec\u003c_\u003e\u003e();\n    let owned_tests: Vec\u003c_\u003e = tests.iter().map(make_owned_test).collect();\n    test_main(\u0026args, owned_tests, Some(Options::new().panic_abort(true)))\n}\n\n/// Clones static values for putting into a dynamic vector, which test_main()\n/// needs to hand out ownership of tests to parallel test runners.\n///\n/// This will panic when fed any dynamic tests, because they cannot be cloned.\nfn make_owned_test(test: \u0026\u0026TestDescAndFn) -\u003e TestDescAndFn {\n    match test.testfn {\n        StaticTestFn(f) =\u003e TestDescAndFn { testfn: StaticTestFn(f), desc: test.desc.clone() },\n        StaticBenchFn(f) =\u003e TestDescAndFn { testfn: StaticBenchFn(f), desc: test.desc.clone() },\n        _ =\u003e panic!(\"non-static tests passed to test::test_main_static\"),\n    }\n}\n\n/// Invoked when unit tests terminate. Should panic if the unit\n/// Tests is considered a failure. By default, invokes `report()`\n/// and checks for a `0` result.\npub fn assert_test_result\u003cT: Termination\u003e(result: T) {\n    let code = result.report();\n    assert_eq!(\n        code, 0,\n        \"the test returned a termination value with a non-zero status code ({}) \\\n         which indicates a failure\",\n        code\n    );\n}\n\npub fn run_tests\u003cF\u003e(\n    opts: \u0026TestOpts,\n    tests: Vec\u003cTestDescAndFn\u003e,\n    mut notify_about_test_event: F,\n) -\u003e io::Result\u003c()\u003e\nwhere\n    F: FnMut(TestEvent) -\u003e io::Result\u003c()\u003e,\n{\n    use std::collections::{self, HashMap};\n    use std::hash::BuildHasherDefault;\n    use std::sync::mpsc::RecvTimeoutError;\n    // Use a deterministic hasher\n    type TestMap =\n        HashMap\u003cTestDesc, Instant, BuildHasherDefault\u003ccollections::hash_map::DefaultHasher\u003e\u003e;\n\n    let tests_len = tests.len();\n\n    let mut filtered_tests = filter_tests(opts, tests);\n    if !opts.bench_benchmarks {\n        filtered_tests = convert_benchmarks_to_tests(filtered_tests);\n    }\n\n    let filtered_tests = {\n        let mut filtered_tests = filtered_tests;\n        for test in filtered_tests.iter_mut() {\n            test.desc.name = test.desc.name.with_padding(test.testfn.padding());\n        }\n\n        filtered_tests\n    };\n\n    let filtered_out = tests_len - filtered_tests.len();\n    let event = TestEvent::TeFilteredOut(filtered_out);\n    notify_about_test_event(event)?;\n\n    let filtered_descs = filtered_tests.iter().map(|t| t.desc.clone()).collect();\n\n    let event = TestEvent::TeFiltered(filtered_descs);\n    notify_about_test_event(event)?;\n\n    let (filtered_tests, filtered_benchs): (Vec\u003c_\u003e, _) =\n        filtered_tests.into_iter().partition(|e| match e.testfn {\n            StaticTestFn(_) | DynTestFn(_) =\u003e true,\n            _ =\u003e false,\n        });\n\n    let concurrency = opts.test_threads.unwrap_or_else(get_concurrency);\n\n    let mut remaining = filtered_tests;\n    remaining.reverse();\n    let mut pending = 0;\n\n    let (tx, rx) = channel::\u003cCompletedTest\u003e();\n    let run_strategy = if opts.options.panic_abort \u0026\u0026 !opts.force_run_in_process {\n        RunStrategy::SpawnPrimary\n    } else {\n        RunStrategy::InProcess\n    };\n\n    let mut running_tests: TestMap = HashMap::default();\n\n    fn get_timed_out_tests(running_tests: \u0026mut TestMap) -\u003e Vec\u003cTestDesc\u003e {\n        let now = Instant::now();\n        let timed_out = running_tests\n            .iter()\n            .filter_map(|(desc, timeout)| if \u0026now \u003e= timeout { Some(desc.clone()) } else { None })\n            .collect();\n        for test in \u0026timed_out {\n            running_tests.remove(test);\n        }\n        timed_out\n    };\n\n    fn calc_timeout(running_tests: \u0026TestMap) -\u003e Option\u003cDuration\u003e {\n        running_tests.values().min().map(|next_timeout| {\n            let now = Instant::now();\n            if *next_timeout \u003e= now { *next_timeout - now } else { Duration::new(0, 0) }\n        })\n    };\n\n    if concurrency == 1 {\n        while !remaining.is_empty() {\n            let test = remaining.pop().unwrap();\n            let event = TestEvent::TeWait(test.desc.clone());\n            notify_about_test_event(event)?;\n            run_test(opts, !opts.run_tests, test, run_strategy, tx.clone(), Concurrent::No);\n            let completed_test = rx.recv().unwrap();\n\n            let event = TestEvent::TeResult(completed_test);\n            notify_about_test_event(event)?;\n        }\n    } else {\n        while pending \u003e 0 || !remaining.is_empty() {\n            while pending \u003c concurrency \u0026\u0026 !remaining.is_empty() {\n                let test = remaining.pop().unwrap();\n                let timeout = time::get_default_test_timeout();\n                running_tests.insert(test.desc.clone(), timeout);\n\n                let event = TestEvent::TeWait(test.desc.clone());\n                notify_about_test_event(event)?; //here no pad\n                run_test(opts, !opts.run_tests, test, run_strategy, tx.clone(), Concurrent::Yes);\n                pending += 1;\n            }\n\n            let mut res;\n            loop {\n                if let Some(timeout) = calc_timeout(\u0026running_tests) {\n                    res = rx.recv_timeout(timeout);\n                    for test in get_timed_out_tests(\u0026mut running_tests) {\n                        let event = TestEvent::TeTimeout(test);\n                        notify_about_test_event(event)?;\n                    }\n\n                    match res {\n                        Err(RecvTimeoutError::Timeout) =\u003e {\n                            // Result is not yet ready, continue waiting.\n                        }\n                        _ =\u003e {\n                            // We've got a result, stop the loop.\n                            break;\n                        }\n                    }\n                } else {\n                    res = rx.recv().map_err(|_| RecvTimeoutError::Disconnected);\n                    break;\n                }\n            }\n\n            let completed_test = res.unwrap();\n            running_tests.remove(\u0026completed_test.desc);\n\n            let event = TestEvent::TeResult(completed_test);\n            notify_about_test_event(event)?;\n            pending -= 1;\n        }\n    }\n\n    if opts.bench_benchmarks {\n        // All benchmarks run at the end, in serial.\n        for b in filtered_benchs {\n            let event = TestEvent::TeWait(b.desc.clone());\n            notify_about_test_event(event)?;\n            run_test(opts, false, b, run_strategy, tx.clone(), Concurrent::No);\n            let completed_test = rx.recv().unwrap();\n\n            let event = TestEvent::TeResult(completed_test);\n            notify_about_test_event(event)?;\n        }\n    }\n    Ok(())\n}\n\npub fn filter_tests(opts: \u0026TestOpts, tests: Vec\u003cTestDescAndFn\u003e) -\u003e Vec\u003cTestDescAndFn\u003e {\n    let mut filtered = tests;\n    let matches_filter = |test: \u0026TestDescAndFn, filter: \u0026str| {\n        let test_name = test.desc.name.as_slice();\n\n        match opts.filter_exact {\n            true =\u003e test_name == filter,\n            false =\u003e test_name.contains(filter),\n        }\n    };\n\n    // Remove tests that don't match the test filter\n    if let Some(ref filter) = opts.filter {\n        filtered.retain(|test| matches_filter(test, filter));\n    }\n\n    // Skip tests that match any of the skip filters\n    filtered.retain(|test| !opts.skip.iter().any(|sf| matches_filter(test, sf)));\n\n    // Excludes #[should_panic] tests\n    if opts.exclude_should_panic {\n        filtered.retain(|test| test.desc.should_panic == ShouldPanic::No);\n    }\n\n    // maybe unignore tests\n    match opts.run_ignored {\n        RunIgnored::Yes =\u003e {\n            filtered.iter_mut().for_each(|test| test.desc.ignore = false);\n        }\n        RunIgnored::Only =\u003e {\n            filtered.retain(|test| test.desc.ignore);\n            filtered.iter_mut().for_each(|test| test.desc.ignore = false);\n        }\n        RunIgnored::No =\u003e {}\n    }\n\n    // Sort the tests alphabetically\n    filtered.sort_by(|t1, t2| t1.desc.name.as_slice().cmp(t2.desc.name.as_slice()));\n\n    filtered\n}\n\npub fn convert_benchmarks_to_tests(tests: Vec\u003cTestDescAndFn\u003e) -\u003e Vec\u003cTestDescAndFn\u003e {\n    // convert benchmarks to tests, if we're not benchmarking them\n    tests\n        .into_iter()\n        .map(|x| {\n            let testfn = match x.testfn {\n                DynBenchFn(bench) =\u003e DynTestFn(Box::new(move || {\n                    bench::run_once(|b| __rust_begin_short_backtrace(|| bench.run(b)))\n                })),\n                StaticBenchFn(benchfn) =\u003e DynTestFn(Box::new(move || {\n                    bench::run_once(|b| __rust_begin_short_backtrace(|| benchfn(b)))\n                })),\n                f =\u003e f,\n            };\n            TestDescAndFn { desc: x.desc, testfn }\n        })\n        .collect()\n}\n\npub fn run_test(\n    opts: \u0026TestOpts,\n    force_ignore: bool,\n    test: TestDescAndFn,\n    strategy: RunStrategy,\n    monitor_ch: Sender\u003cCompletedTest\u003e,\n    concurrency: Concurrent,\n) {\n    let TestDescAndFn { desc, testfn } = test;\n\n    // Emscripten can catch panics but other wasm targets cannot\n    let ignore_because_no_process_support = desc.should_panic != ShouldPanic::No\n        \u0026\u0026 cfg!(target_arch = \"wasm32\")\n        \u0026\u0026 !cfg!(target_os = \"emscripten\");\n\n    if force_ignore || desc.ignore || ignore_because_no_process_support {\n        let message = CompletedTest::new(desc, TrIgnored, None, Vec::new());\n        monitor_ch.send(message).unwrap();\n        return;\n    }\n\n    struct TestRunOpts {\n        pub strategy: RunStrategy,\n        pub nocapture: bool,\n        pub concurrency: Concurrent,\n        pub time: Option\u003ctime::TestTimeOptions\u003e,\n    }\n\n    fn run_test_inner(\n        desc: TestDesc,\n        monitor_ch: Sender\u003cCompletedTest\u003e,\n        testfn: Box\u003cdyn FnOnce() + Send\u003e,\n        opts: TestRunOpts,\n    ) {\n        let concurrency = opts.concurrency;\n        let name = desc.name.clone();\n\n        let runtest = move || match opts.strategy {\n            RunStrategy::InProcess =\u003e run_test_in_process(\n                desc,\n                opts.nocapture,\n                opts.time.is_some(),\n                testfn,\n                monitor_ch,\n                opts.time,\n            ),\n            RunStrategy::SpawnPrimary =\u003e spawn_test_subprocess(\n                desc,\n                opts.nocapture,\n                opts.time.is_some(),\n                monitor_ch,\n                opts.time,\n            ),\n        };\n\n        // If the platform is single-threaded we're just going to run\n        // the test synchronously, regardless of the concurrency\n        // level.\n        let supports_threads = !cfg!(target_os = \"emscripten\") \u0026\u0026 !cfg!(target_arch = \"wasm32\");\n        if concurrency == Concurrent::Yes \u0026\u0026 supports_threads {\n            let cfg = thread::Builder::new().name(name.as_slice().to_owned());\n            cfg.spawn(runtest).unwrap();\n        } else {\n            runtest();\n        }\n    }\n\n    let test_run_opts =\n        TestRunOpts { strategy, nocapture: opts.nocapture, concurrency, time: opts.time_options };\n\n    match testfn {\n        DynBenchFn(bencher) =\u003e {\n            // Benchmarks aren't expected to panic, so we run them all in-process.\n            crate::bench::benchmark(desc, monitor_ch, opts.nocapture, |harness| {\n                bencher.run(harness)\n            });\n        }\n        StaticBenchFn(benchfn) =\u003e {\n            // Benchmarks aren't expected to panic, so we run them all in-process.\n            crate::bench::benchmark(desc, monitor_ch, opts.nocapture, benchfn);\n        }\n        DynTestFn(f) =\u003e {\n            match strategy {\n                RunStrategy::InProcess =\u003e (),\n                _ =\u003e panic!(\"Cannot run dynamic test fn out-of-process\"),\n            };\n            run_test_inner(\n                desc,\n                monitor_ch,\n                Box::new(move || __rust_begin_short_backtrace(f)),\n                test_run_opts,\n            );\n        }\n        StaticTestFn(f) =\u003e run_test_inner(\n            desc,\n            monitor_ch,\n            Box::new(move || __rust_begin_short_backtrace(f)),\n            test_run_opts,\n        ),\n    }\n}\n\n/// Fixed frame used to clean the backtrace with `RUST_BACKTRACE=1`.\n#[inline(never)]\nfn __rust_begin_short_backtrace\u003cF: FnOnce()\u003e(f: F) {\n    f()\n}\n\nfn run_test_in_process(\n    desc: TestDesc,\n    nocapture: bool,\n    report_time: bool,\n    testfn: Box\u003cdyn FnOnce() + Send\u003e,\n    monitor_ch: Sender\u003cCompletedTest\u003e,\n    time_opts: Option\u003ctime::TestTimeOptions\u003e,\n) {\n    // Buffer for capturing standard I/O\n    let data = Arc::new(Mutex::new(Vec::new()));\n\n    let oldio = if !nocapture {\n        Some((\n            io::set_print(Some(Sink::new_boxed(\u0026data))),\n            io::set_panic(Some(Sink::new_boxed(\u0026data))),\n        ))\n    } else {\n        None\n    };\n\n    let start = report_time.then(Instant::now);\n    let result = catch_unwind(AssertUnwindSafe(testfn));\n    let exec_time = start.map(|start| {\n        let duration = start.elapsed();\n        TestExecTime(duration)\n    });\n\n    if let Some((printio, panicio)) = oldio {\n        io::set_print(printio);\n        io::set_panic(panicio);\n    }\n\n    let test_result = match result {\n        Ok(()) =\u003e calc_result(\u0026desc, Ok(()), \u0026time_opts, \u0026exec_time),\n        Err(e) =\u003e calc_result(\u0026desc, Err(e.as_ref()), \u0026time_opts, \u0026exec_time),\n    };\n    let stdout = data.lock().unwrap().to_vec();\n    let message = CompletedTest::new(desc, test_result, exec_time, stdout);\n    monitor_ch.send(message).unwrap();\n}\n\nfn spawn_test_subprocess(\n    desc: TestDesc,\n    nocapture: bool,\n    report_time: bool,\n    monitor_ch: Sender\u003cCompletedTest\u003e,\n    time_opts: Option\u003ctime::TestTimeOptions\u003e,\n) {\n    let (result, test_output, exec_time) = (|| {\n        let args = env::args().collect::\u003cVec\u003c_\u003e\u003e();\n        let current_exe = \u0026args[0];\n\n        let mut command = Command::new(current_exe);\n        command.env(SECONDARY_TEST_INVOKER_VAR, desc.name.as_slice());\n        if nocapture {\n            command.stdout(process::Stdio::inherit());\n            command.stderr(process::Stdio::inherit());\n        }\n\n        let start = report_time.then(Instant::now);\n        let output = match command.output() {\n            Ok(out) =\u003e out,\n            Err(e) =\u003e {\n                let err = format!(\"Failed to spawn {} as child for test: {:?}\", args[0], e);\n                return (TrFailed, err.into_bytes(), None);\n            }\n        };\n        let exec_time = start.map(|start| {\n            let duration = start.elapsed();\n            TestExecTime(duration)\n        });\n\n        let std::process::Output { stdout, stderr, status } = output;\n        let mut test_output = stdout;\n        formatters::write_stderr_delimiter(\u0026mut test_output, \u0026desc.name);\n        test_output.extend_from_slice(\u0026stderr);\n\n        let result = match (|| -\u003e Result\u003cTestResult, String\u003e {\n            let exit_code = get_exit_code(status)?;\n            Ok(get_result_from_exit_code(\u0026desc, exit_code, \u0026time_opts, \u0026exec_time))\n        })() {\n            Ok(r) =\u003e r,\n            Err(e) =\u003e {\n                write!(\u0026mut test_output, \"Unexpected error: {}\", e).unwrap();\n                TrFailed\n            }\n        };\n\n        (result, test_output, exec_time)\n    })();\n\n    let message = CompletedTest::new(desc, result, exec_time, test_output);\n    monitor_ch.send(message).unwrap();\n}\n\nfn run_test_in_spawned_subprocess(desc: TestDesc, testfn: Box\u003cdyn FnOnce() + Send\u003e) -\u003e ! {\n    let builtin_panic_hook = panic::take_hook();\n    let record_result = Arc::new(move |panic_info: Option\u003c\u0026'_ PanicInfo\u003c'_\u003e\u003e| {\n        let test_result = match panic_info {\n            Some(info) =\u003e calc_result(\u0026desc, Err(info.payload()), \u0026None, \u0026None),\n            None =\u003e calc_result(\u0026desc, Ok(()), \u0026None, \u0026None),\n        };\n\n        // We don't support serializing TrFailedMsg, so just\n        // print the message out to stderr.\n        if let TrFailedMsg(msg) = \u0026test_result {\n            eprintln!(\"{}\", msg);\n        }\n\n        if let Some(info) = panic_info {\n            builtin_panic_hook(info);\n        }\n\n        if let TrOk = test_result {\n            process::exit(test_result::TR_OK);\n        } else {\n            process::exit(test_result::TR_FAILED);\n        }\n    });\n    let record_result2 = record_result.clone();\n    panic::set_hook(Box::new(move |info| record_result2(Some(\u0026info))));\n    testfn();\n    record_result(None);\n    unreachable!(\"panic=abort callback should have exited the process\")\n}\n","traces":[{"line":189,"address":[4211424],"length":1,"stats":{"Line":1},"fn_name":"assert_test_result\u003c()\u003e"},{"line":190,"address":[4211431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[4211576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[4211596],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[4211528],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":3,"coverable":5},{"path":["/","workspaces","blinky","src","main.rs"],"content":"//! A basic blinky application. The purpose of this application is to serve as an easy starting point\n//! for embedded rust projects. Be sure to read the `README.md`. It gives usefull information for how\n//! to quickly get your environment up and running within vscode and illustrates some useful tools\n//! such as a debugger and a way to flash your microcontroller. All of these tools ship with docker\n//! container and have been .\n#![cfg_attr(feature = \"embedded_platform\", no_std)]\n#![cfg_attr(feature = \"embedded_platform\", no_main)]\n\n#[cfg(feature = \"embedded_platform\")] \nuse cortex_m_rt::entry;\n\n#[cfg(feature = \"stm32f407\")]\nuse stm32f4xx_hal as hal;\n\n#[cfg(feature = \"st_board\")]\nuse hal::{\n    prelude::*,\n    stm32 as board,\n};\n\n#[cfg_attr(feature = \"embedded_platform\", allow(unused_imports))]\n#[cfg(feature = \"embedded_platform\")]\nuse panic_halt;\n\n// NOTE(allow) bug rust-lang/rust#53964\n#[cfg_attr(feature = \"embedded_platform\", entry)]\n#[cfg(feature = \"embedded_platform\")]\nfn main() -\u003e ! {\n    let board_peripherals = board::Peripherals::take().unwrap();\n    let processor_peripherals = cortex_m::Peripherals::take().unwrap();\n    \n    // Setting system clock speed\n    let clock_controler = board_peripherals.RCC.constrain();\n    let system_clock = clock_controler.cfgr.sysclk(48.mhz()).freeze();\n\n    let mut delay = hal::delay::Delay::new(processor_peripherals.SYST, system_clock);\n\n    let mut led2 = board_peripherals.GPIOG.split().pg13.into_push_pull_output();\n\n    loop {\n        // On for 1s, off for 1s\n        led2.set_high().unwrap();\n        delay.delay_ms(1000_u32);\n        led2.set_low().unwrap();\n        delay.delay_ms(1000_u32);\n    }\n}\n\nfn add_two(x: u32) -\u003e u32 {\n    x + 2\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn add_two_good_value() {\n        assert_eq!(2, add_two(0));\n    }\n}\n","traces":[{"line":49,"address":[4213648],"length":1,"stats":{"Line":1},"fn_name":"add_two"},{"line":50,"address":[4213701,4213671,4213653],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[4211312,4211317],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":59,"address":[4213257,4213360],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":4,"coverable":4}]};
        var previousData = {"files":[{"path":["/","usr","local","rustup","toolchains","1.45.2-x86_64-unknown-linux-gnu","lib","rustlib","src","rust","src","libcore","fmt","mod.rs"],"content":"//! Utilities for formatting and printing strings.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::cell::{Cell, Ref, RefCell, RefMut, UnsafeCell};\nuse crate::marker::PhantomData;\nuse crate::mem;\nuse crate::num::flt2dec;\nuse crate::ops::Deref;\nuse crate::result;\nuse crate::str;\n\nmod builders;\nmod float;\nmod num;\n\n#[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n/// Possible alignments returned by `Formatter::align`\n#[derive(Debug)]\npub enum Alignment {\n    #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n    /// Indication that contents should be left-aligned.\n    Left,\n    #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n    /// Indication that contents should be right-aligned.\n    Right,\n    #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n    /// Indication that contents should be center-aligned.\n    Center,\n}\n\n#[stable(feature = \"debug_builders\", since = \"1.2.0\")]\npub use self::builders::{DebugList, DebugMap, DebugSet, DebugStruct, DebugTuple};\n\n#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n#[doc(hidden)]\npub mod rt {\n    pub mod v1;\n}\n\n/// The type returned by formatter methods.\n///\n/// # Examples\n///\n/// ```\n/// use std::fmt;\n///\n/// #[derive(Debug)]\n/// struct Triangle {\n///     a: f32,\n///     b: f32,\n///     c: f32\n/// }\n///\n/// impl fmt::Display for Triangle {\n///     fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n///         write!(f, \"({}, {}, {})\", self.a, self.b, self.c)\n///     }\n/// }\n///\n/// let pythagorean_triple = Triangle { a: 3.0, b: 4.0, c: 5.0 };\n///\n/// assert_eq!(format!(\"{}\", pythagorean_triple), \"(3, 4, 5)\");\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub type Result = result::Result\u003c(), Error\u003e;\n\n/// The error type which is returned from formatting a message into a stream.\n///\n/// This type does not support transmission of an error other than that an error\n/// occurred. Any extra information must be arranged to be transmitted through\n/// some other means.\n///\n/// An important thing to remember is that the type `fmt::Error` should not be\n/// confused with [`std::io::Error`] or [`std::error::Error`], which you may also\n/// have in scope.\n///\n/// [`std::io::Error`]: ../../std/io/struct.Error.html\n/// [`std::error::Error`]: ../../std/error/trait.Error.html\n///\n/// # Examples\n///\n/// ```rust\n/// use std::fmt::{self, write};\n///\n/// let mut output = String::new();\n/// if let Err(fmt::Error) = write(\u0026mut output, format_args!(\"Hello {}!\", \"world\")) {\n///     panic!(\"An error occurred\");\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]\npub struct Error;\n\n/// A collection of methods that are required to format a message into a stream.\n///\n/// This trait is the type which this modules requires when formatting\n/// information. This is similar to the standard library's [`io::Write`] trait,\n/// but it is only intended for use in libcore.\n///\n/// This trait should generally not be implemented by consumers of the standard\n/// library. The [`write!`] macro accepts an instance of [`io::Write`], and the\n/// [`io::Write`] trait is favored over implementing this trait.\n///\n/// [`write!`]: ../../std/macro.write.html\n/// [`io::Write`]: ../../std/io/trait.Write.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Write {\n    /// Writes a string slice into this writer, returning whether the write\n    /// succeeded.\n    ///\n    /// This method can only succeed if the entire string slice was successfully\n    /// written, and this method will not return until all data has been\n    /// written or an error occurs.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an instance of [`Error`] on error.\n    ///\n    /// [`Error`]: struct.Error.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt::{Error, Write};\n    ///\n    /// fn writer\u003cW: Write\u003e(f: \u0026mut W, s: \u0026str) -\u003e Result\u003c(), Error\u003e {\n    ///     f.write_str(s)\n    /// }\n    ///\n    /// let mut buf = String::new();\n    /// writer(\u0026mut buf, \"hola\").unwrap();\n    /// assert_eq!(\u0026buf, \"hola\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write_str(\u0026mut self, s: \u0026str) -\u003e Result;\n\n    /// Writes a [`char`] into this writer, returning whether the write succeeded.\n    ///\n    /// A single [`char`] may be encoded as more than one byte.\n    /// This method can only succeed if the entire byte sequence was successfully\n    /// written, and this method will not return until all data has been\n    /// written or an error occurs.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an instance of [`Error`] on error.\n    ///\n    /// [`char`]: ../../std/primitive.char.html\n    /// [`Error`]: struct.Error.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt::{Error, Write};\n    ///\n    /// fn writer\u003cW: Write\u003e(f: \u0026mut W, c: char) -\u003e Result\u003c(), Error\u003e {\n    ///     f.write_char(c)\n    /// }\n    ///\n    /// let mut buf = String::new();\n    /// writer(\u0026mut buf, 'a').unwrap();\n    /// writer(\u0026mut buf, 'b').unwrap();\n    /// assert_eq!(\u0026buf, \"ab\");\n    /// ```\n    #[stable(feature = \"fmt_write_char\", since = \"1.1.0\")]\n    fn write_char(\u0026mut self, c: char) -\u003e Result {\n        self.write_str(c.encode_utf8(\u0026mut [0; 4]))\n    }\n\n    /// Glue for usage of the [`write!`] macro with implementors of this trait.\n    ///\n    /// This method should generally not be invoked manually, but rather through\n    /// the [`write!`] macro itself.\n    ///\n    /// [`write!`]: ../../std/macro.write.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt::{Error, Write};\n    ///\n    /// fn writer\u003cW: Write\u003e(f: \u0026mut W, s: \u0026str) -\u003e Result\u003c(), Error\u003e {\n    ///     f.write_fmt(format_args!(\"{}\", s))\n    /// }\n    ///\n    /// let mut buf = String::new();\n    /// writer(\u0026mut buf, \"world\").unwrap();\n    /// assert_eq!(\u0026buf, \"world\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write_fmt(mut self: \u0026mut Self, args: Arguments\u003c'_\u003e) -\u003e Result {\n        write(\u0026mut self, args)\n    }\n}\n\n#[stable(feature = \"fmt_write_blanket_impl\", since = \"1.4.0\")]\nimpl\u003cW: Write + ?Sized\u003e Write for \u0026mut W {\n    fn write_str(\u0026mut self, s: \u0026str) -\u003e Result {\n        (**self).write_str(s)\n    }\n\n    fn write_char(\u0026mut self, c: char) -\u003e Result {\n        (**self).write_char(c)\n    }\n\n    fn write_fmt(\u0026mut self, args: Arguments\u003c'_\u003e) -\u003e Result {\n        (**self).write_fmt(args)\n    }\n}\n\n/// Configuration for formatting.\n///\n/// A `Formatter` represents various options related to formatting. Users do not\n/// construct `Formatter`s directly; a mutable reference to one is passed to\n/// the `fmt` method of all formatting traits, like [`Debug`] and [`Display`].\n///\n/// To interact with a `Formatter`, you'll call various methods to change the\n/// various options related to formatting. For examples, please see the\n/// documentation of the methods defined on `Formatter` below.\n///\n/// [`Debug`]: trait.Debug.html\n/// [`Display`]: trait.Display.html\n#[allow(missing_debug_implementations)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Formatter\u003c'a\u003e {\n    flags: u32,\n    fill: char,\n    align: rt::v1::Alignment,\n    width: Option\u003cusize\u003e,\n    precision: Option\u003cusize\u003e,\n\n    buf: \u0026'a mut (dyn Write + 'a),\n}\n\n// NB. Argument is essentially an optimized partially applied formatting function,\n// equivalent to `exists T.(\u0026T, fn(\u0026T, \u0026mut Formatter\u003c'_\u003e) -\u003e Result`.\n\nextern \"C\" {\n    type Opaque;\n}\n\n/// This struct represents the generic \"argument\" which is taken by the Xprintf\n/// family of functions. It contains a function to format the given value. At\n/// compile time it is ensured that the function and the value have the correct\n/// types, and then this struct is used to canonicalize arguments to one type.\n#[derive(Copy, Clone)]\n#[allow(missing_debug_implementations)]\n#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n#[doc(hidden)]\npub struct ArgumentV1\u003c'a\u003e {\n    value: \u0026'a Opaque,\n    formatter: fn(\u0026Opaque, \u0026mut Formatter\u003c'_\u003e) -\u003e Result,\n}\n\n// This guarantees a single stable value for the function pointer associated with\n// indices/counts in the formatting infrastructure.\n//\n// Note that a function defined as such would not be correct as functions are\n// always tagged unnamed_addr with the current lowering to LLVM IR, so their\n// address is not considered important to LLVM and as such the as_usize cast\n// could have been miscompiled. In practice, we never call as_usize on non-usize\n// containing data (as a matter of static generation of the formatting\n// arguments), so this is merely an additional check.\n//\n// We primarily want to ensure that the function pointer at `USIZE_MARKER` has\n// an address corresponding *only* to functions that also take `\u0026usize` as their\n// first argument. The read_volatile here ensures that we can safely ready out a\n// usize from the passed reference and that this address does not point at a\n// non-usize taking function.\n#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\nstatic USIZE_MARKER: fn(\u0026usize, \u0026mut Formatter\u003c'_\u003e) -\u003e Result = |ptr, _| {\n    // SAFETY: ptr is a reference\n    let _v: usize = unsafe { crate::ptr::read_volatile(ptr) };\n    loop {}\n};\n\nimpl\u003c'a\u003e ArgumentV1\u003c'a\u003e {\n    #[doc(hidden)]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n    pub fn new\u003c'b, T\u003e(x: \u0026'b T, f: fn(\u0026T, \u0026mut Formatter\u003c'_\u003e) -\u003e Result) -\u003e ArgumentV1\u003c'b\u003e {\n        // SAFETY: `mem::transmute(x)` is safe because\n        //     1. `\u0026'b T` keeps the lifetime it originated with `'b`\n        //              (so as to not have an unbounded lifetime)\n        //     2. `\u0026'b T` and `\u0026'b Opaque` have the same memory layout\n        //              (when `T` is `Sized`, as it is here)\n        // `mem::transmute(f)` is safe since `fn(\u0026T, \u0026mut Formatter\u003c'_\u003e) -\u003e Result`\n        // and `fn(\u0026Opaque, \u0026mut Formatter\u003c'_\u003e) -\u003e Result` have the same ABI\n        // (as long as `T` is `Sized`)\n        unsafe { ArgumentV1 { formatter: mem::transmute(f), value: mem::transmute(x) } }\n    }\n\n    #[doc(hidden)]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n    pub fn from_usize(x: \u0026usize) -\u003e ArgumentV1\u003c'_\u003e {\n        ArgumentV1::new(x, USIZE_MARKER)\n    }\n\n    fn as_usize(\u0026self) -\u003e Option\u003cusize\u003e {\n        if self.formatter as usize == USIZE_MARKER as usize {\n            // SAFETY: The `formatter` field is only set to USIZE_MARKER if\n            // the value is a usize, so this is safe\n            Some(unsafe { *(self.value as *const _ as *const usize) })\n        } else {\n            None\n        }\n    }\n}\n\n// flags available in the v1 format of format_args\n#[derive(Copy, Clone)]\nenum FlagV1 {\n    SignPlus,\n    SignMinus,\n    Alternate,\n    SignAwareZeroPad,\n    DebugLowerHex,\n    DebugUpperHex,\n}\n\nimpl\u003c'a\u003e Arguments\u003c'a\u003e {\n    /// When using the format_args!() macro, this function is used to generate the\n    /// Arguments structure.\n    #[doc(hidden)]\n    #[inline]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n    pub fn new_v1(pieces: \u0026'a [\u0026'a str], args: \u0026'a [ArgumentV1\u003c'a\u003e]) -\u003e Arguments\u003c'a\u003e {\n        Arguments { pieces, fmt: None, args }\n    }\n\n    /// This function is used to specify nonstandard formatting parameters.\n    /// The `pieces` array must be at least as long as `fmt` to construct\n    /// a valid Arguments structure. Also, any `Count` within `fmt` that is\n    /// `CountIsParam` or `CountIsNextParam` has to point to an argument\n    /// created with `argumentusize`. However, failing to do so doesn't cause\n    /// unsafety, but will ignore invalid .\n    #[doc(hidden)]\n    #[inline]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n    pub fn new_v1_formatted(\n        pieces: \u0026'a [\u0026'a str],\n        args: \u0026'a [ArgumentV1\u003c'a\u003e],\n        fmt: \u0026'a [rt::v1::Argument],\n    ) -\u003e Arguments\u003c'a\u003e {\n        Arguments { pieces, fmt: Some(fmt), args }\n    }\n\n    /// Estimates the length of the formatted text.\n    ///\n    /// This is intended to be used for setting initial `String` capacity\n    /// when using `format!`. Note: this is neither the lower nor upper bound.\n    #[doc(hidden)]\n    #[inline]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n    pub fn estimated_capacity(\u0026self) -\u003e usize {\n        let pieces_length: usize = self.pieces.iter().map(|x| x.len()).sum();\n\n        if self.args.is_empty() {\n            pieces_length\n        } else if self.pieces[0] == \"\" \u0026\u0026 pieces_length \u003c 16 {\n            // If the format string starts with an argument,\n            // don't preallocate anything, unless length\n            // of pieces is significant.\n            0\n        } else {\n            // There are some arguments, so any additional push\n            // will reallocate the string. To avoid that,\n            // we're \"pre-doubling\" the capacity here.\n            pieces_length.checked_mul(2).unwrap_or(0)\n        }\n    }\n}\n\n/// This structure represents a safely precompiled version of a format string\n/// and its arguments. This cannot be generated at runtime because it cannot\n/// safely be done, so no constructors are given and the fields are private\n/// to prevent modification.\n///\n/// The [`format_args!`] macro will safely create an instance of this structure.\n/// The macro validates the format string at compile-time so usage of the\n/// [`write`] and [`format`] functions can be safely performed.\n///\n/// You can use the `Arguments\u003c'a\u003e` that [`format_args!`] returns in `Debug`\n/// and `Display` contexts as seen below. The example also shows that `Debug`\n/// and `Display` format to the same thing: the interpolated format string\n/// in `format_args!`.\n///\n/// ```rust\n/// let debug = format!(\"{:?}\", format_args!(\"{} foo {:?}\", 1, 2));\n/// let display = format!(\"{}\", format_args!(\"{} foo {:?}\", 1, 2));\n/// assert_eq!(\"1 foo 2\", display);\n/// assert_eq!(display, debug);\n/// ```\n///\n/// [`format_args!`]: ../../std/macro.format_args.html\n/// [`format`]: ../../std/fmt/fn.format.html\n/// [`write`]: ../../std/fmt/fn.write.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Copy, Clone)]\npub struct Arguments\u003c'a\u003e {\n    // Format string pieces to print.\n    pieces: \u0026'a [\u0026'a str],\n\n    // Placeholder specs, or `None` if all specs are default (as in \"{}{}\").\n    fmt: Option\u003c\u0026'a [rt::v1::Argument]\u003e,\n\n    // Dynamic arguments for interpolation, to be interleaved with string\n    // pieces. (Every argument is preceded by a string piece.)\n    args: \u0026'a [ArgumentV1\u003c'a\u003e],\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Debug for Arguments\u003c'_\u003e {\n    fn fmt(\u0026self, fmt: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        Display::fmt(self, fmt)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Display for Arguments\u003c'_\u003e {\n    fn fmt(\u0026self, fmt: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        write(fmt.buf, *self)\n    }\n}\n\n/// `?` formatting.\n///\n/// `Debug` should format the output in a programmer-facing, debugging context.\n///\n/// Generally speaking, you should just `derive` a `Debug` implementation.\n///\n/// When used with the alternate format specifier `#?`, the output is pretty-printed.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// This trait can be used with `#[derive]` if all fields implement `Debug`. When\n/// `derive`d for structs, it will use the name of the `struct`, then `{`, then a\n/// comma-separated list of each field's name and `Debug` value, then `}`. For\n/// `enum`s, it will use the name of the variant and, if applicable, `(`, then the\n/// `Debug` values of the fields, then `)`.\n///\n/// # Stability\n///\n/// Derived `Debug` formats are not stable, and so may change with future Rust\n/// versions. Additionally, `Debug` implementations of types provided by the\n/// standard library (`libstd`, `libcore`, `liballoc`, etc.) are not stable, and\n/// may also change with future Rust versions.\n///\n/// # Examples\n///\n/// Deriving an implementation:\n///\n/// ```\n/// #[derive(Debug)]\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// let origin = Point { x: 0, y: 0 };\n///\n/// assert_eq!(format!(\"The origin is: {:?}\", origin), \"The origin is: Point { x: 0, y: 0 }\");\n/// ```\n///\n/// Manually implementing:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// impl fmt::Debug for Point {\n///     fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n///         f.debug_struct(\"Point\")\n///          .field(\"x\", \u0026self.x)\n///          .field(\"y\", \u0026self.y)\n///          .finish()\n///     }\n/// }\n///\n/// let origin = Point { x: 0, y: 0 };\n///\n/// assert_eq!(format!(\"The origin is: {:?}\", origin), \"The origin is: Point { x: 0, y: 0 }\");\n/// ```\n///\n/// There are a number of helper methods on the [`Formatter`] struct to help you with manual\n/// implementations, such as [`debug_struct`].\n///\n/// `Debug` implementations using either `derive` or the debug builder API\n/// on [`Formatter`] support pretty-printing using the alternate flag: `{:#?}`.\n///\n/// [`debug_struct`]: ../../std/fmt/struct.Formatter.html#method.debug_struct\n/// [`Formatter`]: ../../std/fmt/struct.Formatter.html\n///\n/// Pretty-printing with `#?`:\n///\n/// ```\n/// #[derive(Debug)]\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// let origin = Point { x: 0, y: 0 };\n///\n/// assert_eq!(format!(\"The origin is: {:#?}\", origin),\n/// \"The origin is: Point {\n///     x: 0,\n///     y: 0,\n/// }\");\n/// ```\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(\n    on(\n        crate_local,\n        label = \"`{Self}` cannot be formatted using `{{:?}}`\",\n        note = \"add `#[derive(Debug)]` or manually implement `{Debug}`\"\n    ),\n    message = \"`{Self}` doesn't implement `{Debug}`\",\n    label = \"`{Self}` cannot be formatted using `{{:?}}` because it doesn't implement `{Debug}`\"\n)]\n#[doc(alias = \"{:?}\")]\n#[rustc_diagnostic_item = \"debug_trait\"]\npub trait Debug {\n    /// Formats the value using the given formatter.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Position {\n    ///     longitude: f32,\n    ///     latitude: f32,\n    /// }\n    ///\n    /// impl fmt::Debug for Position {\n    ///     fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n    ///         f.debug_tuple(\"\")\n    ///          .field(\u0026self.longitude)\n    ///          .field(\u0026self.latitude)\n    ///          .finish()\n    ///     }\n    /// }\n    ///\n    /// let position = Position { longitude: 1.987, latitude: 2.983 };\n    /// assert_eq!(format!(\"{:?}\", position), \"(1.987, 2.983)\");\n    ///\n    /// assert_eq!(format!(\"{:#?}\", position), \"(\n    ///     1.987,\n    ///     2.983,\n    /// )\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result;\n}\n\n// Separate module to reexport the macro `Debug` from prelude without the trait `Debug`.\npub(crate) mod macros {\n    /// Derive macro generating an impl of the trait `Debug`.\n    #[rustc_builtin_macro]\n    #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n    #[allow_internal_unstable(core_intrinsics)]\n    pub macro Debug($item:item) {\n        /* compiler built-in */\n    }\n}\n#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n#[doc(inline)]\npub use macros::Debug;\n\n/// Format trait for an empty format, `{}`.\n///\n/// `Display` is similar to [`Debug`][debug], but `Display` is for user-facing\n/// output, and so cannot be derived.\n///\n/// [debug]: trait.Debug.html\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Implementing `Display` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// impl fmt::Display for Point {\n///     fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n///         write!(f, \"({}, {})\", self.x, self.y)\n///     }\n/// }\n///\n/// let origin = Point { x: 0, y: 0 };\n///\n/// assert_eq!(format!(\"The origin is: {}\", origin), \"The origin is: (0, 0)\");\n/// ```\n#[rustc_on_unimplemented(\n    on(\n        _Self = \"std::path::Path\",\n        label = \"`{Self}` cannot be formatted with the default formatter; call `.display()` on it\",\n        note = \"call `.display()` or `.to_string_lossy()` to safely print paths, \\\n                as they may contain non-Unicode data\"\n    ),\n    message = \"`{Self}` doesn't implement `{Display}`\",\n    label = \"`{Self}` cannot be formatted with the default formatter\",\n    note = \"in format strings you may be able to use `{{:?}}` (or {{:#?}} for pretty-print) instead\"\n)]\n#[doc(alias = \"{}\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Display {\n    /// Formats the value using the given formatter.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Position {\n    ///     longitude: f32,\n    ///     latitude: f32,\n    /// }\n    ///\n    /// impl fmt::Display for Position {\n    ///     fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n    ///         write!(f, \"({}, {})\", self.longitude, self.latitude)\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\"(1.987, 2.983)\",\n    ///            format!(\"{}\", Position { longitude: 1.987, latitude: 2.983, }));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result;\n}\n\n/// `o` formatting.\n///\n/// The `Octal` trait should format its output as a number in base-8.\n///\n/// For primitive signed integers (`i8` to `i128`, and `isize`),\n/// negative values are formatted as the two’s complement representation.\n///\n/// The alternate flag, `#`, adds a `0o` in front of the output.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `i32`:\n///\n/// ```\n/// let x = 42; // 42 is '52' in octal\n///\n/// assert_eq!(format!(\"{:o}\", x), \"52\");\n/// assert_eq!(format!(\"{:#o}\", x), \"0o52\");\n///\n/// assert_eq!(format!(\"{:o}\", -16), \"37777777760\");\n/// ```\n///\n/// Implementing `Octal` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::Octal for Length {\n///     fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n///         let val = self.0;\n///\n///         fmt::Octal::fmt(\u0026val, f) // delegate to i32's implementation\n///     }\n/// }\n///\n/// let l = Length(9);\n///\n/// assert_eq!(format!(\"l as octal is: {:o}\", l), \"l as octal is: 11\");\n///\n/// assert_eq!(format!(\"l as octal is: {:#06o}\", l), \"l as octal is: 0o0011\");\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Octal {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result;\n}\n\n/// `b` formatting.\n///\n/// The `Binary` trait should format its output as a number in binary.\n///\n/// For primitive signed integers ([`i8`] to [`i128`], and [`isize`]),\n/// negative values are formatted as the two’s complement representation.\n///\n/// The alternate flag, `#`, adds a `0b` in front of the output.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// # Examples\n///\n/// Basic usage with [`i32`]:\n///\n/// ```\n/// let x = 42; // 42 is '101010' in binary\n///\n/// assert_eq!(format!(\"{:b}\", x), \"101010\");\n/// assert_eq!(format!(\"{:#b}\", x), \"0b101010\");\n///\n/// assert_eq!(format!(\"{:b}\", -16), \"11111111111111111111111111110000\");\n/// ```\n///\n/// Implementing `Binary` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::Binary for Length {\n///     fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n///         let val = self.0;\n///\n///         fmt::Binary::fmt(\u0026val, f) // delegate to i32's implementation\n///     }\n/// }\n///\n/// let l = Length(107);\n///\n/// assert_eq!(format!(\"l as binary is: {:b}\", l), \"l as binary is: 1101011\");\n///\n/// assert_eq!(\n///     format!(\"l as binary is: {:#032b}\", l),\n///     \"l as binary is: 0b000000000000000000000001101011\"\n/// );\n/// ```\n///\n/// [module]: ../../std/fmt/index.html\n/// [`i8`]: ../../std/primitive.i8.html\n/// [`i128`]: ../../std/primitive.i128.html\n/// [`isize`]: ../../std/primitive.isize.html\n/// [`i32`]: ../../std/primitive.i32.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Binary {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result;\n}\n\n/// `x` formatting.\n///\n/// The `LowerHex` trait should format its output as a number in hexadecimal, with `a` through `f`\n/// in lower case.\n///\n/// For primitive signed integers (`i8` to `i128`, and `isize`),\n/// negative values are formatted as the two’s complement representation.\n///\n/// The alternate flag, `#`, adds a `0x` in front of the output.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `i32`:\n///\n/// ```\n/// let x = 42; // 42 is '2a' in hex\n///\n/// assert_eq!(format!(\"{:x}\", x), \"2a\");\n/// assert_eq!(format!(\"{:#x}\", x), \"0x2a\");\n///\n/// assert_eq!(format!(\"{:x}\", -16), \"fffffff0\");\n/// ```\n///\n/// Implementing `LowerHex` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::LowerHex for Length {\n///     fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n///         let val = self.0;\n///\n///         fmt::LowerHex::fmt(\u0026val, f) // delegate to i32's implementation\n///     }\n/// }\n///\n/// let l = Length(9);\n///\n/// assert_eq!(format!(\"l as hex is: {:x}\", l), \"l as hex is: 9\");\n///\n/// assert_eq!(format!(\"l as hex is: {:#010x}\", l), \"l as hex is: 0x00000009\");\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait LowerHex {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result;\n}\n\n/// `X` formatting.\n///\n/// The `UpperHex` trait should format its output as a number in hexadecimal, with `A` through `F`\n/// in upper case.\n///\n/// For primitive signed integers (`i8` to `i128`, and `isize`),\n/// negative values are formatted as the two’s complement representation.\n///\n/// The alternate flag, `#`, adds a `0x` in front of the output.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `i32`:\n///\n/// ```\n/// let x = 42; // 42 is '2A' in hex\n///\n/// assert_eq!(format!(\"{:X}\", x), \"2A\");\n/// assert_eq!(format!(\"{:#X}\", x), \"0x2A\");\n///\n/// assert_eq!(format!(\"{:X}\", -16), \"FFFFFFF0\");\n/// ```\n///\n/// Implementing `UpperHex` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::UpperHex for Length {\n///     fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n///         let val = self.0;\n///\n///         fmt::UpperHex::fmt(\u0026val, f) // delegate to i32's implementation\n///     }\n/// }\n///\n/// let l = Length(i32::MAX);\n///\n/// assert_eq!(format!(\"l as hex is: {:X}\", l), \"l as hex is: 7FFFFFFF\");\n///\n/// assert_eq!(format!(\"l as hex is: {:#010X}\", l), \"l as hex is: 0x7FFFFFFF\");\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait UpperHex {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result;\n}\n\n/// `p` formatting.\n///\n/// The `Pointer` trait should format its output as a memory location. This is commonly presented\n/// as hexadecimal.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `\u0026i32`:\n///\n/// ```\n/// let x = \u002642;\n///\n/// let address = format!(\"{:p}\", x); // this produces something like '0x7f06092ac6d0'\n/// ```\n///\n/// Implementing `Pointer` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::Pointer for Length {\n///     fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n///         // use `as` to convert to a `*const T`, which implements Pointer, which we can use\n///\n///         let ptr = self as *const Self;\n///         fmt::Pointer::fmt(\u0026ptr, f)\n///     }\n/// }\n///\n/// let l = Length(42);\n///\n/// println!(\"l is in memory here: {:p}\", l);\n///\n/// let l_ptr = format!(\"{:018p}\", l);\n/// assert_eq!(l_ptr.len(), 18);\n/// assert_eq!(\u0026l_ptr[..2], \"0x\");\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Pointer {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result;\n}\n\n/// `e` formatting.\n///\n/// The `LowerExp` trait should format its output in scientific notation with a lower-case `e`.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `f64`:\n///\n/// ```\n/// let x = 42.0; // 42.0 is '4.2e1' in scientific notation\n///\n/// assert_eq!(format!(\"{:e}\", x), \"4.2e1\");\n/// ```\n///\n/// Implementing `LowerExp` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::LowerExp for Length {\n///     fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n///         let val = f64::from(self.0);\n///         fmt::LowerExp::fmt(\u0026val, f) // delegate to f64's implementation\n///     }\n/// }\n///\n/// let l = Length(100);\n///\n/// assert_eq!(\n///     format!(\"l in scientific notation is: {:e}\", l),\n///     \"l in scientific notation is: 1e2\"\n/// );\n///\n/// assert_eq!(\n///     format!(\"l in scientific notation is: {:05e}\", l),\n///     \"l in scientific notation is: 001e2\"\n/// );\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait LowerExp {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result;\n}\n\n/// `E` formatting.\n///\n/// The `UpperExp` trait should format its output in scientific notation with an upper-case `E`.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `f64`:\n///\n/// ```\n/// let x = 42.0; // 42.0 is '4.2E1' in scientific notation\n///\n/// assert_eq!(format!(\"{:E}\", x), \"4.2E1\");\n/// ```\n///\n/// Implementing `UpperExp` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::UpperExp for Length {\n///     fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n///         let val = f64::from(self.0);\n///         fmt::UpperExp::fmt(\u0026val, f) // delegate to f64's implementation\n///     }\n/// }\n///\n/// let l = Length(100);\n///\n/// assert_eq!(\n///     format!(\"l in scientific notation is: {:E}\", l),\n///     \"l in scientific notation is: 1E2\"\n/// );\n///\n/// assert_eq!(\n///     format!(\"l in scientific notation is: {:05E}\", l),\n///     \"l in scientific notation is: 001E2\"\n/// );\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait UpperExp {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result;\n}\n\n/// The `write` function takes an output stream, and an `Arguments` struct\n/// that can be precompiled with the `format_args!` macro.\n///\n/// The arguments will be formatted according to the specified format string\n/// into the output stream provided.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::fmt;\n///\n/// let mut output = String::new();\n/// fmt::write(\u0026mut output, format_args!(\"Hello {}!\", \"world\"))\n///     .expect(\"Error occurred while trying to write in String\");\n/// assert_eq!(output, \"Hello world!\");\n/// ```\n///\n/// Please note that using [`write!`] might be preferable. Example:\n///\n/// ```\n/// use std::fmt::Write;\n///\n/// let mut output = String::new();\n/// write!(\u0026mut output, \"Hello {}!\", \"world\")\n///     .expect(\"Error occurred while trying to write in String\");\n/// assert_eq!(output, \"Hello world!\");\n/// ```\n///\n/// [`write!`]: ../../std/macro.write.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn write(output: \u0026mut dyn Write, args: Arguments\u003c'_\u003e) -\u003e Result {\n    let mut formatter = Formatter {\n        flags: 0,\n        width: None,\n        precision: None,\n        buf: output,\n        align: rt::v1::Alignment::Unknown,\n        fill: ' ',\n    };\n\n    let mut idx = 0;\n\n    match args.fmt {\n        None =\u003e {\n            // We can use default formatting parameters for all arguments.\n            for (arg, piece) in args.args.iter().zip(args.pieces.iter()) {\n                formatter.buf.write_str(*piece)?;\n                (arg.formatter)(arg.value, \u0026mut formatter)?;\n                idx += 1;\n            }\n        }\n        Some(fmt) =\u003e {\n            // Every spec has a corresponding argument that is preceded by\n            // a string piece.\n            for (arg, piece) in fmt.iter().zip(args.pieces.iter()) {\n                formatter.buf.write_str(*piece)?;\n                run(\u0026mut formatter, arg, \u0026args.args)?;\n                idx += 1;\n            }\n        }\n    }\n\n    // There can be only one trailing string piece left.\n    if let Some(piece) = args.pieces.get(idx) {\n        formatter.buf.write_str(*piece)?;\n    }\n\n    Ok(())\n}\n\nfn run(fmt: \u0026mut Formatter\u003c'_\u003e, arg: \u0026rt::v1::Argument, args: \u0026[ArgumentV1\u003c'_\u003e]) -\u003e Result {\n    fmt.fill = arg.format.fill;\n    fmt.align = arg.format.align;\n    fmt.flags = arg.format.flags;\n    fmt.width = getcount(args, \u0026arg.format.width);\n    fmt.precision = getcount(args, \u0026arg.format.precision);\n\n    // Extract the correct argument\n    let value = args[arg.position];\n\n    // Then actually do some printing\n    (value.formatter)(value.value, fmt)\n}\n\nfn getcount(args: \u0026[ArgumentV1\u003c'_\u003e], cnt: \u0026rt::v1::Count) -\u003e Option\u003cusize\u003e {\n    match *cnt {\n        rt::v1::Count::Is(n) =\u003e Some(n),\n        rt::v1::Count::Implied =\u003e None,\n        rt::v1::Count::Param(i) =\u003e args[i].as_usize(),\n    }\n}\n\n/// Padding after the end of something. Returned by `Formatter::padding`.\n#[must_use = \"don't forget to write the post padding\"]\nstruct PostPadding {\n    fill: char,\n    padding: usize,\n}\n\nimpl PostPadding {\n    fn new(fill: char, padding: usize) -\u003e PostPadding {\n        PostPadding { fill, padding }\n    }\n\n    /// Write this post padding.\n    fn write(self, buf: \u0026mut dyn Write) -\u003e Result {\n        for _ in 0..self.padding {\n            buf.write_char(self.fill)?;\n        }\n        Ok(())\n    }\n}\n\nimpl\u003c'a\u003e Formatter\u003c'a\u003e {\n    fn wrap_buf\u003c'b, 'c, F\u003e(\u0026'b mut self, wrap: F) -\u003e Formatter\u003c'c\u003e\n    where\n        'b: 'c,\n        F: FnOnce(\u0026'b mut (dyn Write + 'b)) -\u003e \u0026'c mut (dyn Write + 'c),\n    {\n        Formatter {\n            // We want to change this\n            buf: wrap(self.buf),\n\n            // And preserve these\n            flags: self.flags,\n            fill: self.fill,\n            align: self.align,\n            width: self.width,\n            precision: self.precision,\n        }\n    }\n\n    // Helper methods used for padding and processing formatting arguments that\n    // all formatting traits can use.\n\n    /// Performs the correct padding for an integer which has already been\n    /// emitted into a str. The str should *not* contain the sign for the\n    /// integer, that will be added by this method.\n    ///\n    /// # Arguments\n    ///\n    /// * is_nonnegative - whether the original integer was either positive or zero.\n    /// * prefix - if the '#' character (Alternate) is provided, this\n    ///   is the prefix to put in front of the number.\n    /// * buf - the byte array that the number has been formatted into\n    ///\n    /// This function will correctly account for the flags provided as well as\n    /// the minimum width. It will not take precision into account.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo { nb: i32 };\n    ///\n    /// impl Foo {\n    ///     fn new(nb: i32) -\u003e Foo {\n    ///         Foo {\n    ///             nb,\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         // We need to remove \"-\" from the number output.\n    ///         let tmp = self.nb.abs().to_string();\n    ///\n    ///         formatter.pad_integral(self.nb \u003e 0, \"Foo \", \u0026tmp)\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\u0026format!(\"{}\", Foo::new(2)), \"2\");\n    /// assert_eq!(\u0026format!(\"{}\", Foo::new(-1)), \"-1\");\n    /// assert_eq!(\u0026format!(\"{:#}\", Foo::new(-1)), \"-Foo 1\");\n    /// assert_eq!(\u0026format!(\"{:0\u003e#8}\", Foo::new(-1)), \"00-Foo 1\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn pad_integral(\u0026mut self, is_nonnegative: bool, prefix: \u0026str, buf: \u0026str) -\u003e Result {\n        let mut width = buf.len();\n\n        let mut sign = None;\n        if !is_nonnegative {\n            sign = Some('-');\n            width += 1;\n        } else if self.sign_plus() {\n            sign = Some('+');\n            width += 1;\n        }\n\n        let prefix = if self.alternate() {\n            width += prefix.chars().count();\n            Some(prefix)\n        } else {\n            None\n        };\n\n        // Writes the sign if it exists, and then the prefix if it was requested\n        #[inline(never)]\n        fn write_prefix(f: \u0026mut Formatter\u003c'_\u003e, sign: Option\u003cchar\u003e, prefix: Option\u003c\u0026str\u003e) -\u003e Result {\n            if let Some(c) = sign {\n                f.buf.write_char(c)?;\n            }\n            if let Some(prefix) = prefix { f.buf.write_str(prefix) } else { Ok(()) }\n        }\n\n        // The `width` field is more of a `min-width` parameter at this point.\n        match self.width {\n            // If there's no minimum length requirements then we can just\n            // write the bytes.\n            None =\u003e {\n                write_prefix(self, sign, prefix)?;\n                self.buf.write_str(buf)\n            }\n            // Check if we're over the minimum width, if so then we can also\n            // just write the bytes.\n            Some(min) if width \u003e= min =\u003e {\n                write_prefix(self, sign, prefix)?;\n                self.buf.write_str(buf)\n            }\n            // The sign and prefix goes before the padding if the fill character\n            // is zero\n            Some(min) if self.sign_aware_zero_pad() =\u003e {\n                let old_fill = crate::mem::replace(\u0026mut self.fill, '0');\n                let old_align = crate::mem::replace(\u0026mut self.align, rt::v1::Alignment::Right);\n                write_prefix(self, sign, prefix)?;\n                let post_padding = self.padding(min - width, rt::v1::Alignment::Right)?;\n                self.buf.write_str(buf)?;\n                post_padding.write(self.buf)?;\n                self.fill = old_fill;\n                self.align = old_align;\n                Ok(())\n            }\n            // Otherwise, the sign and prefix goes after the padding\n            Some(min) =\u003e {\n                let post_padding = self.padding(min - width, rt::v1::Alignment::Right)?;\n                write_prefix(self, sign, prefix)?;\n                self.buf.write_str(buf)?;\n                post_padding.write(self.buf)\n            }\n        }\n    }\n\n    /// This function takes a string slice and emits it to the internal buffer\n    /// after applying the relevant formatting flags specified. The flags\n    /// recognized for generic strings are:\n    ///\n    /// * width - the minimum width of what to emit\n    /// * fill/align - what to emit and where to emit it if the string\n    ///                provided needs to be padded\n    /// * precision - the maximum length to emit, the string is truncated if it\n    ///               is longer than this length\n    ///\n    /// Notably this function ignores the `flag` parameters.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo;\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         formatter.pad(\"Foo\")\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\u0026format!(\"{:\u003c4}\", Foo), \"Foo \");\n    /// assert_eq!(\u0026format!(\"{:0\u003e4}\", Foo), \"0Foo\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn pad(\u0026mut self, s: \u0026str) -\u003e Result {\n        // Make sure there's a fast path up front\n        if self.width.is_none() \u0026\u0026 self.precision.is_none() {\n            return self.buf.write_str(s);\n        }\n        // The `precision` field can be interpreted as a `max-width` for the\n        // string being formatted.\n        let s = if let Some(max) = self.precision {\n            // If our string is longer that the precision, then we must have\n            // truncation. However other flags like `fill`, `width` and `align`\n            // must act as always.\n            if let Some((i, _)) = s.char_indices().nth(max) {\n                // LLVM here can't prove that `..i` won't panic `\u0026s[..i]`, but\n                // we know that it can't panic. Use `get` + `unwrap_or` to avoid\n                // `unsafe` and otherwise don't emit any panic-related code\n                // here.\n                s.get(..i).unwrap_or(\u0026s)\n            } else {\n                \u0026s\n            }\n        } else {\n            \u0026s\n        };\n        // The `width` field is more of a `min-width` parameter at this point.\n        match self.width {\n            // If we're under the maximum length, and there's no minimum length\n            // requirements, then we can just emit the string\n            None =\u003e self.buf.write_str(s),\n            // If we're under the maximum width, check if we're over the minimum\n            // width, if so it's as easy as just emitting the string.\n            Some(width) if s.chars().count() \u003e= width =\u003e self.buf.write_str(s),\n            // If we're under both the maximum and the minimum width, then fill\n            // up the minimum width with the specified string + some alignment.\n            Some(width) =\u003e {\n                let align = rt::v1::Alignment::Left;\n                let post_padding = self.padding(width - s.chars().count(), align)?;\n                self.buf.write_str(s)?;\n                post_padding.write(self.buf)\n            }\n        }\n    }\n\n    /// Write the pre-padding and return the unwritten post-padding. Callers are\n    /// responsible for ensuring post-padding is written after the thing that is\n    /// being padded.\n    fn padding(\n        \u0026mut self,\n        padding: usize,\n        default: rt::v1::Alignment,\n    ) -\u003e result::Result\u003cPostPadding, Error\u003e {\n        let align = match self.align {\n            rt::v1::Alignment::Unknown =\u003e default,\n            _ =\u003e self.align,\n        };\n\n        let (pre_pad, post_pad) = match align {\n            rt::v1::Alignment::Left =\u003e (0, padding),\n            rt::v1::Alignment::Right | rt::v1::Alignment::Unknown =\u003e (padding, 0),\n            rt::v1::Alignment::Center =\u003e (padding / 2, (padding + 1) / 2),\n        };\n\n        for _ in 0..pre_pad {\n            self.buf.write_char(self.fill)?;\n        }\n\n        Ok(PostPadding::new(self.fill, post_pad))\n    }\n\n    /// Takes the formatted parts and applies the padding.\n    /// Assumes that the caller already has rendered the parts with required precision,\n    /// so that `self.precision` can be ignored.\n    fn pad_formatted_parts(\u0026mut self, formatted: \u0026flt2dec::Formatted\u003c'_\u003e) -\u003e Result {\n        if let Some(mut width) = self.width {\n            // for the sign-aware zero padding, we render the sign first and\n            // behave as if we had no sign from the beginning.\n            let mut formatted = formatted.clone();\n            let old_fill = self.fill;\n            let old_align = self.align;\n            let mut align = old_align;\n            if self.sign_aware_zero_pad() {\n                // a sign always goes first\n                let sign = formatted.sign;\n                self.buf.write_str(sign)?;\n\n                // remove the sign from the formatted parts\n                formatted.sign = \"\";\n                width = width.saturating_sub(sign.len());\n                align = rt::v1::Alignment::Right;\n                self.fill = '0';\n                self.align = rt::v1::Alignment::Right;\n            }\n\n            // remaining parts go through the ordinary padding process.\n            let len = formatted.len();\n            let ret = if width \u003c= len {\n                // no padding\n                self.write_formatted_parts(\u0026formatted)\n            } else {\n                let post_padding = self.padding(width - len, align)?;\n                self.write_formatted_parts(\u0026formatted)?;\n                post_padding.write(self.buf)\n            };\n            self.fill = old_fill;\n            self.align = old_align;\n            ret\n        } else {\n            // this is the common case and we take a shortcut\n            self.write_formatted_parts(formatted)\n        }\n    }\n\n    fn write_formatted_parts(\u0026mut self, formatted: \u0026flt2dec::Formatted\u003c'_\u003e) -\u003e Result {\n        fn write_bytes(buf: \u0026mut dyn Write, s: \u0026[u8]) -\u003e Result {\n            // SAFETY: This is used for `flt2dec::Part::Num` and `flt2dec::Part::Copy`.\n            // It's safe to use for `flt2dec::Part::Num` since every char `c` is between\n            // `b'0'` and `b'9'`, which means `s` is valid UTF-8.\n            // It's also probably safe in practice to use for `flt2dec::Part::Copy(buf)`\n            // since `buf` should be plain ASCII, but it's possible for someone to pass\n            // in a bad value for `buf` into `flt2dec::to_shortest_str` since it is a\n            // public function.\n            // FIXME: Determine whether this could result in UB.\n            buf.write_str(unsafe { str::from_utf8_unchecked(s) })\n        }\n\n        if !formatted.sign.is_empty() {\n            self.buf.write_str(formatted.sign)?;\n        }\n        for part in formatted.parts {\n            match *part {\n                flt2dec::Part::Zero(mut nzeroes) =\u003e {\n                    const ZEROES: \u0026str = // 64 zeroes\n                        \"0000000000000000000000000000000000000000000000000000000000000000\";\n                    while nzeroes \u003e ZEROES.len() {\n                        self.buf.write_str(ZEROES)?;\n                        nzeroes -= ZEROES.len();\n                    }\n                    if nzeroes \u003e 0 {\n                        self.buf.write_str(\u0026ZEROES[..nzeroes])?;\n                    }\n                }\n                flt2dec::Part::Num(mut v) =\u003e {\n                    let mut s = [0; 5];\n                    let len = part.len();\n                    for c in s[..len].iter_mut().rev() {\n                        *c = b'0' + (v % 10) as u8;\n                        v /= 10;\n                    }\n                    write_bytes(self.buf, \u0026s[..len])?;\n                }\n                flt2dec::Part::Copy(buf) =\u003e {\n                    write_bytes(self.buf, buf)?;\n                }\n            }\n        }\n        Ok(())\n    }\n\n    /// Writes some data to the underlying buffer contained within this\n    /// formatter.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo;\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         formatter.write_str(\"Foo\")\n    ///         // This is equivalent to:\n    ///         // write!(formatter, \"Foo\")\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\u0026format!(\"{}\", Foo), \"Foo\");\n    /// assert_eq!(\u0026format!(\"{:0\u003e8}\", Foo), \"Foo\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn write_str(\u0026mut self, data: \u0026str) -\u003e Result {\n        self.buf.write_str(data)\n    }\n\n    /// Writes some formatted information into this instance.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32);\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         formatter.write_fmt(format_args!(\"Foo {}\", self.0))\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\u0026format!(\"{}\", Foo(-1)), \"Foo -1\");\n    /// assert_eq!(\u0026format!(\"{:0\u003e8}\", Foo(2)), \"Foo 2\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn write_fmt(\u0026mut self, fmt: Arguments\u003c'_\u003e) -\u003e Result {\n        write(self.buf, fmt)\n    }\n\n    /// Flags for formatting\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_deprecated(\n        since = \"1.24.0\",\n        reason = \"use the `sign_plus`, `sign_minus`, `alternate`, \\\n                  or `sign_aware_zero_pad` methods instead\"\n    )]\n    pub fn flags(\u0026self) -\u003e u32 {\n        self.flags\n    }\n\n    /// Character used as 'fill' whenever there is alignment.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo;\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         let c = formatter.fill();\n    ///         if let Some(width) = formatter.width() {\n    ///             for _ in 0..width {\n    ///                 write!(formatter, \"{}\", c)?;\n    ///             }\n    ///             Ok(())\n    ///         } else {\n    ///             write!(formatter, \"{}\", c)\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// // We set alignment to the left with \"\u003e\".\n    /// assert_eq!(\u0026format!(\"{:G\u003e3}\", Foo), \"GGG\");\n    /// assert_eq!(\u0026format!(\"{:t\u003e6}\", Foo), \"tttttt\");\n    /// ```\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn fill(\u0026self) -\u003e char {\n        self.fill\n    }\n\n    /// Flag indicating what form of alignment was requested.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// extern crate core;\n    ///\n    /// use std::fmt::{self, Alignment};\n    ///\n    /// struct Foo;\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         let s = if let Some(s) = formatter.align() {\n    ///             match s {\n    ///                 Alignment::Left    =\u003e \"left\",\n    ///                 Alignment::Right   =\u003e \"right\",\n    ///                 Alignment::Center  =\u003e \"center\",\n    ///             }\n    ///         } else {\n    ///             \"into the void\"\n    ///         };\n    ///         write!(formatter, \"{}\", s)\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\u0026format!(\"{:\u003c}\", Foo), \"left\");\n    /// assert_eq!(\u0026format!(\"{:\u003e}\", Foo), \"right\");\n    /// assert_eq!(\u0026format!(\"{:^}\", Foo), \"center\");\n    /// assert_eq!(\u0026format!(\"{}\", Foo), \"into the void\");\n    /// ```\n    #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n    pub fn align(\u0026self) -\u003e Option\u003cAlignment\u003e {\n        match self.align {\n            rt::v1::Alignment::Left =\u003e Some(Alignment::Left),\n            rt::v1::Alignment::Right =\u003e Some(Alignment::Right),\n            rt::v1::Alignment::Center =\u003e Some(Alignment::Center),\n            rt::v1::Alignment::Unknown =\u003e None,\n        }\n    }\n\n    /// Optionally specified integer width that the output should be.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32);\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         if let Some(width) = formatter.width() {\n    ///             // If we received a width, we use it\n    ///             write!(formatter, \"{:width$}\", \u0026format!(\"Foo({})\", self.0), width = width)\n    ///         } else {\n    ///             // Otherwise we do nothing special\n    ///             write!(formatter, \"Foo({})\", self.0)\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\u0026format!(\"{:10}\", Foo(23)), \"Foo(23)   \");\n    /// assert_eq!(\u0026format!(\"{}\", Foo(23)), \"Foo(23)\");\n    /// ```\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn width(\u0026self) -\u003e Option\u003cusize\u003e {\n        self.width\n    }\n\n    /// Optionally specified precision for numeric types. Alternatively, the\n    /// maximum width for string types.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(f32);\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         if let Some(precision) = formatter.precision() {\n    ///             // If we received a precision, we use it.\n    ///             write!(formatter, \"Foo({1:.*})\", precision, self.0)\n    ///         } else {\n    ///             // Otherwise we default to 2.\n    ///             write!(formatter, \"Foo({:.2})\", self.0)\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\u0026format!(\"{:.4}\", Foo(23.2)), \"Foo(23.2000)\");\n    /// assert_eq!(\u0026format!(\"{}\", Foo(23.2)), \"Foo(23.20)\");\n    /// ```\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn precision(\u0026self) -\u003e Option\u003cusize\u003e {\n        self.precision\n    }\n\n    /// Determines if the `+` flag was specified.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32);\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         if formatter.sign_plus() {\n    ///             write!(formatter,\n    ///                    \"Foo({}{})\",\n    ///                    if self.0 \u003c 0 { '-' } else { '+' },\n    ///                    self.0)\n    ///         } else {\n    ///             write!(formatter, \"Foo({})\", self.0)\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\u0026format!(\"{:+}\", Foo(23)), \"Foo(+23)\");\n    /// assert_eq!(\u0026format!(\"{}\", Foo(23)), \"Foo(23)\");\n    /// ```\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn sign_plus(\u0026self) -\u003e bool {\n        self.flags \u0026 (1 \u003c\u003c FlagV1::SignPlus as u32) != 0\n    }\n\n    /// Determines if the `-` flag was specified.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32);\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         if formatter.sign_minus() {\n    ///             // You want a minus sign? Have one!\n    ///             write!(formatter, \"-Foo({})\", self.0)\n    ///         } else {\n    ///             write!(formatter, \"Foo({})\", self.0)\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\u0026format!(\"{:-}\", Foo(23)), \"-Foo(23)\");\n    /// assert_eq!(\u0026format!(\"{}\", Foo(23)), \"Foo(23)\");\n    /// ```\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn sign_minus(\u0026self) -\u003e bool {\n        self.flags \u0026 (1 \u003c\u003c FlagV1::SignMinus as u32) != 0\n    }\n\n    /// Determines if the `#` flag was specified.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32);\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         if formatter.alternate() {\n    ///             write!(formatter, \"Foo({})\", self.0)\n    ///         } else {\n    ///             write!(formatter, \"{}\", self.0)\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\u0026format!(\"{:#}\", Foo(23)), \"Foo(23)\");\n    /// assert_eq!(\u0026format!(\"{}\", Foo(23)), \"23\");\n    /// ```\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn alternate(\u0026self) -\u003e bool {\n        self.flags \u0026 (1 \u003c\u003c FlagV1::Alternate as u32) != 0\n    }\n\n    /// Determines if the `0` flag was specified.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32);\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         assert!(formatter.sign_aware_zero_pad());\n    ///         assert_eq!(formatter.width(), Some(4));\n    ///         // We ignore the formatter's options.\n    ///         write!(formatter, \"{}\", self.0)\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\u0026format!(\"{:04}\", Foo(23)), \"23\");\n    /// ```\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn sign_aware_zero_pad(\u0026self) -\u003e bool {\n        self.flags \u0026 (1 \u003c\u003c FlagV1::SignAwareZeroPad as u32) != 0\n    }\n\n    // FIXME: Decide what public API we want for these two flags.\n    // https://github.com/rust-lang/rust/issues/48584\n    fn debug_lower_hex(\u0026self) -\u003e bool {\n        self.flags \u0026 (1 \u003c\u003c FlagV1::DebugLowerHex as u32) != 0\n    }\n\n    fn debug_upper_hex(\u0026self) -\u003e bool {\n        self.flags \u0026 (1 \u003c\u003c FlagV1::DebugUpperHex as u32) != 0\n    }\n\n    /// Creates a [`DebugStruct`] builder designed to assist with creation of\n    /// [`fmt::Debug`] implementations for structs.\n    ///\n    /// [`DebugStruct`]: ../../std/fmt/struct.DebugStruct.html\n    /// [`fmt::Debug`]: ../../std/fmt/trait.Debug.html\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    /// use std::net::Ipv4Addr;\n    ///\n    /// struct Foo {\n    ///     bar: i32,\n    ///     baz: String,\n    ///     addr: Ipv4Addr,\n    /// }\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(\u0026self, fmt: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         fmt.debug_struct(\"Foo\")\n    ///             .field(\"bar\", \u0026self.bar)\n    ///             .field(\"baz\", \u0026self.baz)\n    ///             .field(\"addr\", \u0026format_args!(\"{}\", self.addr))\n    ///             .finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     \"Foo { bar: 10, baz: \\\"Hello World\\\", addr: 127.0.0.1 }\",\n    ///     format!(\"{:?}\", Foo {\n    ///         bar: 10,\n    ///         baz: \"Hello World\".to_string(),\n    ///         addr: Ipv4Addr::new(127, 0, 0, 1),\n    ///     })\n    /// );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn debug_struct\u003c'b\u003e(\u0026'b mut self, name: \u0026str) -\u003e DebugStruct\u003c'b, 'a\u003e {\n        builders::debug_struct_new(self, name)\n    }\n\n    /// Creates a `DebugTuple` builder designed to assist with creation of\n    /// `fmt::Debug` implementations for tuple structs.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    /// use std::marker::PhantomData;\n    ///\n    /// struct Foo\u003cT\u003e(i32, String, PhantomData\u003cT\u003e);\n    ///\n    /// impl\u003cT\u003e fmt::Debug for Foo\u003cT\u003e {\n    ///     fn fmt(\u0026self, fmt: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         fmt.debug_tuple(\"Foo\")\n    ///             .field(\u0026self.0)\n    ///             .field(\u0026self.1)\n    ///             .field(\u0026format_args!(\"_\"))\n    ///             .finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     \"Foo(10, \\\"Hello\\\", _)\",\n    ///     format!(\"{:?}\", Foo(10, \"Hello\".to_string(), PhantomData::\u003cu8\u003e))\n    /// );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn debug_tuple\u003c'b\u003e(\u0026'b mut self, name: \u0026str) -\u003e DebugTuple\u003c'b, 'a\u003e {\n        builders::debug_tuple_new(self, name)\n    }\n\n    /// Creates a `DebugList` builder designed to assist with creation of\n    /// `fmt::Debug` implementations for list-like structures.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec\u003ci32\u003e);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(\u0026self, fmt: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         fmt.debug_list().entries(self.0.iter()).finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(format!(\"{:?}\", Foo(vec![10, 11])), \"[10, 11]\");\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn debug_list\u003c'b\u003e(\u0026'b mut self) -\u003e DebugList\u003c'b, 'a\u003e {\n        builders::debug_list_new(self)\n    }\n\n    /// Creates a `DebugSet` builder designed to assist with creation of\n    /// `fmt::Debug` implementations for set-like structures.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec\u003ci32\u003e);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(\u0026self, fmt: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         fmt.debug_set().entries(self.0.iter()).finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(format!(\"{:?}\", Foo(vec![10, 11])), \"{10, 11}\");\n    /// ```\n    ///\n    /// [`format_args!`]: ../../std/macro.format_args.html\n    ///\n    /// In this more complex example, we use [`format_args!`] and `.debug_set()`\n    /// to build a list of match arms:\n    ///\n    /// ```rust\n    /// use std::fmt;\n    ///\n    /// struct Arm\u003c'a, L: 'a, R: 'a\u003e(\u0026'a (L, R));\n    /// struct Table\u003c'a, K: 'a, V: 'a\u003e(\u0026'a [(K, V)], V);\n    ///\n    /// impl\u003c'a, L, R\u003e fmt::Debug for Arm\u003c'a, L, R\u003e\n    /// where\n    ///     L: 'a + fmt::Debug, R: 'a + fmt::Debug\n    /// {\n    ///     fn fmt(\u0026self, fmt: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         L::fmt(\u0026(self.0).0, fmt)?;\n    ///         fmt.write_str(\" =\u003e \")?;\n    ///         R::fmt(\u0026(self.0).1, fmt)\n    ///     }\n    /// }\n    ///\n    /// impl\u003c'a, K, V\u003e fmt::Debug for Table\u003c'a, K, V\u003e\n    /// where\n    ///     K: 'a + fmt::Debug, V: 'a + fmt::Debug\n    /// {\n    ///     fn fmt(\u0026self, fmt: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         fmt.debug_set()\n    ///         .entries(self.0.iter().map(Arm))\n    ///         .entry(\u0026Arm(\u0026(format_args!(\"_\"), \u0026self.1)))\n    ///         .finish()\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn debug_set\u003c'b\u003e(\u0026'b mut self) -\u003e DebugSet\u003c'b, 'a\u003e {\n        builders::debug_set_new(self)\n    }\n\n    /// Creates a `DebugMap` builder designed to assist with creation of\n    /// `fmt::Debug` implementations for map-like structures.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec\u003c(String, i32)\u003e);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(\u0026self, fmt: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///         fmt.debug_map().entries(self.0.iter().map(|\u0026(ref k, ref v)| (k, v))).finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     format!(\"{:?}\",  Foo(vec![(\"A\".to_string(), 10), (\"B\".to_string(), 11)])),\n    ///     r#\"{\"A\": 10, \"B\": 11}\"#\n    ///  );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn debug_map\u003c'b\u003e(\u0026'b mut self) -\u003e DebugMap\u003c'b, 'a\u003e {\n        builders::debug_map_new(self)\n    }\n}\n\n#[stable(since = \"1.2.0\", feature = \"formatter_write\")]\nimpl Write for Formatter\u003c'_\u003e {\n    fn write_str(\u0026mut self, s: \u0026str) -\u003e Result {\n        self.buf.write_str(s)\n    }\n\n    fn write_char(\u0026mut self, c: char) -\u003e Result {\n        self.buf.write_char(c)\n    }\n\n    fn write_fmt(\u0026mut self, args: Arguments\u003c'_\u003e) -\u003e Result {\n        write(self.buf, args)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Display for Error {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        Display::fmt(\"an error occurred when formatting an argument\", f)\n    }\n}\n\n// Implementations of the core formatting traits\n\nmacro_rules! fmt_refs {\n    ($($tr:ident),*) =\u003e {\n        $(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl\u003cT: ?Sized + $tr\u003e $tr for \u0026T {\n            fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result { $tr::fmt(\u0026**self, f) }\n        }\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl\u003cT: ?Sized + $tr\u003e $tr for \u0026mut T {\n            fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result { $tr::fmt(\u0026**self, f) }\n        }\n        )*\n    }\n}\n\nfmt_refs! { Debug, Display, Octal, Binary, LowerHex, UpperHex, LowerExp, UpperExp }\n\n#[unstable(feature = \"never_type\", issue = \"35121\")]\nimpl Debug for ! {\n    fn fmt(\u0026self, _: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        *self\n    }\n}\n\n#[unstable(feature = \"never_type\", issue = \"35121\")]\nimpl Display for ! {\n    fn fmt(\u0026self, _: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        *self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Debug for bool {\n    #[inline]\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        Display::fmt(self, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Display for bool {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        Display::fmt(if *self { \"true\" } else { \"false\" }, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Debug for str {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        f.write_char('\"')?;\n        let mut from = 0;\n        for (i, c) in self.char_indices() {\n            let esc = c.escape_debug();\n            // If char needs escaping, flush backlog so far and write, else skip\n            if esc.len() != 1 {\n                f.write_str(\u0026self[from..i])?;\n                for c in esc {\n                    f.write_char(c)?;\n                }\n                from = i + c.len_utf8();\n            }\n        }\n        f.write_str(\u0026self[from..])?;\n        f.write_char('\"')\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Display for str {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        f.pad(self)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Debug for char {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        f.write_char('\\'')?;\n        for c in self.escape_debug() {\n            f.write_char(c)?\n        }\n        f.write_char('\\'')\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Display for char {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        if f.width.is_none() \u0026\u0026 f.precision.is_none() {\n            f.write_char(*self)\n        } else {\n            f.pad(self.encode_utf8(\u0026mut [0; 4]))\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003cT: ?Sized\u003e Pointer for *const T {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        let old_width = f.width;\n        let old_flags = f.flags;\n\n        // The alternate flag is already treated by LowerHex as being special-\n        // it denotes whether to prefix with 0x. We use it to work out whether\n        // or not to zero extend, and then unconditionally set it to get the\n        // prefix.\n        if f.alternate() {\n            f.flags |= 1 \u003c\u003c (FlagV1::SignAwareZeroPad as u32);\n\n            if f.width.is_none() {\n                f.width = Some(((mem::size_of::\u003cusize\u003e() * 8) / 4) + 2);\n            }\n        }\n        f.flags |= 1 \u003c\u003c (FlagV1::Alternate as u32);\n\n        let ret = LowerHex::fmt(\u0026(*self as *const () as usize), f);\n\n        f.width = old_width;\n        f.flags = old_flags;\n\n        ret\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003cT: ?Sized\u003e Pointer for *mut T {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        Pointer::fmt(\u0026(*self as *const T), f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003cT: ?Sized\u003e Pointer for \u0026T {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        Pointer::fmt(\u0026(*self as *const T), f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003cT: ?Sized\u003e Pointer for \u0026mut T {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        Pointer::fmt(\u0026(\u0026**self as *const T), f)\n    }\n}\n\n// Implementation of Display/Debug for various core types\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003cT: ?Sized\u003e Debug for *const T {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        Pointer::fmt(self, f)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003cT: ?Sized\u003e Debug for *mut T {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        Pointer::fmt(self, f)\n    }\n}\n\nmacro_rules! peel {\n    ($name:ident, $($other:ident,)*) =\u003e (tuple! { $($other,)* })\n}\n\nmacro_rules! tuple {\n    () =\u003e ();\n    ( $($name:ident,)+ ) =\u003e (\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl\u003c$($name:Debug),+\u003e Debug for ($($name,)+) where last_type!($($name,)+): ?Sized {\n            #[allow(non_snake_case, unused_assignments)]\n            fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n                let mut builder = f.debug_tuple(\"\");\n                let ($(ref $name,)+) = *self;\n                $(\n                    builder.field(\u0026$name);\n                )+\n\n                builder.finish()\n            }\n        }\n        peel! { $($name,)+ }\n    )\n}\n\nmacro_rules! last_type {\n    ($a:ident,) =\u003e { $a };\n    ($a:ident, $($rest_a:ident,)+) =\u003e { last_type!($($rest_a,)+) };\n}\n\ntuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003cT: Debug\u003e Debug for [T] {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        f.debug_list().entries(self.iter()).finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Debug for () {\n    #[inline]\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        f.pad(\"()\")\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003cT: ?Sized\u003e Debug for PhantomData\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        f.pad(\"PhantomData\")\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003cT: Copy + Debug\u003e Debug for Cell\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        f.debug_struct(\"Cell\").field(\"value\", \u0026self.get()).finish()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003cT: ?Sized + Debug\u003e Debug for RefCell\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        match self.try_borrow() {\n            Ok(borrow) =\u003e f.debug_struct(\"RefCell\").field(\"value\", \u0026borrow).finish(),\n            Err(_) =\u003e {\n                // The RefCell is mutably borrowed so we can't look at its value\n                // here. Show a placeholder instead.\n                struct BorrowedPlaceholder;\n\n                impl Debug for BorrowedPlaceholder {\n                    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n                        f.write_str(\"\u003cborrowed\u003e\")\n                    }\n                }\n\n                f.debug_struct(\"RefCell\").field(\"value\", \u0026BorrowedPlaceholder).finish()\n            }\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003cT: ?Sized + Debug\u003e Debug for Ref\u003c'_, T\u003e {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        Debug::fmt(\u0026**self, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl\u003cT: ?Sized + Debug\u003e Debug for RefMut\u003c'_, T\u003e {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        Debug::fmt(\u0026*(self.deref()), f)\n    }\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl\u003cT: ?Sized + Debug\u003e Debug for UnsafeCell\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        f.pad(\"UnsafeCell\")\n    }\n}\n\n// If you expected tests to be here, look instead at the ui/ifmt.rs test,\n// it's a lot easier than creating all of the rt::Piece structures here.\n","traces":[{"line":281,"address":[4212640,4212448,4212736,4212544],"length":1,"stats":{"Line":0},"fn_name":"new\u003c\u0026i32\u003e"},{"line":290,"address":[4212750,4212558,4212654,4212462],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[4212631,4212520,4212808,4212823,4212727,4212712,4212535,4212616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[4211344],"length":1,"stats":{"Line":0},"fn_name":"new_v1"},{"line":328,"address":[4211371],"length":1,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[4211411,4211416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1981,"address":[4212352,4212414,4212366,4212400],"length":1,"stats":{"Line":0},"fn_name":"fmt\u003cu32\u003e"}],"covered":0,"coverable":7},{"path":["/","usr","local","rustup","toolchains","1.45.2-x86_64-unknown-linux-gnu","lib","rustlib","src","rust","src","libcore","fmt","num.rs"],"content":"//! Integer and floating-point number formatting\n\nuse crate::fmt;\nuse crate::mem::MaybeUninit;\nuse crate::num::flt2dec;\nuse crate::ops::{Div, Rem, Sub};\nuse crate::ptr;\nuse crate::slice;\nuse crate::str;\n\n#[doc(hidden)]\ntrait Int:\n    PartialEq + PartialOrd + Div\u003cOutput = Self\u003e + Rem\u003cOutput = Self\u003e + Sub\u003cOutput = Self\u003e + Copy\n{\n    fn zero() -\u003e Self;\n    fn from_u8(u: u8) -\u003e Self;\n    fn to_u8(\u0026self) -\u003e u8;\n    fn to_u16(\u0026self) -\u003e u16;\n    fn to_u32(\u0026self) -\u003e u32;\n    fn to_u64(\u0026self) -\u003e u64;\n    fn to_u128(\u0026self) -\u003e u128;\n}\n\nmacro_rules! doit {\n    ($($t:ident)*) =\u003e ($(impl Int for $t {\n        fn zero() -\u003e Self { 0 }\n        fn from_u8(u: u8) -\u003e Self { u as Self }\n        fn to_u8(\u0026self) -\u003e u8 { *self as u8 }\n        fn to_u16(\u0026self) -\u003e u16 { *self as u16 }\n        fn to_u32(\u0026self) -\u003e u32 { *self as u32 }\n        fn to_u64(\u0026self) -\u003e u64 { *self as u64 }\n        fn to_u128(\u0026self) -\u003e u128 { *self as u128 }\n    })*)\n}\ndoit! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }\n\n/// A type that represents a specific radix\n#[doc(hidden)]\ntrait GenericRadix {\n    /// The number of digits.\n    const BASE: u8;\n\n    /// A radix-specific prefix string.\n    const PREFIX: \u0026'static str;\n\n    /// Converts an integer to corresponding radix digit.\n    fn digit(x: u8) -\u003e u8;\n\n    /// Format an integer using the radix using a formatter.\n    fn fmt_int\u003cT: Int\u003e(\u0026self, mut x: T, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        // The radix can be as low as 2, so we need a buffer of at least 128\n        // characters for a base 2 number.\n        let zero = T::zero();\n        let is_nonnegative = x \u003e= zero;\n        let mut buf = [MaybeUninit::\u003cu8\u003e::uninit(); 128];\n        let mut curr = buf.len();\n        let base = T::from_u8(Self::BASE);\n        if is_nonnegative {\n            // Accumulate each digit of the number from the least significant\n            // to the most significant figure.\n            for byte in buf.iter_mut().rev() {\n                let n = x % base; // Get the current place value.\n                x = x / base; // Deaccumulate the number.\n                byte.write(Self::digit(n.to_u8())); // Store the digit in the buffer.\n                curr -= 1;\n                if x == zero {\n                    // No more digits left to accumulate.\n                    break;\n                };\n            }\n        } else {\n            // Do the same as above, but accounting for two's complement.\n            for byte in buf.iter_mut().rev() {\n                let n = zero - (x % base); // Get the current place value.\n                x = x / base; // Deaccumulate the number.\n                byte.write(Self::digit(n.to_u8())); // Store the digit in the buffer.\n                curr -= 1;\n                if x == zero {\n                    // No more digits left to accumulate.\n                    break;\n                };\n            }\n        }\n        let buf = \u0026buf[curr..];\n        // SAFETY: The only chars in `buf` are created by `Self::digit` which are assumed to be\n        // valid UTF-8\n        let buf = unsafe {\n            str::from_utf8_unchecked(slice::from_raw_parts(MaybeUninit::first_ptr(buf), buf.len()))\n        };\n        f.pad_integral(is_nonnegative, Self::PREFIX, buf)\n    }\n}\n\n/// A binary (base 2) radix\n#[derive(Clone, PartialEq)]\nstruct Binary;\n\n/// An octal (base 8) radix\n#[derive(Clone, PartialEq)]\nstruct Octal;\n\n/// A hexadecimal (base 16) radix, formatted with lower-case characters\n#[derive(Clone, PartialEq)]\nstruct LowerHex;\n\n/// A hexadecimal (base 16) radix, formatted with upper-case characters\n#[derive(Clone, PartialEq)]\nstruct UpperHex;\n\nmacro_rules! radix {\n    ($T:ident, $base:expr, $prefix:expr, $($x:pat =\u003e $conv:expr),+) =\u003e {\n        impl GenericRadix for $T {\n            const BASE: u8 = $base;\n            const PREFIX: \u0026'static str = $prefix;\n            fn digit(x: u8) -\u003e u8 {\n                match x {\n                    $($x =\u003e $conv,)+\n                    x =\u003e panic!(\"number not in the range 0..={}: {}\", Self::BASE - 1, x),\n                }\n            }\n        }\n    }\n}\n\nradix! { Binary,    2, \"0b\", x @  0 ..=  1 =\u003e b'0' + x }\nradix! { Octal,     8, \"0o\", x @  0 ..=  7 =\u003e b'0' + x }\nradix! { LowerHex, 16, \"0x\", x @  0 ..=  9 =\u003e b'0' + x,\nx @ 10 ..= 15 =\u003e b'a' + (x - 10) }\nradix! { UpperHex, 16, \"0x\", x @  0 ..=  9 =\u003e b'0' + x,\nx @ 10 ..= 15 =\u003e b'A' + (x - 10) }\n\nmacro_rules! int_base {\n    ($Trait:ident for $T:ident as $U:ident -\u003e $Radix:ident) =\u003e {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl fmt::$Trait for $T {\n            fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                $Radix.fmt_int(*self as $U, f)\n            }\n        }\n    };\n}\n\nmacro_rules! debug {\n    ($T:ident) =\u003e {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl fmt::Debug for $T {\n            #[inline]\n            fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                if f.debug_lower_hex() {\n                    fmt::LowerHex::fmt(self, f)\n                } else if f.debug_upper_hex() {\n                    fmt::UpperHex::fmt(self, f)\n                } else {\n                    fmt::Display::fmt(self, f)\n                }\n            }\n        }\n    };\n}\n\nmacro_rules! integer {\n    ($Int:ident, $Uint:ident) =\u003e {\n        int_base! { Binary   for $Int as $Uint  -\u003e Binary }\n        int_base! { Octal    for $Int as $Uint  -\u003e Octal }\n        int_base! { LowerHex for $Int as $Uint  -\u003e LowerHex }\n        int_base! { UpperHex for $Int as $Uint  -\u003e UpperHex }\n        debug! { $Int }\n\n        int_base! { Binary   for $Uint as $Uint -\u003e Binary }\n        int_base! { Octal    for $Uint as $Uint -\u003e Octal }\n        int_base! { LowerHex for $Uint as $Uint -\u003e LowerHex }\n        int_base! { UpperHex for $Uint as $Uint -\u003e UpperHex }\n        debug! { $Uint }\n    };\n}\ninteger! { isize, usize }\ninteger! { i8, u8 }\ninteger! { i16, u16 }\ninteger! { i32, u32 }\ninteger! { i64, u64 }\ninteger! { i128, u128 }\n\nstatic DEC_DIGITS_LUT: \u0026[u8; 200] = b\"0001020304050607080910111213141516171819\\\n      2021222324252627282930313233343536373839\\\n      4041424344454647484950515253545556575859\\\n      6061626364656667686970717273747576777879\\\n      8081828384858687888990919293949596979899\";\n\nmacro_rules! impl_Display {\n    ($($t:ident),* as $u:ident via $conv_fn:ident named $name:ident) =\u003e {\n        fn $name(mut n: $u, is_nonnegative: bool, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n            // 2^128 is about 3*10^38, so 39 gives an extra byte of space\n            let mut buf = [MaybeUninit::\u003cu8\u003e::uninit(); 39];\n            let mut curr = buf.len() as isize;\n            let buf_ptr = MaybeUninit::first_ptr_mut(\u0026mut buf);\n            let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n\n            // SAFETY: Since `d1` and `d2` are always less than or equal to `198`, we\n            // can copy from `lut_ptr[d1..d1 + 1]` and `lut_ptr[d2..d2 + 1]`. To show\n            // that it's OK to copy into `buf_ptr`, notice that at the beginning\n            // `curr == buf.len() == 39 \u003e log(n)` since `n \u003c 2^128 \u003c 10^39`, and at\n            // each step this is kept the same as `n` is divided. Since `n` is always\n            // non-negative, this means that `curr \u003e 0` so `buf_ptr[curr..curr + 1]`\n            // is safe to access.\n            unsafe {\n                // need at least 16 bits for the 4-characters-at-a-time to work.\n                assert!(crate::mem::size_of::\u003c$u\u003e() \u003e= 2);\n\n                // eagerly decode 4 characters at a time\n                while n \u003e= 10000 {\n                    let rem = (n % 10000) as isize;\n                    n /= 10000;\n\n                    let d1 = (rem / 100) \u003c\u003c 1;\n                    let d2 = (rem % 100) \u003c\u003c 1;\n                    curr -= 4;\n\n                    // We are allowed to copy to `buf_ptr[curr..curr + 3]` here since\n                    // otherwise `curr \u003c 0`. But then `n` was originally at least `10000^10`\n                    // which is `10^40 \u003e 2^128 \u003e n`.\n                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                    ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\n                }\n\n                // if we reach here numbers are \u003c= 9999, so at most 4 chars long\n                let mut n = n as isize; // possibly reduce 64bit math\n\n                // decode 2 more chars, if \u003e 2 chars\n                if n \u003e= 100 {\n                    let d1 = (n % 100) \u003c\u003c 1;\n                    n /= 100;\n                    curr -= 2;\n                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                }\n\n                // decode last 1 or 2 chars\n                if n \u003c 10 {\n                    curr -= 1;\n                    *buf_ptr.offset(curr) = (n as u8) + b'0';\n                } else {\n                    let d1 = n \u003c\u003c 1;\n                    curr -= 2;\n                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                }\n            }\n\n            // SAFETY: `curr` \u003e 0 (since we made `buf` large enough), and all the chars are valid\n            // UTF-8 since `DEC_DIGITS_LUT` is\n            let buf_slice = unsafe {\n                str::from_utf8_unchecked(\n                    slice::from_raw_parts(buf_ptr.offset(curr), buf.len() - curr as usize))\n            };\n            f.pad_integral(is_nonnegative, \"\", buf_slice)\n        }\n\n        $(\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl fmt::Display for $t {\n                #[allow(unused_comparisons)]\n                fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                    let is_nonnegative = *self \u003e= 0;\n                    let n = if is_nonnegative {\n                        self.$conv_fn()\n                    } else {\n                        // convert the negative num to positive by summing 1 to it's 2 complement\n                        (!self.$conv_fn()).wrapping_add(1)\n                    };\n                    $name(n, is_nonnegative, f)\n                }\n            })*\n    };\n}\n\nmacro_rules! impl_Exp {\n    ($($t:ident),* as $u:ident via $conv_fn:ident named $name:ident) =\u003e {\n        fn $name(\n            mut n: $u,\n            is_nonnegative: bool,\n            upper: bool,\n            f: \u0026mut fmt::Formatter\u003c'_\u003e\n        ) -\u003e fmt::Result {\n            let (mut n, mut exponent, trailing_zeros, added_precision) = {\n                let mut exponent = 0;\n                // count and remove trailing decimal zeroes\n                while n % 10 == 0 \u0026\u0026 n \u003e= 10 {\n                    n /= 10;\n                    exponent += 1;\n                }\n                let trailing_zeros = exponent;\n\n                let (added_precision, subtracted_precision) = match f.precision() {\n                    Some(fmt_prec) =\u003e {\n                        // number of decimal digits minus 1\n                        let mut tmp = n;\n                        let mut prec = 0;\n                        while tmp \u003e= 10 {\n                            tmp /= 10;\n                            prec += 1;\n                        }\n                        (fmt_prec.saturating_sub(prec), prec.saturating_sub(fmt_prec))\n                    }\n                    None =\u003e (0,0)\n                };\n                for _ in 1..subtracted_precision {\n                    n/=10;\n                    exponent += 1;\n                }\n                if subtracted_precision != 0 {\n                    let rem = n % 10;\n                    n /= 10;\n                    exponent += 1;\n                    // round up last digit\n                    if rem \u003e= 5 {\n                        n += 1;\n                    }\n                }\n                (n, exponent, trailing_zeros, added_precision)\n            };\n\n            // 39 digits (worst case u128) + . = 40\n            // Since `curr` always decreases by the number of digits copied, this means\n            // that `curr \u003e= 0`.\n            let mut buf = [MaybeUninit::\u003cu8\u003e::uninit(); 40];\n            let mut curr = buf.len() as isize; //index for buf\n            let buf_ptr = MaybeUninit::first_ptr_mut(\u0026mut buf);\n            let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n\n            // decode 2 chars at a time\n            while n \u003e= 100 {\n                let d1 = ((n % 100) as isize) \u003c\u003c 1;\n                curr -= 2;\n                // SAFETY: `d1 \u003c= 198`, so we can copy from `lut_ptr[d1..d1 + 2]` since\n                // `DEC_DIGITS_LUT` has a length of 200.\n                unsafe {\n                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                }\n                n /= 100;\n                exponent += 2;\n            }\n            // n is \u003c= 99, so at most 2 chars long\n            let mut n = n as isize; // possibly reduce 64bit math\n            // decode second-to-last character\n            if n \u003e= 10 {\n                curr -= 1;\n                // SAFETY: Safe since `40 \u003e curr \u003e= 0` (see comment)\n                unsafe {\n                    *buf_ptr.offset(curr) = (n as u8 % 10_u8) + b'0';\n                }\n                n /= 10;\n                exponent += 1;\n            }\n            // add decimal point iff \u003e1 mantissa digit will be printed\n            if exponent != trailing_zeros || added_precision != 0 {\n                curr -= 1;\n                // SAFETY: Safe since `40 \u003e curr \u003e= 0`\n                unsafe {\n                    *buf_ptr.offset(curr) = b'.';\n                }\n            }\n\n            // SAFETY: Safe since `40 \u003e curr \u003e= 0`\n            let buf_slice = unsafe {\n                // decode last character\n                curr -= 1;\n                *buf_ptr.offset(curr) = (n as u8) + b'0';\n\n                let len = buf.len() - curr as usize;\n                slice::from_raw_parts(buf_ptr.offset(curr), len)\n            };\n\n            // stores 'e' (or 'E') and the up to 2-digit exponent\n            let mut exp_buf = [MaybeUninit::\u003cu8\u003e::uninit(); 3];\n            let exp_ptr = MaybeUninit::first_ptr_mut(\u0026mut exp_buf);\n            // SAFETY: In either case, `exp_buf` is written within bounds and `exp_ptr[..len]`\n            // is contained within `exp_buf` since `len \u003c= 3`.\n            let exp_slice = unsafe {\n                *exp_ptr.offset(0) = if upper {b'E'} else {b'e'};\n                let len = if exponent \u003c 10 {\n                    *exp_ptr.offset(1) = (exponent as u8) + b'0';\n                    2\n                } else {\n                    let off = exponent \u003c\u003c 1;\n                    ptr::copy_nonoverlapping(lut_ptr.offset(off), exp_ptr.offset(1), 2);\n                    3\n                };\n                slice::from_raw_parts(exp_ptr, len)\n            };\n\n            let parts = \u0026[\n                flt2dec::Part::Copy(buf_slice),\n                flt2dec::Part::Zero(added_precision),\n                flt2dec::Part::Copy(exp_slice)\n            ];\n            let sign = if !is_nonnegative {\n                \"-\"\n            } else if f.sign_plus() {\n                \"+\"\n            } else {\n                \"\"\n            };\n            let formatted = flt2dec::Formatted{sign, parts};\n            f.pad_formatted_parts(\u0026formatted)\n        }\n\n        $(\n            #[stable(feature = \"integer_exp_format\", since = \"1.42.0\")]\n            impl fmt::LowerExp for $t {\n                #[allow(unused_comparisons)]\n                fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                    let is_nonnegative = *self \u003e= 0;\n                    let n = if is_nonnegative {\n                        self.$conv_fn()\n                    } else {\n                        // convert the negative num to positive by summing 1 to it's 2 complement\n                        (!self.$conv_fn()).wrapping_add(1)\n                    };\n                    $name(n, is_nonnegative, false, f)\n                }\n            })*\n        $(\n            #[stable(feature = \"integer_exp_format\", since = \"1.42.0\")]\n            impl fmt::UpperExp for $t {\n                #[allow(unused_comparisons)]\n                fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                    let is_nonnegative = *self \u003e= 0;\n                    let n = if is_nonnegative {\n                        self.$conv_fn()\n                    } else {\n                        // convert the negative num to positive by summing 1 to it's 2 complement\n                        (!self.$conv_fn()).wrapping_add(1)\n                    };\n                    $name(n, is_nonnegative, true, f)\n                }\n            })*\n    };\n}\n\n// Include wasm32 in here since it doesn't reflect the native pointer size, and\n// often cares strongly about getting a smaller code size.\n#[cfg(any(target_pointer_width = \"64\", target_arch = \"wasm32\"))]\nmod imp {\n    use super::*;\n    impl_Display!(\n        i8, u8, i16, u16, i32, u32, i64, u64, usize, isize\n            as u64 via to_u64 named fmt_u64\n    );\n    impl_Exp!(\n        i8, u8, i16, u16, i32, u32, i64, u64, usize, isize\n            as u64 via to_u64 named exp_u64\n    );\n}\n\n#[cfg(not(any(target_pointer_width = \"64\", target_arch = \"wasm32\")))]\nmod imp {\n    use super::*;\n    impl_Display!(i8, u8, i16, u16, i32, u32, isize, usize as u32 via to_u32 named fmt_u32);\n    impl_Display!(i64, u64 as u64 via to_u64 named fmt_u64);\n    impl_Exp!(i8, u8, i16, u16, i32, u32, isize, usize as u32 via to_u32 named exp_u32);\n    impl_Exp!(i64, u64 as u64 via to_u64 named exp_u64);\n}\n\nimpl_Display!(i128, u128 as u128 via to_u128 named fmt_u128);\nimpl_Exp!(i128, u128 as u128 via to_u128 named exp_u128);\n","traces":[{"line":148,"address":[4213072,4212896],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":149,"address":[4213091,4212982,4212915,4213220,4213158,4213044],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[4213146,4212970],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[4212988,4213216,4213040,4212948,4213124,4213164],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[4213204,4213028],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[4213004,4213180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[4213060,4213222,4213236,4213046],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":7},{"path":["/","usr","local","rustup","toolchains","1.45.2-x86_64-unknown-linux-gnu","lib","rustlib","src","rust","src","libcore","macros","mod.rs"],"content":"#[doc(include = \"panic.md\")]\n#[macro_export]\n#[allow_internal_unstable(core_panic, track_caller)]\n#[stable(feature = \"core\", since = \"1.6.0\")]\nmacro_rules! panic {\n    () =\u003e (\n        $crate::panic!(\"explicit panic\")\n    );\n    ($msg:expr) =\u003e (\n        $crate::panicking::panic($msg)\n    );\n    ($msg:expr,) =\u003e (\n        $crate::panic!($msg)\n    );\n    ($fmt:expr, $($arg:tt)+) =\u003e (\n        $crate::panicking::panic_fmt($crate::format_args!($fmt, $($arg)+))\n    );\n}\n\n/// Asserts that two expressions are equal to each other (using [`PartialEq`]).\n///\n/// On panic, this macro will print the values of the expressions with their\n/// debug representations.\n///\n/// Like [`assert!`], this macro has a second form, where a custom\n/// panic message can be provided.\n///\n/// [`PartialEq`]: cmp/trait.PartialEq.html\n/// [`assert!`]: macro.assert.html\n///\n/// # Examples\n///\n/// ```\n/// let a = 3;\n/// let b = 1 + 2;\n/// assert_eq!(a, b);\n///\n/// assert_eq!(a, b, \"we are testing addition with {} and {}\", a, b);\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! assert_eq {\n    ($left:expr, $right:expr) =\u003e ({\n        match (\u0026$left, \u0026$right) {\n            (left_val, right_val) =\u003e {\n                if !(*left_val == *right_val) {\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    panic!(r#\"assertion failed: `(left == right)`\n  left: `{:?}`,\n right: `{:?}`\"#, \u0026*left_val, \u0026*right_val)\n                }\n            }\n        }\n    });\n    ($left:expr, $right:expr,) =\u003e ({\n        $crate::assert_eq!($left, $right)\n    });\n    ($left:expr, $right:expr, $($arg:tt)+) =\u003e ({\n        match (\u0026($left), \u0026($right)) {\n            (left_val, right_val) =\u003e {\n                if !(*left_val == *right_val) {\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    panic!(r#\"assertion failed: `(left == right)`\n  left: `{:?}`,\n right: `{:?}`: {}\"#, \u0026*left_val, \u0026*right_val,\n                           $crate::format_args!($($arg)+))\n                }\n            }\n        }\n    });\n}\n\n/// Asserts that two expressions are not equal to each other (using [`PartialEq`]).\n///\n/// On panic, this macro will print the values of the expressions with their\n/// debug representations.\n///\n/// Like [`assert!`], this macro has a second form, where a custom\n/// panic message can be provided.\n///\n/// [`PartialEq`]: cmp/trait.PartialEq.html\n/// [`assert!`]: macro.assert.html\n///\n/// # Examples\n///\n/// ```\n/// let a = 3;\n/// let b = 2;\n/// assert_ne!(a, b);\n///\n/// assert_ne!(a, b, \"we are testing that the values are not equal\");\n/// ```\n#[macro_export]\n#[stable(feature = \"assert_ne\", since = \"1.13.0\")]\nmacro_rules! assert_ne {\n    ($left:expr, $right:expr) =\u003e ({\n        match (\u0026$left, \u0026$right) {\n            (left_val, right_val) =\u003e {\n                if *left_val == *right_val {\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    panic!(r#\"assertion failed: `(left != right)`\n  left: `{:?}`,\n right: `{:?}`\"#, \u0026*left_val, \u0026*right_val)\n                }\n            }\n        }\n    });\n    ($left:expr, $right:expr,) =\u003e {\n        $crate::assert_ne!($left, $right)\n    };\n    ($left:expr, $right:expr, $($arg:tt)+) =\u003e ({\n        match (\u0026($left), \u0026($right)) {\n            (left_val, right_val) =\u003e {\n                if *left_val == *right_val {\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    panic!(r#\"assertion failed: `(left != right)`\n  left: `{:?}`,\n right: `{:?}`: {}\"#, \u0026*left_val, \u0026*right_val,\n                           $crate::format_args!($($arg)+))\n                }\n            }\n        }\n    });\n}\n\n/// Asserts that a boolean expression is `true` at runtime.\n///\n/// This will invoke the [`panic!`] macro if the provided expression cannot be\n/// evaluated to `true` at runtime.\n///\n/// Like [`assert!`], this macro also has a second version, where a custom panic\n/// message can be provided.\n///\n/// # Uses\n///\n/// Unlike [`assert!`], `debug_assert!` statements are only enabled in non\n/// optimized builds by default. An optimized build will not execute\n/// `debug_assert!` statements unless `-C debug-assertions` is passed to the\n/// compiler. This makes `debug_assert!` useful for checks that are too\n/// expensive to be present in a release build but may be helpful during\n/// development. The result of expanding `debug_assert!` is always type checked.\n///\n/// An unchecked assertion allows a program in an inconsistent state to keep\n/// running, which might have unexpected consequences but does not introduce\n/// unsafety as long as this only happens in safe code. The performance cost\n/// of assertions, is however, not measurable in general. Replacing [`assert!`]\n/// with `debug_assert!` is thus only encouraged after thorough profiling, and\n/// more importantly, only in safe code!\n///\n/// [`panic!`]: macro.panic.html\n/// [`assert!`]: macro.assert.html\n///\n/// # Examples\n///\n/// ```\n/// // the panic message for these assertions is the stringified value of the\n/// // expression given.\n/// debug_assert!(true);\n///\n/// fn some_expensive_computation() -\u003e bool { true } // a very simple function\n/// debug_assert!(some_expensive_computation());\n///\n/// // assert with a custom message\n/// let x = true;\n/// debug_assert!(x, \"x wasn't true!\");\n///\n/// let a = 3; let b = 27;\n/// debug_assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! debug_assert {\n    ($($arg:tt)*) =\u003e (if $crate::cfg!(debug_assertions) { $crate::assert!($($arg)*); })\n}\n\n/// Asserts that two expressions are equal to each other.\n///\n/// On panic, this macro will print the values of the expressions with their\n/// debug representations.\n///\n/// Unlike [`assert_eq!`], `debug_assert_eq!` statements are only enabled in non\n/// optimized builds by default. An optimized build will not execute\n/// `debug_assert_eq!` statements unless `-C debug-assertions` is passed to the\n/// compiler. This makes `debug_assert_eq!` useful for checks that are too\n/// expensive to be present in a release build but may be helpful during\n/// development. The result of expanding `debug_assert_eq!` is always type checked.\n///\n/// [`assert_eq!`]: ../std/macro.assert_eq.html\n///\n/// # Examples\n///\n/// ```\n/// let a = 3;\n/// let b = 1 + 2;\n/// debug_assert_eq!(a, b);\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! debug_assert_eq {\n    ($($arg:tt)*) =\u003e (if $crate::cfg!(debug_assertions) { $crate::assert_eq!($($arg)*); })\n}\n\n/// Asserts that two expressions are not equal to each other.\n///\n/// On panic, this macro will print the values of the expressions with their\n/// debug representations.\n///\n/// Unlike [`assert_ne!`], `debug_assert_ne!` statements are only enabled in non\n/// optimized builds by default. An optimized build will not execute\n/// `debug_assert_ne!` statements unless `-C debug-assertions` is passed to the\n/// compiler. This makes `debug_assert_ne!` useful for checks that are too\n/// expensive to be present in a release build but may be helpful during\n/// development. The result of expanding `debug_assert_ne!` is always type checked.\n///\n/// [`assert_ne!`]: ../std/macro.assert_ne.html\n///\n/// # Examples\n///\n/// ```\n/// let a = 3;\n/// let b = 2;\n/// debug_assert_ne!(a, b);\n/// ```\n#[macro_export]\n#[stable(feature = \"assert_ne\", since = \"1.13.0\")]\nmacro_rules! debug_assert_ne {\n    ($($arg:tt)*) =\u003e (if $crate::cfg!(debug_assertions) { $crate::assert_ne!($($arg)*); })\n}\n\n/// Returns whether the given expression matches any of the given patterns.\n///\n/// Like in a `match` expression, the pattern can be optionally followed by `if`\n/// and a guard expression that has access to names bound by the pattern.\n///\n/// # Examples\n///\n/// ```\n/// let foo = 'f';\n/// assert!(matches!(foo, 'A'..='Z' | 'a'..='z'));\n///\n/// let bar = Some(4);\n/// assert!(matches!(bar, Some(x) if x \u003e 2));\n/// ```\n#[macro_export]\n#[stable(feature = \"matches_macro\", since = \"1.42.0\")]\nmacro_rules! matches {\n    ($expression:expr, $( $pattern:pat )|+ $( if $guard: expr )?) =\u003e {\n        match $expression {\n            $( $pattern )|+ $( if $guard )? =\u003e true,\n            _ =\u003e false\n        }\n    }\n}\n\n/// Unwraps a result or propagates its error.\n///\n/// The `?` operator was added to replace `try!` and should be used instead.\n/// Furthermore, `try` is a reserved word in Rust 2018, so if you must use\n/// it, you will need to use the [raw-identifier syntax][ris]: `r#try`.\n///\n/// [ris]: https://doc.rust-lang.org/nightly/rust-by-example/compatibility/raw_identifiers.html\n///\n/// `try!` matches the given [`Result`]. In case of the `Ok` variant, the\n/// expression has the value of the wrapped value.\n///\n/// In case of the `Err` variant, it retrieves the inner error. `try!` then\n/// performs conversion using `From`. This provides automatic conversion\n/// between specialized errors and more general ones. The resulting\n/// error is then immediately returned.\n///\n/// Because of the early return, `try!` can only be used in functions that\n/// return [`Result`].\n///\n/// [`Result`]: ../std/result/enum.Result.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io;\n/// use std::fs::File;\n/// use std::io::prelude::*;\n///\n/// enum MyError {\n///     FileWriteError\n/// }\n///\n/// impl From\u003cio::Error\u003e for MyError {\n///     fn from(e: io::Error) -\u003e MyError {\n///         MyError::FileWriteError\n///     }\n/// }\n///\n/// // The preferred method of quick returning Errors\n/// fn write_to_file_question() -\u003e Result\u003c(), MyError\u003e {\n///     let mut file = File::create(\"my_best_friends.txt\")?;\n///     file.write_all(b\"This is a list of my best friends.\")?;\n///     Ok(())\n/// }\n///\n/// // The previous method of quick returning Errors\n/// fn write_to_file_using_try() -\u003e Result\u003c(), MyError\u003e {\n///     let mut file = r#try!(File::create(\"my_best_friends.txt\"));\n///     r#try!(file.write_all(b\"This is a list of my best friends.\"));\n///     Ok(())\n/// }\n///\n/// // This is equivalent to:\n/// fn write_to_file_using_match() -\u003e Result\u003c(), MyError\u003e {\n///     let mut file = r#try!(File::create(\"my_best_friends.txt\"));\n///     match file.write_all(b\"This is a list of my best friends.\") {\n///         Ok(v) =\u003e v,\n///         Err(e) =\u003e return Err(From::from(e)),\n///     }\n///     Ok(())\n/// }\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(since = \"1.39.0\", reason = \"use the `?` operator instead\")]\n#[doc(alias = \"?\")]\nmacro_rules! r#try {\n    ($expr:expr) =\u003e {\n        match $expr {\n            $crate::result::Result::Ok(val) =\u003e val,\n            $crate::result::Result::Err(err) =\u003e {\n                return $crate::result::Result::Err($crate::convert::From::from(err));\n            }\n        }\n    };\n    ($expr:expr,) =\u003e {\n        $crate::r#try!($expr)\n    };\n}\n\n/// Writes formatted data into a buffer.\n///\n/// This macro accepts a format string, a list of arguments, and a 'writer'. Arguments will be\n/// formatted according to the specified format string and the result will be passed to the writer.\n/// The writer may be any value with a `write_fmt` method; generally this comes from an\n/// implementation of either the [`std::fmt::Write`] or the [`std::io::Write`] trait. The macro\n/// returns whatever the `write_fmt` method returns; commonly a [`std::fmt::Result`], or an\n/// [`io::Result`].\n///\n/// See [`std::fmt`] for more information on the format string syntax.\n///\n/// [`std::fmt`]: ../std/fmt/index.html\n/// [`std::fmt::Write`]: ../std/fmt/trait.Write.html\n/// [`std::io::Write`]: ../std/io/trait.Write.html\n/// [`std::fmt::Result`]: ../std/fmt/type.Result.html\n/// [`io::Result`]: ../std/io/type.Result.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io::Write;\n///\n/// fn main() -\u003e std::io::Result\u003c()\u003e {\n///     let mut w = Vec::new();\n///     write!(\u0026mut w, \"test\")?;\n///     write!(\u0026mut w, \"formatted {}\", \"arguments\")?;\n///\n///     assert_eq!(w, b\"testformatted arguments\");\n///     Ok(())\n/// }\n/// ```\n///\n/// A module can import both `std::fmt::Write` and `std::io::Write` and call `write!` on objects\n/// implementing either, as objects do not typically implement both. However, the module must\n/// import the traits qualified so their names do not conflict:\n///\n/// ```\n/// use std::fmt::Write as FmtWrite;\n/// use std::io::Write as IoWrite;\n///\n/// fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n///     let mut s = String::new();\n///     let mut v = Vec::new();\n///\n///     write!(\u0026mut s, \"{} {}\", \"abc\", 123)?; // uses fmt::Write::write_fmt\n///     write!(\u0026mut v, \"s = {:?}\", s)?; // uses io::Write::write_fmt\n///     assert_eq!(v, b\"s = \\\"abc 123\\\"\");\n///     Ok(())\n/// }\n/// ```\n///\n/// Note: This macro can be used in `no_std` setups as well.\n/// In a `no_std` setup you are responsible for the implementation details of the components.\n///\n/// ```no_run\n/// # extern crate core;\n/// use core::fmt::Write;\n///\n/// struct Example;\n///\n/// impl Write for Example {\n///     fn write_str(\u0026mut self, _s: \u0026str) -\u003e core::fmt::Result {\n///          unimplemented!();\n///     }\n/// }\n///\n/// let mut m = Example{};\n/// write!(\u0026mut m, \"Hello World\").expect(\"Not written\");\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! write {\n    ($dst:expr, $($arg:tt)*) =\u003e ($dst.write_fmt($crate::format_args!($($arg)*)))\n}\n\n/// Write formatted data into a buffer, with a newline appended.\n///\n/// On all platforms, the newline is the LINE FEED character (`\\n`/`U+000A`) alone\n/// (no additional CARRIAGE RETURN (`\\r`/`U+000D`).\n///\n/// For more information, see [`write!`]. For information on the format string syntax, see\n/// [`std::fmt`].\n///\n/// [`write!`]: macro.write.html\n/// [`std::fmt`]: ../std/fmt/index.html\n///\n///\n/// # Examples\n///\n/// ```\n/// use std::io::{Write, Result};\n///\n/// fn main() -\u003e Result\u003c()\u003e {\n///     let mut w = Vec::new();\n///     writeln!(\u0026mut w)?;\n///     writeln!(\u0026mut w, \"test\")?;\n///     writeln!(\u0026mut w, \"formatted {}\", \"arguments\")?;\n///\n///     assert_eq!(\u0026w[..], \"\\ntest\\nformatted arguments\\n\".as_bytes());\n///     Ok(())\n/// }\n/// ```\n///\n/// A module can import both `std::fmt::Write` and `std::io::Write` and call `write!` on objects\n/// implementing either, as objects do not typically implement both. However, the module must\n/// import the traits qualified so their names do not conflict:\n///\n/// ```\n/// use std::fmt::Write as FmtWrite;\n/// use std::io::Write as IoWrite;\n///\n/// fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n///     let mut s = String::new();\n///     let mut v = Vec::new();\n///\n///     writeln!(\u0026mut s, \"{} {}\", \"abc\", 123)?; // uses fmt::Write::write_fmt\n///     writeln!(\u0026mut v, \"s = {:?}\", s)?; // uses io::Write::write_fmt\n///     assert_eq!(v, b\"s = \\\"abc 123\\\\n\\\"\\n\");\n///     Ok(())\n/// }\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow_internal_unstable(format_args_nl)]\nmacro_rules! writeln {\n    ($dst:expr) =\u003e (\n        $crate::write!($dst, \"\\n\")\n    );\n    ($dst:expr,) =\u003e (\n        $crate::writeln!($dst)\n    );\n    ($dst:expr, $($arg:tt)*) =\u003e (\n        $dst.write_fmt($crate::format_args_nl!($($arg)*))\n    );\n}\n\n/// Indicates unreachable code.\n///\n/// This is useful any time that the compiler can't determine that some code is unreachable. For\n/// example:\n///\n/// * Match arms with guard conditions.\n/// * Loops that dynamically terminate.\n/// * Iterators that dynamically terminate.\n///\n/// If the determination that the code is unreachable proves incorrect, the\n/// program immediately terminates with a [`panic!`].\n///\n/// The unsafe counterpart of this macro is the [`unreachable_unchecked`] function, which\n/// will cause undefined behavior if the code is reached.\n///\n/// [`panic!`]: ../std/macro.panic.html\n/// [`unreachable_unchecked`]: ../std/hint/fn.unreachable_unchecked.html\n/// [`std::hint`]: ../std/hint/index.html\n///\n/// # Panics\n///\n/// This will always [`panic!`]\n///\n/// [`panic!`]: ../std/macro.panic.html\n///\n/// # Examples\n///\n/// Match arms:\n///\n/// ```\n/// # #[allow(dead_code)]\n/// fn foo(x: Option\u003ci32\u003e) {\n///     match x {\n///         Some(n) if n \u003e= 0 =\u003e println!(\"Some(Non-negative)\"),\n///         Some(n) if n \u003c  0 =\u003e println!(\"Some(Negative)\"),\n///         Some(_)           =\u003e unreachable!(), // compile error if commented out\n///         None              =\u003e println!(\"None\")\n///     }\n/// }\n/// ```\n///\n/// Iterators:\n///\n/// ```\n/// # #[allow(dead_code)]\n/// fn divide_by_three(x: u32) -\u003e u32 { // one of the poorest implementations of x/3\n///     for i in 0.. {\n///         if 3*i \u003c i { panic!(\"u32 overflow\"); }\n///         if x \u003c 3*i { return i-1; }\n///     }\n///     unreachable!();\n/// }\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! unreachable {\n    () =\u003e ({\n        panic!(\"internal error: entered unreachable code\")\n    });\n    ($msg:expr) =\u003e ({\n        $crate::unreachable!(\"{}\", $msg)\n    });\n    ($msg:expr,) =\u003e ({\n        $crate::unreachable!($msg)\n    });\n    ($fmt:expr, $($arg:tt)*) =\u003e ({\n        panic!($crate::concat!(\"internal error: entered unreachable code: \", $fmt), $($arg)*)\n    });\n}\n\n/// Indicates unimplemented code by panicking with a message of \"not implemented\".\n///\n/// This allows your code to type-check, which is useful if you are prototyping or\n/// implementing a trait that requires multiple methods which you don't plan of using all of.\n///\n/// The difference between `unimplemented!` and [`todo!`](macro.todo.html) is that while `todo!`\n/// conveys an intent of implementing the functionality later and the message is \"not yet\n/// implemented\", `unimplemented!` makes no such claims. Its message is \"not implemented\".\n/// Also some IDEs will mark `todo!`s.\n///\n/// # Panics\n///\n/// This will always [panic!](macro.panic.html) because `unimplemented!` is just a\n/// shorthand for `panic!` with a fixed, specific message.\n///\n/// Like `panic!`, this macro has a second form for displaying custom values.\n///\n/// # Examples\n///\n/// Say we have a trait `Foo`:\n///\n/// ```\n/// trait Foo {\n///     fn bar(\u0026self) -\u003e u8;\n///     fn baz(\u0026self);\n///     fn qux(\u0026self) -\u003e Result\u003cu64, ()\u003e;\n/// }\n/// ```\n///\n/// We want to implement `Foo` for 'MyStruct', but for some reason it only makes sense\n/// to implement the `bar()` function. `baz()` and `qux()` will still need to be defined\n/// in our implementation of `Foo`, but we can use `unimplemented!` in their definitions\n/// to allow our code to compile.\n///\n/// We still want to have our program stop running if the unimplemented methods are\n/// reached.\n///\n/// ```\n/// # trait Foo {\n/// #     fn bar(\u0026self) -\u003e u8;\n/// #     fn baz(\u0026self);\n/// #     fn qux(\u0026self) -\u003e Result\u003cu64, ()\u003e;\n/// # }\n/// struct MyStruct;\n///\n/// impl Foo for MyStruct {\n///     fn bar(\u0026self) -\u003e u8 {\n///         1 + 1\n///     }\n///\n///     fn baz(\u0026self) {\n///         // It makes no sense to `baz` a `MyStruct`, so we have no logic here\n///         // at all.\n///         // This will display \"thread 'main' panicked at 'not implemented'\".\n///         unimplemented!();\n///     }\n///\n///     fn qux(\u0026self) -\u003e Result\u003cu64, ()\u003e {\n///         // We have some logic here,\n///         // We can add a message to unimplemented! to display our omission.\n///         // This will display:\n///         // \"thread 'main' panicked at 'not implemented: MyStruct isn't quxable'\".\n///         unimplemented!(\"MyStruct isn't quxable\");\n///     }\n/// }\n///\n/// fn main() {\n///     let s = MyStruct;\n///     s.bar();\n/// }\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! unimplemented {\n    () =\u003e (panic!(\"not implemented\"));\n    ($($arg:tt)+) =\u003e (panic!(\"not implemented: {}\", $crate::format_args!($($arg)+)));\n}\n\n/// Indicates unfinished code.\n///\n/// This can be useful if you are prototyping and are just looking to have your\n/// code typecheck.\n///\n/// The difference between [`unimplemented!`] and `todo!` is that while `todo!` conveys\n/// an intent of implementing the functionality later and the message is \"not yet\n/// implemented\", `unimplemented!` makes no such claims. Its message is \"not implemented\".\n/// Also some IDEs will mark `todo!`s.\n///\n/// [`unimplemented!`]: macro.unimplemented.html\n///\n/// # Panics\n///\n/// This will always [panic!](macro.panic.html)\n///\n/// # Examples\n///\n/// Here's an example of some in-progress code. We have a trait `Foo`:\n///\n/// ```\n/// trait Foo {\n///     fn bar(\u0026self);\n///     fn baz(\u0026self);\n/// }\n/// ```\n///\n/// We want to implement `Foo` on one of our types, but we also want to work on\n/// just `bar()` first. In order for our code to compile, we need to implement\n/// `baz()`, so we can use `todo!`:\n///\n/// ```\n/// # trait Foo {\n/// #     fn bar(\u0026self);\n/// #     fn baz(\u0026self);\n/// # }\n/// struct MyStruct;\n///\n/// impl Foo for MyStruct {\n///     fn bar(\u0026self) {\n///         // implementation goes here\n///     }\n///\n///     fn baz(\u0026self) {\n///         // let's not worry about implementing baz() for now\n///         todo!();\n///     }\n/// }\n///\n/// fn main() {\n///     let s = MyStruct;\n///     s.bar();\n///\n///     // we aren't even using baz(), so this is fine.\n/// }\n/// ```\n#[macro_export]\n#[stable(feature = \"todo_macro\", since = \"1.40.0\")]\nmacro_rules! todo {\n    () =\u003e (panic!(\"not yet implemented\"));\n    ($($arg:tt)+) =\u003e (panic!(\"not yet implemented: {}\", $crate::format_args!($($arg)+)));\n}\n\n/// Definitions of built-in macros.\n///\n/// Most of the macro properties (stability, visibility, etc.) are taken from the source code here,\n/// with exception of expansion functions transforming macro inputs into outputs,\n/// those functions are provided by the compiler.\npub(crate) mod builtin {\n\n    /// Causes compilation to fail with the given error message when encountered.\n    ///\n    /// This macro should be used when a crate uses a conditional compilation strategy to provide\n    /// better error messages for erroneous conditions. It's the compiler-level form of [`panic!`],\n    /// but emits an error during *compilation* rather than at *runtime*.\n    ///\n    /// # Examples\n    ///\n    /// Two such examples are macros and `#[cfg]` environments.\n    ///\n    /// Emit better compiler error if a macro is passed invalid values. Without the final branch,\n    /// the compiler would still emit an error, but the error's message would not mention the two\n    /// valid values.\n    ///\n    /// ```compile_fail\n    /// macro_rules! give_me_foo_or_bar {\n    ///     (foo) =\u003e {};\n    ///     (bar) =\u003e {};\n    ///     ($x:ident) =\u003e {\n    ///         compile_error!(\"This macro only accepts `foo` or `bar`\");\n    ///     }\n    /// }\n    ///\n    /// give_me_foo_or_bar!(neither);\n    /// // ^ will fail at compile time with message \"This macro only accepts `foo` or `bar`\"\n    /// ```\n    ///\n    /// Emit compiler error if one of a number of features isn't available.\n    ///\n    /// ```compile_fail\n    /// #[cfg(not(any(feature = \"foo\", feature = \"bar\")))]\n    /// compile_error!(\"Either feature \\\"foo\\\" or \\\"bar\\\" must be enabled for this crate.\");\n    /// ```\n    ///\n    /// [`panic!`]: ../std/macro.panic.html\n    #[stable(feature = \"compile_error_macro\", since = \"1.20.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! compile_error {\n        ($msg:expr) =\u003e {{ /* compiler built-in */ }};\n        ($msg:expr,) =\u003e {{ /* compiler built-in */ }};\n    }\n\n    /// Constructs parameters for the other string-formatting macros.\n    ///\n    /// This macro functions by taking a formatting string literal containing\n    /// `{}` for each additional argument passed. `format_args!` prepares the\n    /// additional parameters to ensure the output can be interpreted as a string\n    /// and canonicalizes the arguments into a single type. Any value that implements\n    /// the [`Display`] trait can be passed to `format_args!`, as can any\n    /// [`Debug`] implementation be passed to a `{:?}` within the formatting string.\n    ///\n    /// This macro produces a value of type [`fmt::Arguments`]. This value can be\n    /// passed to the macros within [`std::fmt`] for performing useful redirection.\n    /// All other formatting macros ([`format!`], [`write!`], [`println!`], etc) are\n    /// proxied through this one. `format_args!`, unlike its derived macros, avoids\n    /// heap allocations.\n    ///\n    /// You can use the [`fmt::Arguments`] value that `format_args!` returns\n    /// in `Debug` and `Display` contexts as seen below. The example also shows\n    /// that `Debug` and `Display` format to the same thing: the interpolated\n    /// format string in `format_args!`.\n    ///\n    /// ```rust\n    /// let debug = format!(\"{:?}\", format_args!(\"{} foo {:?}\", 1, 2));\n    /// let display = format!(\"{}\", format_args!(\"{} foo {:?}\", 1, 2));\n    /// assert_eq!(\"1 foo 2\", display);\n    /// assert_eq!(display, debug);\n    /// ```\n    ///\n    /// For more information, see the documentation in [`std::fmt`].\n    ///\n    /// [`Display`]: ../std/fmt/trait.Display.html\n    /// [`Debug`]: ../std/fmt/trait.Debug.html\n    /// [`fmt::Arguments`]: ../std/fmt/struct.Arguments.html\n    /// [`std::fmt`]: ../std/fmt/index.html\n    /// [`format!`]: ../std/macro.format.html\n    /// [`write!`]: ../std/macro.write.html\n    /// [`println!`]: ../std/macro.println.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// let s = fmt::format(format_args!(\"hello {}\", \"world\"));\n    /// assert_eq!(s, format!(\"hello {}\", \"world\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[allow_internal_unstable(fmt_internals)]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! format_args {\n        ($fmt:expr) =\u003e {{ /* compiler built-in */ }};\n        ($fmt:expr, $($args:tt)*) =\u003e {{ /* compiler built-in */ }};\n    }\n\n    /// Same as `format_args`, but adds a newline in the end.\n    #[unstable(\n        feature = \"format_args_nl\",\n        issue = \"none\",\n        reason = \"`format_args_nl` is only for internal \\\n                  language use and is subject to change\"\n    )]\n    #[allow_internal_unstable(fmt_internals)]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! format_args_nl {\n        ($fmt:expr) =\u003e {{ /* compiler built-in */ }};\n        ($fmt:expr, $($args:tt)*) =\u003e {{ /* compiler built-in */ }};\n    }\n\n    /// Inspects an environment variable at compile time.\n    ///\n    /// This macro will expand to the value of the named environment variable at\n    /// compile time, yielding an expression of type `\u0026'static str`.\n    ///\n    /// If the environment variable is not defined, then a compilation error\n    /// will be emitted. To not emit a compile error, use the [`option_env!`]\n    /// macro instead.\n    ///\n    /// [`option_env!`]: ../std/macro.option_env.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let path: \u0026'static str = env!(\"PATH\");\n    /// println!(\"the $PATH variable at the time of compiling was: {}\", path);\n    /// ```\n    ///\n    /// You can customize the error message by passing a string as the second\n    /// parameter:\n    ///\n    /// ```compile_fail\n    /// let doc: \u0026'static str = env!(\"documentation\", \"what's that?!\");\n    /// ```\n    ///\n    /// If the `documentation` environment variable is not defined, you'll get\n    /// the following error:\n    ///\n    /// ```text\n    /// error: what's that?!\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! env {\n        ($name:expr) =\u003e {{ /* compiler built-in */ }};\n        ($name:expr,) =\u003e {{ /* compiler built-in */ }};\n    }\n\n    /// Optionally inspects an environment variable at compile time.\n    ///\n    /// If the named environment variable is present at compile time, this will\n    /// expand into an expression of type `Option\u003c\u0026'static str\u003e` whose value is\n    /// `Some` of the value of the environment variable. If the environment\n    /// variable is not present, then this will expand to `None`. See\n    /// [`Option\u003cT\u003e`][option] for more information on this type.\n    ///\n    /// A compile time error is never emitted when using this macro regardless\n    /// of whether the environment variable is present or not.\n    ///\n    /// [option]: ../std/option/enum.Option.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let key: Option\u003c\u0026'static str\u003e = option_env!(\"SECRET_KEY\");\n    /// println!(\"the secret key might be: {:?}\", key);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! option_env {\n        ($name:expr) =\u003e {{ /* compiler built-in */ }};\n        ($name:expr,) =\u003e {{ /* compiler built-in */ }};\n    }\n\n    /// Concatenates identifiers into one identifier.\n    ///\n    /// This macro takes any number of comma-separated identifiers, and\n    /// concatenates them all into one, yielding an expression which is a new\n    /// identifier. Note that hygiene makes it such that this macro cannot\n    /// capture local variables. Also, as a general rule, macros are only\n    /// allowed in item, statement or expression position. That means while\n    /// you may use this macro for referring to existing variables, functions or\n    /// modules etc, you cannot define a new one with it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(concat_idents)]\n    ///\n    /// # fn main() {\n    /// fn foobar() -\u003e u32 { 23 }\n    ///\n    /// let f = concat_idents!(foo, bar);\n    /// println!(\"{}\", f());\n    ///\n    /// // fn concat_idents!(new, fun, name) { } // not usable in this way!\n    /// # }\n    /// ```\n    #[unstable(\n        feature = \"concat_idents\",\n        issue = \"29599\",\n        reason = \"`concat_idents` is not stable enough for use and is subject to change\"\n    )]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! concat_idents {\n        ($($e:ident),+) =\u003e {{ /* compiler built-in */ }};\n        ($($e:ident,)+) =\u003e {{ /* compiler built-in */ }};\n    }\n\n    /// Concatenates literals into a static string slice.\n    ///\n    /// This macro takes any number of comma-separated literals, yielding an\n    /// expression of type `\u0026'static str` which represents all of the literals\n    /// concatenated left-to-right.\n    ///\n    /// Integer and floating point literals are stringified in order to be\n    /// concatenated.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let s = concat!(\"test\", 10, 'b', true);\n    /// assert_eq!(s, \"test10btrue\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! concat {\n        ($($e:expr),*) =\u003e {{ /* compiler built-in */ }};\n        ($($e:expr,)*) =\u003e {{ /* compiler built-in */ }};\n    }\n\n    /// Expands to the line number on which it was invoked.\n    ///\n    /// With [`column!`] and [`file!`], these macros provide debugging information for\n    /// developers about the location within the source.\n    ///\n    /// The expanded expression has type `u32` and is 1-based, so the first line\n    /// in each file evaluates to 1, the second to 2, etc. This is consistent\n    /// with error messages by common compilers or popular editors.\n    /// The returned line is *not necessarily* the line of the `line!` invocation itself,\n    /// but rather the first macro invocation leading up to the invocation\n    /// of the `line!` macro.\n    ///\n    /// [`column!`]: macro.column.html\n    /// [`file!`]: macro.file.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let current_line = line!();\n    /// println!(\"defined on line: {}\", current_line);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! line {\n        () =\u003e {\n            /* compiler built-in */\n        };\n    }\n\n    /// Expands to the column number at which it was invoked.\n    ///\n    /// With [`line!`] and [`file!`], these macros provide debugging information for\n    /// developers about the location within the source.\n    ///\n    /// The expanded expression has type `u32` and is 1-based, so the first column\n    /// in each line evaluates to 1, the second to 2, etc. This is consistent\n    /// with error messages by common compilers or popular editors.\n    /// The returned column is *not necessarily* the line of the `column!` invocation itself,\n    /// but rather the first macro invocation leading up to the invocation\n    /// of the `column!` macro.\n    ///\n    /// [`line!`]: macro.line.html\n    /// [`file!`]: macro.file.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let current_col = column!();\n    /// println!(\"defined on column: {}\", current_col);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! column {\n        () =\u003e {\n            /* compiler built-in */\n        };\n    }\n\n    /// Expands to the file name in which it was invoked.\n    ///\n    /// With [`line!`] and [`column!`], these macros provide debugging information for\n    /// developers about the location within the source.\n    ///\n    ///\n    /// The expanded expression has type `\u0026'static str`, and the returned file\n    /// is not the invocation of the `file!` macro itself, but rather the\n    /// first macro invocation leading up to the invocation of the `file!`\n    /// macro.\n    ///\n    /// [`line!`]: macro.line.html\n    /// [`column!`]: macro.column.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let this_file = file!();\n    /// println!(\"defined in file: {}\", this_file);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! file {\n        () =\u003e {\n            /* compiler built-in */\n        };\n    }\n\n    /// Stringifies its arguments.\n    ///\n    /// This macro will yield an expression of type `\u0026'static str` which is the\n    /// stringification of all the tokens passed to the macro. No restrictions\n    /// are placed on the syntax of the macro invocation itself.\n    ///\n    /// Note that the expanded results of the input tokens may change in the\n    /// future. You should be careful if you rely on the output.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let one_plus_one = stringify!(1 + 1);\n    /// assert_eq!(one_plus_one, \"1 + 1\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! stringify {\n        ($($t:tt)*) =\u003e {\n            /* compiler built-in */\n        };\n    }\n\n    /// Includes a utf8-encoded file as a string.\n    ///\n    /// The file is located relative to the current file (similarly to how\n    /// modules are found). The provided path is interpreted in a platform-specific\n    /// way at compile time. So, for instance, an invocation with a Windows path\n    /// containing backslashes `\\` would not compile correctly on Unix.\n    ///\n    /// This macro will yield an expression of type `\u0026'static str` which is the\n    /// contents of the file.\n    ///\n    /// # Examples\n    ///\n    /// Assume there are two files in the same directory with the following\n    /// contents:\n    ///\n    /// File 'spanish.in':\n    ///\n    /// ```text\n    /// adiós\n    /// ```\n    ///\n    /// File 'main.rs':\n    ///\n    /// ```ignore (cannot-doctest-external-file-dependency)\n    /// fn main() {\n    ///     let my_str = include_str!(\"spanish.in\");\n    ///     assert_eq!(my_str, \"adiós\\n\");\n    ///     print!(\"{}\", my_str);\n    /// }\n    /// ```\n    ///\n    /// Compiling 'main.rs' and running the resulting binary will print \"adiós\".\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! include_str {\n        ($file:expr) =\u003e {{ /* compiler built-in */ }};\n        ($file:expr,) =\u003e {{ /* compiler built-in */ }};\n    }\n\n    /// Includes a file as a reference to a byte array.\n    ///\n    /// The file is located relative to the current file (similarly to how\n    /// modules are found). The provided path is interpreted in a platform-specific\n    /// way at compile time. So, for instance, an invocation with a Windows path\n    /// containing backslashes `\\` would not compile correctly on Unix.\n    ///\n    /// This macro will yield an expression of type `\u0026'static [u8; N]` which is\n    /// the contents of the file.\n    ///\n    /// # Examples\n    ///\n    /// Assume there are two files in the same directory with the following\n    /// contents:\n    ///\n    /// File 'spanish.in':\n    ///\n    /// ```text\n    /// adiós\n    /// ```\n    ///\n    /// File 'main.rs':\n    ///\n    /// ```ignore (cannot-doctest-external-file-dependency)\n    /// fn main() {\n    ///     let bytes = include_bytes!(\"spanish.in\");\n    ///     assert_eq!(bytes, b\"adi\\xc3\\xb3s\\n\");\n    ///     print!(\"{}\", String::from_utf8_lossy(bytes));\n    /// }\n    /// ```\n    ///\n    /// Compiling 'main.rs' and running the resulting binary will print \"adiós\".\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! include_bytes {\n        ($file:expr) =\u003e {{ /* compiler built-in */ }};\n        ($file:expr,) =\u003e {{ /* compiler built-in */ }};\n    }\n\n    /// Expands to a string that represents the current module path.\n    ///\n    /// The current module path can be thought of as the hierarchy of modules\n    /// leading back up to the crate root. The first component of the path\n    /// returned is the name of the crate currently being compiled.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// mod test {\n    ///     pub fn foo() {\n    ///         assert!(module_path!().ends_with(\"test\"));\n    ///     }\n    /// }\n    ///\n    /// test::foo();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! module_path {\n        () =\u003e {\n            /* compiler built-in */\n        };\n    }\n\n    /// Evaluates boolean combinations of configuration flags at compile-time.\n    ///\n    /// In addition to the `#[cfg]` attribute, this macro is provided to allow\n    /// boolean expression evaluation of configuration flags. This frequently\n    /// leads to less duplicated code.\n    ///\n    /// The syntax given to this macro is the same syntax as the [`cfg`]\n    /// attribute.\n    ///\n    /// `cfg!`, unlike `#[cfg]`, does not remove any code and only evaluates to true or false. For\n    /// example, all blocks in an if/else expression need to be valid when `cfg!` is used for\n    /// the condition, regardless of what `cfg!` is evaluating.\n    ///\n    /// [`cfg`]: ../reference/conditional-compilation.html#the-cfg-attribute\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let my_directory = if cfg!(windows) {\n    ///     \"windows-specific-directory\"\n    /// } else {\n    ///     \"unix-directory\"\n    /// };\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! cfg {\n        ($($cfg:tt)*) =\u003e {\n            /* compiler built-in */\n        };\n    }\n\n    /// Parses a file as an expression or an item according to the context.\n    ///\n    /// The file is located relative to the current file (similarly to how\n    /// modules are found). The provided path is interpreted in a platform-specific\n    /// way at compile time. So, for instance, an invocation with a Windows path\n    /// containing backslashes `\\` would not compile correctly on Unix.\n    ///\n    /// Using this macro is often a bad idea, because if the file is\n    /// parsed as an expression, it is going to be placed in the\n    /// surrounding code unhygienically. This could result in variables\n    /// or functions being different from what the file expected if\n    /// there are variables or functions that have the same name in\n    /// the current file.\n    ///\n    /// # Examples\n    ///\n    /// Assume there are two files in the same directory with the following\n    /// contents:\n    ///\n    /// File 'monkeys.in':\n    ///\n    /// ```ignore (only-for-syntax-highlight)\n    /// ['🙈', '🙊', '🙉']\n    ///     .iter()\n    ///     .cycle()\n    ///     .take(6)\n    ///     .collect::\u003cString\u003e()\n    /// ```\n    ///\n    /// File 'main.rs':\n    ///\n    /// ```ignore (cannot-doctest-external-file-dependency)\n    /// fn main() {\n    ///     let my_string = include!(\"monkeys.in\");\n    ///     assert_eq!(\"🙈🙊🙉🙈🙊🙉\", my_string);\n    ///     println!(\"{}\", my_string);\n    /// }\n    /// ```\n    ///\n    /// Compiling 'main.rs' and running the resulting binary will print\n    /// \"🙈🙊🙉🙈🙊🙉\".\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! include {\n        ($file:expr) =\u003e {{ /* compiler built-in */ }};\n        ($file:expr,) =\u003e {{ /* compiler built-in */ }};\n    }\n\n    /// Asserts that a boolean expression is `true` at runtime.\n    ///\n    /// This will invoke the [`panic!`] macro if the provided expression cannot be\n    /// evaluated to `true` at runtime.\n    ///\n    /// # Uses\n    ///\n    /// Assertions are always checked in both debug and release builds, and cannot\n    /// be disabled. See [`debug_assert!`] for assertions that are not enabled in\n    /// release builds by default.\n    ///\n    /// Unsafe code may rely on `assert!` to enforce run-time invariants that, if\n    /// violated could lead to unsafety.\n    ///\n    /// Other use-cases of `assert!` include testing and enforcing run-time\n    /// invariants in safe code (whose violation cannot result in unsafety).\n    ///\n    /// # Custom Messages\n    ///\n    /// This macro has a second form, where a custom panic message can\n    /// be provided with or without arguments for formatting. See [`std::fmt`]\n    /// for syntax for this form.\n    ///\n    /// [`panic!`]: macro.panic.html\n    /// [`debug_assert!`]: macro.debug_assert.html\n    /// [`std::fmt`]: ../std/fmt/index.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// // the panic message for these assertions is the stringified value of the\n    /// // expression given.\n    /// assert!(true);\n    ///\n    /// fn some_computation() -\u003e bool { true } // a very simple function\n    ///\n    /// assert!(some_computation());\n    ///\n    /// // assert with a custom message\n    /// let x = true;\n    /// assert!(x, \"x wasn't true!\");\n    ///\n    /// let a = 3; let b = 27;\n    /// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! assert {\n        ($cond:expr) =\u003e {{ /* compiler built-in */ }};\n        ($cond:expr,) =\u003e {{ /* compiler built-in */ }};\n        ($cond:expr, $($arg:tt)+) =\u003e {{ /* compiler built-in */ }};\n    }\n\n    /// Inline assembly.\n    ///\n    /// Read the [unstable book] for the usage.\n    ///\n    /// [unstable book]: ../unstable-book/library-features/asm.html\n    #[unstable(\n        feature = \"asm\",\n        issue = \"72016\",\n        reason = \"inline assembly is not stable enough for use and is subject to change\"\n    )]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! asm {\n        (\"assembly template\",\n            $(operands,)*\n            $(options($(option),*))?\n        ) =\u003e {\n            /* compiler built-in */\n        };\n    }\n\n    /// LLVM-style inline assembly.\n    ///\n    /// Read the [unstable book] for the usage.\n    ///\n    /// [unstable book]: ../unstable-book/library-features/llvm-asm.html\n    #[unstable(\n        feature = \"llvm_asm\",\n        issue = \"70173\",\n        reason = \"prefer using the new asm! syntax instead\"\n    )]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! llvm_asm {\n        (\"assembly template\"\n                        : $(\"output\"(operand),)*\n                        : $(\"input\"(operand),)*\n                        : $(\"clobbers\",)*\n                        : $(\"options\",)*) =\u003e {\n            /* compiler built-in */\n        };\n    }\n\n    /// Module-level inline assembly.\n    #[unstable(\n        feature = \"global_asm\",\n        issue = \"35119\",\n        reason = \"`global_asm!` is not stable enough for use and is subject to change\"\n    )]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! global_asm {\n        (\"assembly\") =\u003e {\n            /* compiler built-in */\n        };\n    }\n\n    /// Prints passed tokens into the standard output.\n    #[unstable(\n        feature = \"log_syntax\",\n        issue = \"29598\",\n        reason = \"`log_syntax!` is not stable enough for use and is subject to change\"\n    )]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! log_syntax {\n        ($($arg:tt)*) =\u003e {\n            /* compiler built-in */\n        };\n    }\n\n    /// Enables or disables tracing functionality used for debugging other macros.\n    #[unstable(\n        feature = \"trace_macros\",\n        issue = \"29598\",\n        reason = \"`trace_macros` is not stable enough for use and is subject to change\"\n    )]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! trace_macros {\n        (true) =\u003e {{ /* compiler built-in */ }};\n        (false) =\u003e {{ /* compiler built-in */ }};\n    }\n\n    /// Attribute macro applied to a function to turn it into a unit test.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[allow_internal_unstable(test, rustc_attrs)]\n    #[rustc_builtin_macro]\n    pub macro test($item:item) {\n        /* compiler built-in */\n    }\n\n    /// Attribute macro applied to a function to turn it into a benchmark test.\n    #[unstable(\n        feature = \"test\",\n        issue = \"50297\",\n        soft,\n        reason = \"`bench` is a part of custom test frameworks which are unstable\"\n    )]\n    #[allow_internal_unstable(test, rustc_attrs)]\n    #[rustc_builtin_macro]\n    pub macro bench($item:item) {\n        /* compiler built-in */\n    }\n\n    /// An implementation detail of the `#[test]` and `#[bench]` macros.\n    #[unstable(\n        feature = \"custom_test_frameworks\",\n        issue = \"50297\",\n        reason = \"custom test frameworks are an unstable feature\"\n    )]\n    #[allow_internal_unstable(test, rustc_attrs)]\n    #[rustc_builtin_macro]\n    pub macro test_case($item:item) {\n        /* compiler built-in */\n    }\n\n    /// Attribute macro applied to a static to register it as a global allocator.\n    #[stable(feature = \"global_allocator\", since = \"1.28.0\")]\n    #[allow_internal_unstable(rustc_attrs)]\n    #[rustc_builtin_macro]\n    pub macro global_allocator($item:item) {\n        /* compiler built-in */\n    }\n\n    /// Keeps the item it's applied to if the passed path is accessible, and removes it otherwise.\n    #[unstable(\n        feature = \"cfg_accessible\",\n        issue = \"64797\",\n        reason = \"`cfg_accessible` is not fully implemented\"\n    )]\n    #[rustc_builtin_macro]\n    pub macro cfg_accessible($item:item) {\n        /* compiler built-in */\n    }\n\n    /// Unstable implementation detail of the `rustc` compiler, do not use.\n    #[rustc_builtin_macro]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[allow_internal_unstable(core_intrinsics, libstd_sys_internals)]\n    pub macro RustcDecodable($item:item) {\n        /* compiler built-in */\n    }\n\n    /// Unstable implementation detail of the `rustc` compiler, do not use.\n    #[rustc_builtin_macro]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[allow_internal_unstable(core_intrinsics)]\n    pub macro RustcEncodable($item:item) {\n        /* compiler built-in */\n    }\n}\n","traces":[{"line":61,"address":[4211440],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[4211468],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[4211500],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[4211543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[4211555,4211765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[4211583,4211617,4211797],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":3,"coverable":6},{"path":["/","usr","local","rustup","toolchains","1.45.2-x86_64-unknown-linux-gnu","lib","rustlib","src","rust","src","libcore","ops","function.rs"],"content":"/// The version of the call operator that takes an immutable receiver.\n///\n/// Instances of `Fn` can be called repeatedly without mutating state.\n///\n/// *This trait (`Fn`) is not to be confused with [function pointers]\n/// (`fn`).*\n///\n/// `Fn` is implemented automatically by closures which only take immutable\n/// references to captured variables or don't capture anything at all, as well\n/// as (safe) [function pointers] (with some caveats, see their documentation\n/// for more details). Additionally, for any type `F` that implements `Fn`, `\u0026F`\n/// implements `Fn`, too.\n///\n/// Since both [`FnMut`] and [`FnOnce`] are supertraits of `Fn`, any\n/// instance of `Fn` can be used as a parameter where a [`FnMut`] or [`FnOnce`]\n/// is expected.\n///\n/// Use `Fn` as a bound when you want to accept a parameter of function-like\n/// type and need to call it repeatedly and without mutating state (e.g., when\n/// calling it concurrently). If you do not need such strict requirements, use\n/// [`FnMut`] or [`FnOnce`] as bounds.\n///\n/// See the [chapter on closures in *The Rust Programming Language*][book] for\n/// some more information on this topic.\n///\n/// Also of note is the special syntax for `Fn` traits (e.g.\n/// `Fn(usize, bool) -\u003e usize`). Those interested in the technical details of\n/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n///\n/// [book]: ../../book/ch13-01-closures.html\n/// [`FnMut`]: trait.FnMut.html\n/// [`FnOnce`]: trait.FnOnce.html\n/// [function pointers]: ../../std/primitive.fn.html\n/// [nomicon]: ../../nomicon/hrtb.html\n///\n/// # Examples\n///\n/// ## Calling a closure\n///\n/// ```\n/// let square = |x| x * x;\n/// assert_eq!(square(5), 25);\n/// ```\n///\n/// ## Using a `Fn` parameter\n///\n/// ```\n/// fn call_with_one\u003cF\u003e(func: F) -\u003e usize\n///     where F: Fn(usize) -\u003e usize {\n///     func(1)\n/// }\n///\n/// let double = |x| x * 2;\n/// assert_eq!(call_with_one(double), 2);\n/// ```\n#[lang = \"fn\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_paren_sugar]\n#[rustc_on_unimplemented(\n    on(\n        Args = \"()\",\n        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"\n    ),\n    message = \"expected a `{Fn}\u003c{Args}\u003e` closure, found `{Self}`\",\n    label = \"expected an `Fn\u003c{Args}\u003e` closure, found `{Self}`\"\n)]\n#[fundamental] // so that regex can rely that `\u0026str: !FnMut`\n#[must_use = \"closures are lazy and do nothing unless called\"]\npub trait Fn\u003cArgs\u003e: FnMut\u003cArgs\u003e {\n    /// Performs the call operation.\n    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n    extern \"rust-call\" fn call(\u0026self, args: Args) -\u003e Self::Output;\n}\n\n/// The version of the call operator that takes a mutable receiver.\n///\n/// Instances of `FnMut` can be called repeatedly and may mutate state.\n///\n/// `FnMut` is implemented automatically by closures which take mutable\n/// references to captured variables, as well as all types that implement\n/// [`Fn`], e.g., (safe) [function pointers] (since `FnMut` is a supertrait of\n/// [`Fn`]). Additionally, for any type `F` that implements `FnMut`, `\u0026mut F`\n/// implements `FnMut`, too.\n///\n/// Since [`FnOnce`] is a supertrait of `FnMut`, any instance of `FnMut` can be\n/// used where a [`FnOnce`] is expected, and since [`Fn`] is a subtrait of\n/// `FnMut`, any instance of [`Fn`] can be used where `FnMut` is expected.\n///\n/// Use `FnMut` as a bound when you want to accept a parameter of function-like\n/// type and need to call it repeatedly, while allowing it to mutate state.\n/// If you don't want the parameter to mutate state, use [`Fn`] as a\n/// bound; if you don't need to call it repeatedly, use [`FnOnce`].\n///\n/// See the [chapter on closures in *The Rust Programming Language*][book] for\n/// some more information on this topic.\n///\n/// Also of note is the special syntax for `Fn` traits (e.g.\n/// `Fn(usize, bool) -\u003e usize`). Those interested in the technical details of\n/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n///\n/// [book]: ../../book/ch13-01-closures.html\n/// [`Fn`]: trait.Fn.html\n/// [`FnOnce`]: trait.FnOnce.html\n/// [function pointers]: ../../std/primitive.fn.html\n/// [nomicon]: ../../nomicon/hrtb.html\n///\n/// # Examples\n///\n/// ## Calling a mutably capturing closure\n///\n/// ```\n/// let mut x = 5;\n/// {\n///     let mut square_x = || x *= x;\n///     square_x();\n/// }\n/// assert_eq!(x, 25);\n/// ```\n///\n/// ## Using a `FnMut` parameter\n///\n/// ```\n/// fn do_twice\u003cF\u003e(mut func: F)\n///     where F: FnMut()\n/// {\n///     func();\n///     func();\n/// }\n///\n/// let mut x: usize = 1;\n/// {\n///     let add_two_to_x = || x += 2;\n///     do_twice(add_two_to_x);\n/// }\n///\n/// assert_eq!(x, 5);\n/// ```\n#[lang = \"fn_mut\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_paren_sugar]\n#[rustc_on_unimplemented(\n    on(\n        Args = \"()\",\n        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"\n    ),\n    message = \"expected a `{FnMut}\u003c{Args}\u003e` closure, found `{Self}`\",\n    label = \"expected an `FnMut\u003c{Args}\u003e` closure, found `{Self}`\"\n)]\n#[fundamental] // so that regex can rely that `\u0026str: !FnMut`\n#[must_use = \"closures are lazy and do nothing unless called\"]\npub trait FnMut\u003cArgs\u003e: FnOnce\u003cArgs\u003e {\n    /// Performs the call operation.\n    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n    extern \"rust-call\" fn call_mut(\u0026mut self, args: Args) -\u003e Self::Output;\n}\n\n/// The version of the call operator that takes a by-value receiver.\n///\n/// Instances of `FnOnce` can be called, but might not be callable multiple\n/// times. Because of this, if the only thing known about a type is that it\n/// implements `FnOnce`, it can only be called once.\n///\n/// `FnOnce` is implemented automatically by closure that might consume captured\n/// variables, as well as all types that implement [`FnMut`], e.g., (safe)\n/// [function pointers] (since `FnOnce` is a supertrait of [`FnMut`]).\n///\n/// Since both [`Fn`] and [`FnMut`] are subtraits of `FnOnce`, any instance of\n/// [`Fn`] or [`FnMut`] can be used where a `FnOnce` is expected.\n///\n/// Use `FnOnce` as a bound when you want to accept a parameter of function-like\n/// type and only need to call it once. If you need to call the parameter\n/// repeatedly, use [`FnMut`] as a bound; if you also need it to not mutate\n/// state, use [`Fn`].\n///\n/// See the [chapter on closures in *The Rust Programming Language*][book] for\n/// some more information on this topic.\n///\n/// Also of note is the special syntax for `Fn` traits (e.g.\n/// `Fn(usize, bool) -\u003e usize`). Those interested in the technical details of\n/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n///\n/// [book]: ../../book/ch13-01-closures.html\n/// [`Fn`]: trait.Fn.html\n/// [`FnMut`]: trait.FnMut.html\n/// [function pointers]: ../../std/primitive.fn.html\n/// [nomicon]: ../../nomicon/hrtb.html\n///\n/// # Examples\n///\n/// ## Using a `FnOnce` parameter\n///\n/// ```\n/// fn consume_with_relish\u003cF\u003e(func: F)\n///     where F: FnOnce() -\u003e String\n/// {\n///     // `func` consumes its captured variables, so it cannot be run more\n///     // than once.\n///     println!(\"Consumed: {}\", func());\n///\n///     println!(\"Delicious!\");\n///\n///     // Attempting to invoke `func()` again will throw a `use of moved\n///     // value` error for `func`.\n/// }\n///\n/// let x = String::from(\"x\");\n/// let consume_and_return_x = move || x;\n/// consume_with_relish(consume_and_return_x);\n///\n/// // `consume_and_return_x` can no longer be invoked at this point\n/// ```\n#[lang = \"fn_once\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_paren_sugar]\n#[rustc_on_unimplemented(\n    on(\n        Args = \"()\",\n        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"\n    ),\n    message = \"expected a `{FnOnce}\u003c{Args}\u003e` closure, found `{Self}`\",\n    label = \"expected an `FnOnce\u003c{Args}\u003e` closure, found `{Self}`\"\n)]\n#[fundamental] // so that regex can rely that `\u0026str: !FnMut`\n#[must_use = \"closures are lazy and do nothing unless called\"]\npub trait FnOnce\u003cArgs\u003e {\n    /// The returned type after the call operator is used.\n    #[stable(feature = \"fn_once_output\", since = \"1.12.0\")]\n    type Output;\n\n    /// Performs the call operation.\n    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n    extern \"rust-call\" fn call_once(self, args: Args) -\u003e Self::Output;\n}\n\nmod impls {\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl\u003cA, F: ?Sized\u003e Fn\u003cA\u003e for \u0026F\n    where\n        F: Fn\u003cA\u003e,\n    {\n        extern \"rust-call\" fn call(\u0026self, args: A) -\u003e F::Output {\n            (**self).call(args)\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl\u003cA, F: ?Sized\u003e FnMut\u003cA\u003e for \u0026F\n    where\n        F: Fn\u003cA\u003e,\n    {\n        extern \"rust-call\" fn call_mut(\u0026mut self, args: A) -\u003e F::Output {\n            (**self).call(args)\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl\u003cA, F: ?Sized\u003e FnOnce\u003cA\u003e for \u0026F\n    where\n        F: Fn\u003cA\u003e,\n    {\n        type Output = F::Output;\n\n        extern \"rust-call\" fn call_once(self, args: A) -\u003e F::Output {\n            (*self).call(args)\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl\u003cA, F: ?Sized\u003e FnMut\u003cA\u003e for \u0026mut F\n    where\n        F: FnMut\u003cA\u003e,\n    {\n        extern \"rust-call\" fn call_mut(\u0026mut self, args: A) -\u003e F::Output {\n            (*self).call_mut(args)\n        }\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl\u003cA, F: ?Sized\u003e FnOnce\u003cA\u003e for \u0026mut F\n    where\n        F: FnMut\u003cA\u003e,\n    {\n        type Output = F::Output;\n        extern \"rust-call\" fn call_once(self, args: A) -\u003e F::Output {\n            (*self).call_mut(args)\n        }\n    }\n}\n","traces":[{"line":232,"address":[4212105,4212158,4212073,4212096,4212144,4212064],"length":1,"stats":{"Line":2},"fn_name":"call_once\u003cclosure-0,()\u003e"}],"covered":1,"coverable":1},{"path":["/","usr","local","rustup","toolchains","1.45.2-x86_64-unknown-linux-gnu","lib","rustlib","src","rust","src","libcore","ptr","mod.rs"],"content":"//! Manually manage memory through raw pointers.\n//!\n//! *[See also the pointer primitive types](../../std/primitive.pointer.html).*\n//!\n//! # Safety\n//!\n//! Many functions in this module take raw pointers as arguments and read from\n//! or write to them. For this to be safe, these pointers must be *valid*.\n//! Whether a pointer is valid depends on the operation it is used for\n//! (read or write), and the extent of the memory that is accessed (i.e.,\n//! how many bytes are read/written). Most functions use `*mut T` and `*const T`\n//! to access only a single value, in which case the documentation omits the size\n//! and implicitly assumes it to be `size_of::\u003cT\u003e()` bytes.\n//!\n//! The precise rules for validity are not determined yet. The guarantees that are\n//! provided at this point are very minimal:\n//!\n//! * A [null] pointer is *never* valid, not even for accesses of [size zero][zst].\n//! * All pointers (except for the null pointer) are valid for all operations of\n//!   [size zero][zst].\n//! * For a pointer to be valid, it is necessary, but not always sufficient, that the pointer\n//!   be *dereferenceable*: the memory range of the given size starting at the pointer must all be\n//!   within the bounds of a single allocated object. Note that in Rust,\n//!   every (stack-allocated) variable is considered a separate allocated object.\n//! * All accesses performed by functions in this module are *non-atomic* in the sense\n//!   of [atomic operations] used to synchronize between threads. This means it is\n//!   undefined behavior to perform two concurrent accesses to the same location from different\n//!   threads unless both accesses only read from memory. Notice that this explicitly\n//!   includes [`read_volatile`] and [`write_volatile`]: Volatile accesses cannot\n//!   be used for inter-thread synchronization.\n//! * The result of casting a reference to a pointer is valid for as long as the\n//!   underlying object is live and no reference (just raw pointers) is used to\n//!   access the same memory.\n//!\n//! These axioms, along with careful use of [`offset`] for pointer arithmetic,\n//! are enough to correctly implement many useful things in unsafe code. Stronger guarantees\n//! will be provided eventually, as the [aliasing] rules are being determined. For more\n//! information, see the [book] as well as the section in the reference devoted\n//! to [undefined behavior][ub].\n//!\n//! ## Alignment\n//!\n//! Valid raw pointers as defined above are not necessarily properly aligned (where\n//! \"proper\" alignment is defined by the pointee type, i.e., `*const T` must be\n//! aligned to `mem::align_of::\u003cT\u003e()`). However, most functions require their\n//! arguments to be properly aligned, and will explicitly state\n//! this requirement in their documentation. Notable exceptions to this are\n//! [`read_unaligned`] and [`write_unaligned`].\n//!\n//! When a function requires proper alignment, it does so even if the access\n//! has size 0, i.e., even if memory is not actually touched. Consider using\n//! [`NonNull::dangling`] in such cases.\n//!\n//! [aliasing]: ../../nomicon/aliasing.html\n//! [book]: ../../book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer\n//! [ub]: ../../reference/behavior-considered-undefined.html\n//! [null]: ./fn.null.html\n//! [zst]: ../../nomicon/exotic-sizes.html#zero-sized-types-zsts\n//! [atomic operations]: ../../std/sync/atomic/index.html\n//! [`copy`]: ../../std/ptr/fn.copy.html\n//! [`offset`]: ../../std/primitive.pointer.html#method.offset\n//! [`read_unaligned`]: ./fn.read_unaligned.html\n//! [`write_unaligned`]: ./fn.write_unaligned.html\n//! [`read_volatile`]: ./fn.read_volatile.html\n//! [`write_volatile`]: ./fn.write_volatile.html\n//! [`NonNull::dangling`]: ./struct.NonNull.html#method.dangling\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::cmp::Ordering;\nuse crate::fmt;\nuse crate::hash;\nuse crate::intrinsics::{self, is_aligned_and_not_null, is_nonoverlapping};\nuse crate::mem::{self, MaybeUninit};\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(inline)]\npub use crate::intrinsics::copy_nonoverlapping;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(inline)]\npub use crate::intrinsics::copy;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(inline)]\npub use crate::intrinsics::write_bytes;\n\nmod non_null;\n#[stable(feature = \"nonnull\", since = \"1.25.0\")]\npub use non_null::NonNull;\n\nmod unique;\n#[unstable(feature = \"ptr_internals\", issue = \"none\")]\npub use unique::Unique;\n\nmod const_ptr;\nmod mut_ptr;\n\n/// Executes the destructor (if any) of the pointed-to value.\n///\n/// This is semantically equivalent to calling [`ptr::read`] and discarding\n/// the result, but has the following advantages:\n///\n/// * It is *required* to use `drop_in_place` to drop unsized types like\n///   trait objects, because they can't be read out onto the stack and\n///   dropped normally.\n///\n/// * It is friendlier to the optimizer to do this over [`ptr::read`] when\n///   dropping manually allocated memory (e.g., when writing Box/Rc/Vec),\n///   as the compiler doesn't need to prove that it's sound to elide the\n///   copy.\n///\n/// * It can be used to drop [pinned] data when `T` is not `repr(packed)`\n///   (pinned data must not be moved before it is dropped).\n///\n/// Unaligned values cannot be dropped in place, they must be copied to an aligned\n/// location first using [`ptr::read_unaligned`]. For packed structs, this move is\n/// done automatically by the compiler. This means the fields of packed structs\n/// are not dropped in-place.\n///\n/// [`ptr::read`]: ../ptr/fn.read.html\n/// [`ptr::read_unaligned`]: ../ptr/fn.read_unaligned.html\n/// [pinned]: ../pin/index.html\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `to_drop` must be [valid] for both reads and writes.\n///\n/// * `to_drop` must be properly aligned.\n///\n/// * The value `to_drop` points to must be valid for dropping, which may mean it must uphold\n///   additional invariants - this is type-dependent.\n///\n/// Additionally, if `T` is not [`Copy`], using the pointed-to value after\n/// calling `drop_in_place` can cause undefined behavior. Note that `*to_drop =\n/// foo` counts as a use because it will cause the value to be dropped\n/// again. [`write`] can be used to overwrite data without causing it to be\n/// dropped.\n///\n/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n///\n/// [valid]: ../ptr/index.html#safety\n/// [`Copy`]: ../marker/trait.Copy.html\n/// [`write`]: ../ptr/fn.write.html\n///\n/// # Examples\n///\n/// Manually remove the last item from a vector:\n///\n/// ```\n/// use std::ptr;\n/// use std::rc::Rc;\n///\n/// let last = Rc::new(1);\n/// let weak = Rc::downgrade(\u0026last);\n///\n/// let mut v = vec![Rc::new(0), last];\n///\n/// unsafe {\n///     // Get a raw pointer to the last element in `v`.\n///     let ptr = \u0026mut v[1] as *mut _;\n///     // Shorten `v` to prevent the last item from being dropped. We do that first,\n///     // to prevent issues if the `drop_in_place` below panics.\n///     v.set_len(1);\n///     // Without a call `drop_in_place`, the last item would never be dropped,\n///     // and the memory it manages would be leaked.\n///     ptr::drop_in_place(ptr);\n/// }\n///\n/// assert_eq!(v, \u0026[0.into()]);\n///\n/// // Ensure that the last item was dropped.\n/// assert!(weak.upgrade().is_none());\n/// ```\n///\n/// Notice that the compiler performs this copy automatically when dropping packed structs,\n/// i.e., you do not usually have to worry about such issues unless you call `drop_in_place`\n/// manually.\n#[stable(feature = \"drop_in_place\", since = \"1.8.0\")]\n#[lang = \"drop_in_place\"]\n#[allow(unconditional_recursion)]\npub unsafe fn drop_in_place\u003cT: ?Sized\u003e(to_drop: *mut T) {\n    // Code here does not matter - this is replaced by the\n    // real drop glue by the compiler.\n    drop_in_place(to_drop)\n}\n\n/// Creates a null raw pointer.\n///\n/// # Examples\n///\n/// ```\n/// use std::ptr;\n///\n/// let p: *const i32 = ptr::null();\n/// assert!(p.is_null());\n/// ```\n#[inline(always)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_promotable]\n#[rustc_const_stable(feature = \"const_ptr_null\", since = \"1.32.0\")]\npub const fn null\u003cT\u003e() -\u003e *const T {\n    0 as *const T\n}\n\n/// Creates a null mutable raw pointer.\n///\n/// # Examples\n///\n/// ```\n/// use std::ptr;\n///\n/// let p: *mut i32 = ptr::null_mut();\n/// assert!(p.is_null());\n/// ```\n#[inline(always)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_promotable]\n#[rustc_const_stable(feature = \"const_ptr_null\", since = \"1.32.0\")]\npub const fn null_mut\u003cT\u003e() -\u003e *mut T {\n    0 as *mut T\n}\n\n#[repr(C)]\npub(crate) union Repr\u003cT\u003e {\n    pub(crate) rust: *const [T],\n    rust_mut: *mut [T],\n    pub(crate) raw: FatPtr\u003cT\u003e,\n}\n\n#[repr(C)]\npub(crate) struct FatPtr\u003cT\u003e {\n    data: *const T,\n    pub(crate) len: usize,\n}\n\n/// Forms a raw slice from a pointer and a length.\n///\n/// The `len` argument is the number of **elements**, not the number of bytes.\n///\n/// This function is safe, but actually using the return value is unsafe.\n/// See the documentation of [`from_raw_parts`] for slice safety requirements.\n///\n/// [`from_raw_parts`]: ../../std/slice/fn.from_raw_parts.html\n///\n/// # Examples\n///\n/// ```rust\n/// use std::ptr;\n///\n/// // create a slice pointer when starting out with a pointer to the first element\n/// let x = [5, 6, 7];\n/// let raw_pointer = x.as_ptr();\n/// let slice = ptr::slice_from_raw_parts(raw_pointer, 3);\n/// assert_eq!(unsafe { \u0026*slice }[2], 7);\n/// ```\n#[inline]\n#[stable(feature = \"slice_from_raw_parts\", since = \"1.42.0\")]\n#[rustc_const_unstable(feature = \"const_slice_from_raw_parts\", issue = \"67456\")]\npub const fn slice_from_raw_parts\u003cT\u003e(data: *const T, len: usize) -\u003e *const [T] {\n    // SAFETY: Accessing the value from the `Repr` union is safe since *const [T]\n    // and FatPtr have the same memory layouts. Only std can make this\n    // guarantee.\n    unsafe { Repr { raw: FatPtr { data, len } }.rust }\n}\n\n/// Performs the same functionality as [`slice_from_raw_parts`], except that a\n/// raw mutable slice is returned, as opposed to a raw immutable slice.\n///\n/// See the documentation of [`slice_from_raw_parts`] for more details.\n///\n/// This function is safe, but actually using the return value is unsafe.\n/// See the documentation of [`from_raw_parts_mut`] for slice safety requirements.\n///\n/// [`slice_from_raw_parts`]: fn.slice_from_raw_parts.html\n/// [`from_raw_parts_mut`]: ../../std/slice/fn.from_raw_parts_mut.html\n///\n/// # Examples\n///\n/// ```rust\n/// use std::ptr;\n///\n/// let x = \u0026mut [5, 6, 7];\n/// let raw_pointer = x.as_mut_ptr();\n/// let slice = ptr::slice_from_raw_parts_mut(raw_pointer, 3);\n///\n/// unsafe {\n///     (*slice)[2] = 99; // assign a value at an index in the slice\n/// };\n///\n/// assert_eq!(unsafe { \u0026*slice }[2], 99);\n/// ```\n#[inline]\n#[stable(feature = \"slice_from_raw_parts\", since = \"1.42.0\")]\n#[rustc_const_unstable(feature = \"const_slice_from_raw_parts\", issue = \"67456\")]\npub const fn slice_from_raw_parts_mut\u003cT\u003e(data: *mut T, len: usize) -\u003e *mut [T] {\n    // SAFETY: Accessing the value from the `Repr` union is safe since *mut [T]\n    // and FatPtr have the same memory layouts\n    unsafe { Repr { raw: FatPtr { data, len } }.rust_mut }\n}\n\n/// Swaps the values at two mutable locations of the same type, without\n/// deinitializing either.\n///\n/// But for the following two exceptions, this function is semantically\n/// equivalent to [`mem::swap`]:\n///\n/// * It operates on raw pointers instead of references. When references are\n///   available, [`mem::swap`] should be preferred.\n///\n/// * The two pointed-to values may overlap. If the values do overlap, then the\n///   overlapping region of memory from `x` will be used. This is demonstrated\n///   in the second example below.\n///\n/// [`mem::swap`]: ../mem/fn.swap.html\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * Both `x` and `y` must be [valid] for both reads and writes.\n///\n/// * Both `x` and `y` must be properly aligned.\n///\n/// Note that even if `T` has size `0`, the pointers must be non-NULL and properly aligned.\n///\n/// [valid]: ../ptr/index.html#safety\n///\n/// # Examples\n///\n/// Swapping two non-overlapping regions:\n///\n/// ```\n/// use std::ptr;\n///\n/// let mut array = [0, 1, 2, 3];\n///\n/// let x = array[0..].as_mut_ptr() as *mut [u32; 2]; // this is `array[0..2]`\n/// let y = array[2..].as_mut_ptr() as *mut [u32; 2]; // this is `array[2..4]`\n///\n/// unsafe {\n///     ptr::swap(x, y);\n///     assert_eq!([2, 3, 0, 1], array);\n/// }\n/// ```\n///\n/// Swapping two overlapping regions:\n///\n/// ```\n/// use std::ptr;\n///\n/// let mut array = [0, 1, 2, 3];\n///\n/// let x = array[0..].as_mut_ptr() as *mut [u32; 3]; // this is `array[0..3]`\n/// let y = array[1..].as_mut_ptr() as *mut [u32; 3]; // this is `array[1..4]`\n///\n/// unsafe {\n///     ptr::swap(x, y);\n///     // The indices `1..3` of the slice overlap between `x` and `y`.\n///     // Reasonable results would be for to them be `[2, 3]`, so that indices `0..3` are\n///     // `[1, 2, 3]` (matching `y` before the `swap`); or for them to be `[0, 1]`\n///     // so that indices `1..4` are `[0, 1, 2]` (matching `x` before the `swap`).\n///     // This implementation is defined to make the latter choice.\n///     assert_eq!([1, 0, 1, 2], array);\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn swap\u003cT\u003e(x: *mut T, y: *mut T) {\n    // Give ourselves some scratch space to work with.\n    // We do not have to worry about drops: `MaybeUninit` does nothing when dropped.\n    let mut tmp = MaybeUninit::\u003cT\u003e::uninit();\n\n    // Perform the swap\n    copy_nonoverlapping(x, tmp.as_mut_ptr(), 1);\n    copy(y, x, 1); // `x` and `y` may overlap\n    copy_nonoverlapping(tmp.as_ptr(), y, 1);\n}\n\n/// Swaps `count * size_of::\u003cT\u003e()` bytes between the two regions of memory\n/// beginning at `x` and `y`. The two regions must *not* overlap.\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * Both `x` and `y` must be [valid] for both reads and writes of `count *\n///   size_of::\u003cT\u003e()` bytes.\n///\n/// * Both `x` and `y` must be properly aligned.\n///\n/// * The region of memory beginning at `x` with a size of `count *\n///   size_of::\u003cT\u003e()` bytes must *not* overlap with the region of memory\n///   beginning at `y` with the same size.\n///\n/// Note that even if the effectively copied size (`count * size_of::\u003cT\u003e()`) is `0`,\n/// the pointers must be non-NULL and properly aligned.\n///\n/// [valid]: ../ptr/index.html#safety\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::ptr;\n///\n/// let mut x = [1, 2, 3, 4];\n/// let mut y = [7, 8, 9];\n///\n/// unsafe {\n///     ptr::swap_nonoverlapping(x.as_mut_ptr(), y.as_mut_ptr(), 2);\n/// }\n///\n/// assert_eq!(x, [7, 8, 3, 4]);\n/// assert_eq!(y, [1, 2, 9]);\n/// ```\n#[inline]\n#[stable(feature = \"swap_nonoverlapping\", since = \"1.27.0\")]\npub unsafe fn swap_nonoverlapping\u003cT\u003e(x: *mut T, y: *mut T, count: usize) {\n    debug_assert!(is_aligned_and_not_null(x), \"attempt to swap unaligned or null pointer\");\n    debug_assert!(is_aligned_and_not_null(y), \"attempt to swap unaligned or null pointer\");\n    debug_assert!(is_nonoverlapping(x, y, count), \"attempt to swap overlapping memory\");\n\n    let x = x as *mut u8;\n    let y = y as *mut u8;\n    let len = mem::size_of::\u003cT\u003e() * count;\n    swap_nonoverlapping_bytes(x, y, len)\n}\n\n#[inline]\npub(crate) unsafe fn swap_nonoverlapping_one\u003cT\u003e(x: *mut T, y: *mut T) {\n    // For types smaller than the block optimization below,\n    // just swap directly to avoid pessimizing codegen.\n    if mem::size_of::\u003cT\u003e() \u003c 32 {\n        let z = read(x);\n        copy_nonoverlapping(y, x, 1);\n        write(y, z);\n    } else {\n        swap_nonoverlapping(x, y, 1);\n    }\n}\n\n#[inline]\nunsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n    // The approach here is to utilize simd to swap x \u0026 y efficiently. Testing reveals\n    // that swapping either 32 bytes or 64 bytes at a time is most efficient for Intel\n    // Haswell E processors. LLVM is more able to optimize if we give a struct a\n    // #[repr(simd)], even if we don't actually use this struct directly.\n    //\n    // FIXME repr(simd) broken on emscripten and redox\n    #[cfg_attr(not(any(target_os = \"emscripten\", target_os = \"redox\")), repr(simd))]\n    struct Block(u64, u64, u64, u64);\n    struct UnalignedBlock(u64, u64, u64, u64);\n\n    let block_size = mem::size_of::\u003cBlock\u003e();\n\n    // Loop through x \u0026 y, copying them `Block` at a time\n    // The optimizer should unroll the loop fully for most types\n    // N.B. We can't use a for loop as the `range` impl calls `mem::swap` recursively\n    let mut i = 0;\n    while i + block_size \u003c= len {\n        // Create some uninitialized memory as scratch space\n        // Declaring `t` here avoids aligning the stack when this loop is unused\n        let mut t = mem::MaybeUninit::\u003cBlock\u003e::uninit();\n        let t = t.as_mut_ptr() as *mut u8;\n        let x = x.add(i);\n        let y = y.add(i);\n\n        // Swap a block of bytes of x \u0026 y, using t as a temporary buffer\n        // This should be optimized into efficient SIMD operations where available\n        copy_nonoverlapping(x, t, block_size);\n        copy_nonoverlapping(y, x, block_size);\n        copy_nonoverlapping(t, y, block_size);\n        i += block_size;\n    }\n\n    if i \u003c len {\n        // Swap any remaining bytes\n        let mut t = mem::MaybeUninit::\u003cUnalignedBlock\u003e::uninit();\n        let rem = len - i;\n\n        let t = t.as_mut_ptr() as *mut u8;\n        let x = x.add(i);\n        let y = y.add(i);\n\n        copy_nonoverlapping(x, t, rem);\n        copy_nonoverlapping(y, x, rem);\n        copy_nonoverlapping(t, y, rem);\n    }\n}\n\n/// Moves `src` into the pointed `dst`, returning the previous `dst` value.\n///\n/// Neither value is dropped.\n///\n/// This function is semantically equivalent to [`mem::replace`] except that it\n/// operates on raw pointers instead of references. When references are\n/// available, [`mem::replace`] should be preferred.\n///\n/// [`mem::replace`]: ../mem/fn.replace.html\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `dst` must be [valid] for both reads and writes.\n///\n/// * `dst` must be properly aligned.\n///\n/// * `dst` must point to a properly initialized value of type `T`.\n///\n/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n///\n/// [valid]: ../ptr/index.html#safety\n///\n/// # Examples\n///\n/// ```\n/// use std::ptr;\n///\n/// let mut rust = vec!['b', 'u', 's', 't'];\n///\n/// // `mem::replace` would have the same effect without requiring the unsafe\n/// // block.\n/// let b = unsafe {\n///     ptr::replace(\u0026mut rust[0], 'r')\n/// };\n///\n/// assert_eq!(b, 'b');\n/// assert_eq!(rust, \u0026['r', 'u', 's', 't']);\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn replace\u003cT\u003e(dst: *mut T, mut src: T) -\u003e T {\n    mem::swap(\u0026mut *dst, \u0026mut src); // cannot overlap\n    src\n}\n\n/// Reads the value from `src` without moving it. This leaves the\n/// memory in `src` unchanged.\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `src` must be [valid] for reads.\n///\n/// * `src` must be properly aligned. Use [`read_unaligned`] if this is not the\n///   case.\n///\n/// * `src` must point to a properly initialized value of type `T`.\n///\n/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let x = 12;\n/// let y = \u0026x as *const i32;\n///\n/// unsafe {\n///     assert_eq!(std::ptr::read(y), 12);\n/// }\n/// ```\n///\n/// Manually implement [`mem::swap`]:\n///\n/// ```\n/// use std::ptr;\n///\n/// fn swap\u003cT\u003e(a: \u0026mut T, b: \u0026mut T) {\n///     unsafe {\n///         // Create a bitwise copy of the value at `a` in `tmp`.\n///         let tmp = ptr::read(a);\n///\n///         // Exiting at this point (either by explicitly returning or by\n///         // calling a function which panics) would cause the value in `tmp` to\n///         // be dropped while the same value is still referenced by `a`. This\n///         // could trigger undefined behavior if `T` is not `Copy`.\n///\n///         // Create a bitwise copy of the value at `b` in `a`.\n///         // This is safe because mutable references cannot alias.\n///         ptr::copy_nonoverlapping(b, a, 1);\n///\n///         // As above, exiting here could trigger undefined behavior because\n///         // the same value is referenced by `a` and `b`.\n///\n///         // Move `tmp` into `b`.\n///         ptr::write(b, tmp);\n///\n///         // `tmp` has been moved (`write` takes ownership of its second argument),\n///         // so nothing is dropped implicitly here.\n///     }\n/// }\n///\n/// let mut foo = \"foo\".to_owned();\n/// let mut bar = \"bar\".to_owned();\n///\n/// swap(\u0026mut foo, \u0026mut bar);\n///\n/// assert_eq!(foo, \"bar\");\n/// assert_eq!(bar, \"foo\");\n/// ```\n///\n/// ## Ownership of the Returned Value\n///\n/// `read` creates a bitwise copy of `T`, regardless of whether `T` is [`Copy`].\n/// If `T` is not [`Copy`], using both the returned value and the value at\n/// `*src` can violate memory safety. Note that assigning to `*src` counts as a\n/// use because it will attempt to drop the value at `*src`.\n///\n/// [`write`] can be used to overwrite data without causing it to be dropped.\n///\n/// ```\n/// use std::ptr;\n///\n/// let mut s = String::from(\"foo\");\n/// unsafe {\n///     // `s2` now points to the same underlying memory as `s`.\n///     let mut s2: String = ptr::read(\u0026s);\n///\n///     assert_eq!(s2, \"foo\");\n///\n///     // Assigning to `s2` causes its original value to be dropped. Beyond\n///     // this point, `s` must no longer be used, as the underlying memory has\n///     // been freed.\n///     s2 = String::default();\n///     assert_eq!(s2, \"\");\n///\n///     // Assigning to `s` would cause the old value to be dropped again,\n///     // resulting in undefined behavior.\n///     // s = String::from(\"bar\"); // ERROR\n///\n///     // `ptr::write` can be used to overwrite a value without dropping it.\n///     ptr::write(\u0026mut s, String::from(\"bar\"));\n/// }\n///\n/// assert_eq!(s, \"bar\");\n/// ```\n///\n/// [`mem::swap`]: ../mem/fn.swap.html\n/// [valid]: ../ptr/index.html#safety\n/// [`Copy`]: ../marker/trait.Copy.html\n/// [`read_unaligned`]: ./fn.read_unaligned.html\n/// [`write`]: ./fn.write.html\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn read\u003cT\u003e(src: *const T) -\u003e T {\n    // `copy_nonoverlapping` takes care of debug_assert.\n    let mut tmp = MaybeUninit::\u003cT\u003e::uninit();\n    copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n    tmp.assume_init()\n}\n\n/// Reads the value from `src` without moving it. This leaves the\n/// memory in `src` unchanged.\n///\n/// Unlike [`read`], `read_unaligned` works with unaligned pointers.\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `src` must be [valid] for reads.\n///\n/// * `src` must point to a properly initialized value of type `T`.\n///\n/// Like [`read`], `read_unaligned` creates a bitwise copy of `T`, regardless of\n/// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the returned\n/// value and the value at `*src` can [violate memory safety][read-ownership].\n///\n/// Note that even if `T` has size `0`, the pointer must be non-NULL.\n///\n/// [`Copy`]: ../marker/trait.Copy.html\n/// [`read`]: ./fn.read.html\n/// [`write_unaligned`]: ./fn.write_unaligned.html\n/// [read-ownership]: ./fn.read.html#ownership-of-the-returned-value\n/// [valid]: ../ptr/index.html#safety\n///\n/// ## On `packed` structs\n///\n/// It is currently impossible to create raw pointers to unaligned fields\n/// of a packed struct.\n///\n/// Attempting to create a raw pointer to an `unaligned` struct field with\n/// an expression such as `\u0026packed.unaligned as *const FieldType` creates an\n/// intermediate unaligned reference before converting that to a raw pointer.\n/// That this reference is temporary and immediately cast is inconsequential\n/// as the compiler always expects references to be properly aligned.\n/// As a result, using `\u0026packed.unaligned as *const FieldType` causes immediate\n/// *undefined behavior* in your program.\n///\n/// An example of what not to do and how this relates to `read_unaligned` is:\n///\n/// ```no_run\n/// #[repr(packed, C)]\n/// struct Packed {\n///     _padding: u8,\n///     unaligned: u32,\n/// }\n///\n/// let packed = Packed {\n///     _padding: 0x00,\n///     unaligned: 0x01020304,\n/// };\n///\n/// let v = unsafe {\n///     // Here we attempt to take the address of a 32-bit integer which is not aligned.\n///     let unaligned =\n///         // A temporary unaligned reference is created here which results in\n///         // undefined behavior regardless of whether the reference is used or not.\n///         \u0026packed.unaligned\n///         // Casting to a raw pointer doesn't help; the mistake already happened.\n///         as *const u32;\n///\n///     let v = std::ptr::read_unaligned(unaligned);\n///\n///     v\n/// };\n/// ```\n///\n/// Accessing unaligned fields directly with e.g. `packed.unaligned` is safe however.\n// FIXME: Update docs based on outcome of RFC #2582 and friends.\n///\n/// # Examples\n///\n/// Read an usize value from a byte buffer:\n///\n/// ```\n/// use std::mem;\n///\n/// fn read_usize(x: \u0026[u8]) -\u003e usize {\n///     assert!(x.len() \u003e= mem::size_of::\u003cusize\u003e());\n///\n///     let ptr = x.as_ptr() as *const usize;\n///\n///     unsafe { ptr.read_unaligned() }\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\npub unsafe fn read_unaligned\u003cT\u003e(src: *const T) -\u003e T {\n    // `copy_nonoverlapping` takes care of debug_assert.\n    let mut tmp = MaybeUninit::\u003cT\u003e::uninit();\n    copy_nonoverlapping(src as *const u8, tmp.as_mut_ptr() as *mut u8, mem::size_of::\u003cT\u003e());\n    tmp.assume_init()\n}\n\n/// Overwrites a memory location with the given value without reading or\n/// dropping the old value.\n///\n/// `write` does not drop the contents of `dst`. This is safe, but it could leak\n/// allocations or resources, so care should be taken not to overwrite an object\n/// that should be dropped.\n///\n/// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n/// location pointed to by `dst`.\n///\n/// This is appropriate for initializing uninitialized memory, or overwriting\n/// memory that has previously been [`read`] from.\n///\n/// [`read`]: ./fn.read.html\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `dst` must be [valid] for writes.\n///\n/// * `dst` must be properly aligned. Use [`write_unaligned`] if this is not the\n///   case.\n///\n/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n///\n/// [valid]: ../ptr/index.html#safety\n/// [`write_unaligned`]: ./fn.write_unaligned.html\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let mut x = 0;\n/// let y = \u0026mut x as *mut i32;\n/// let z = 12;\n///\n/// unsafe {\n///     std::ptr::write(y, z);\n///     assert_eq!(std::ptr::read(y), 12);\n/// }\n/// ```\n///\n/// Manually implement [`mem::swap`]:\n///\n/// ```\n/// use std::ptr;\n///\n/// fn swap\u003cT\u003e(a: \u0026mut T, b: \u0026mut T) {\n///     unsafe {\n///         // Create a bitwise copy of the value at `a` in `tmp`.\n///         let tmp = ptr::read(a);\n///\n///         // Exiting at this point (either by explicitly returning or by\n///         // calling a function which panics) would cause the value in `tmp` to\n///         // be dropped while the same value is still referenced by `a`. This\n///         // could trigger undefined behavior if `T` is not `Copy`.\n///\n///         // Create a bitwise copy of the value at `b` in `a`.\n///         // This is safe because mutable references cannot alias.\n///         ptr::copy_nonoverlapping(b, a, 1);\n///\n///         // As above, exiting here could trigger undefined behavior because\n///         // the same value is referenced by `a` and `b`.\n///\n///         // Move `tmp` into `b`.\n///         ptr::write(b, tmp);\n///\n///         // `tmp` has been moved (`write` takes ownership of its second argument),\n///         // so nothing is dropped implicitly here.\n///     }\n/// }\n///\n/// let mut foo = \"foo\".to_owned();\n/// let mut bar = \"bar\".to_owned();\n///\n/// swap(\u0026mut foo, \u0026mut bar);\n///\n/// assert_eq!(foo, \"bar\");\n/// assert_eq!(bar, \"foo\");\n/// ```\n///\n/// [`mem::swap`]: ../mem/fn.swap.html\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn write\u003cT\u003e(dst: *mut T, src: T) {\n    debug_assert!(is_aligned_and_not_null(dst), \"attempt to write to unaligned or null pointer\");\n    intrinsics::move_val_init(\u0026mut *dst, src)\n}\n\n/// Overwrites a memory location with the given value without reading or\n/// dropping the old value.\n///\n/// Unlike [`write`], the pointer may be unaligned.\n///\n/// `write_unaligned` does not drop the contents of `dst`. This is safe, but it\n/// could leak allocations or resources, so care should be taken not to overwrite\n/// an object that should be dropped.\n///\n/// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n/// location pointed to by `dst`.\n///\n/// This is appropriate for initializing uninitialized memory, or overwriting\n/// memory that has previously been read with [`read_unaligned`].\n///\n/// [`write`]: ./fn.write.html\n/// [`read_unaligned`]: ./fn.read_unaligned.html\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `dst` must be [valid] for writes.\n///\n/// Note that even if `T` has size `0`, the pointer must be non-NULL.\n///\n/// [valid]: ../ptr/index.html#safety\n///\n/// ## On `packed` structs\n///\n/// It is currently impossible to create raw pointers to unaligned fields\n/// of a packed struct.\n///\n/// Attempting to create a raw pointer to an `unaligned` struct field with\n/// an expression such as `\u0026packed.unaligned as *const FieldType` creates an\n/// intermediate unaligned reference before converting that to a raw pointer.\n/// That this reference is temporary and immediately cast is inconsequential\n/// as the compiler always expects references to be properly aligned.\n/// As a result, using `\u0026packed.unaligned as *const FieldType` causes immediate\n/// *undefined behavior* in your program.\n///\n/// An example of what not to do and how this relates to `write_unaligned` is:\n///\n/// ```no_run\n/// #[repr(packed, C)]\n/// struct Packed {\n///     _padding: u8,\n///     unaligned: u32,\n/// }\n///\n/// let v = 0x01020304;\n/// let mut packed: Packed = unsafe { std::mem::zeroed() };\n///\n/// let v = unsafe {\n///     // Here we attempt to take the address of a 32-bit integer which is not aligned.\n///     let unaligned =\n///         // A temporary unaligned reference is created here which results in\n///         // undefined behavior regardless of whether the reference is used or not.\n///         \u0026mut packed.unaligned\n///         // Casting to a raw pointer doesn't help; the mistake already happened.\n///         as *mut u32;\n///\n///     std::ptr::write_unaligned(unaligned, v);\n///\n///     v\n/// };\n/// ```\n///\n/// Accessing unaligned fields directly with e.g. `packed.unaligned` is safe however.\n// FIXME: Update docs based on outcome of RFC #2582 and friends.\n///\n/// # Examples\n///\n/// Write an usize value to a byte buffer:\n///\n/// ```\n/// use std::mem;\n///\n/// fn write_usize(x: \u0026mut [u8], val: usize) {\n///     assert!(x.len() \u003e= mem::size_of::\u003cusize\u003e());\n///\n///     let ptr = x.as_mut_ptr() as *mut usize;\n///\n///     unsafe { ptr.write_unaligned(val) }\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\npub unsafe fn write_unaligned\u003cT\u003e(dst: *mut T, src: T) {\n    // `copy_nonoverlapping` takes care of debug_assert.\n    copy_nonoverlapping(\u0026src as *const T as *const u8, dst as *mut u8, mem::size_of::\u003cT\u003e());\n    mem::forget(src);\n}\n\n/// Performs a volatile read of the value from `src` without moving it. This\n/// leaves the memory in `src` unchanged.\n///\n/// Volatile operations are intended to act on I/O memory, and are guaranteed\n/// to not be elided or reordered by the compiler across other volatile\n/// operations.\n///\n/// [`write_volatile`]: ./fn.write_volatile.html\n///\n/// # Notes\n///\n/// Rust does not currently have a rigorously and formally defined memory model,\n/// so the precise semantics of what \"volatile\" means here is subject to change\n/// over time. That being said, the semantics will almost always end up pretty\n/// similar to [C11's definition of volatile][c11].\n///\n/// The compiler shouldn't change the relative order or number of volatile\n/// memory operations. However, volatile memory operations on zero-sized types\n/// (e.g., if a zero-sized type is passed to `read_volatile`) are noops\n/// and may be ignored.\n///\n/// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `src` must be [valid] for reads.\n///\n/// * `src` must be properly aligned.\n///\n/// * `src` must point to a properly initialized value of type `T`.\n///\n/// Like [`read`], `read_volatile` creates a bitwise copy of `T`, regardless of\n/// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the returned\n/// value and the value at `*src` can [violate memory safety][read-ownership].\n/// However, storing non-[`Copy`] types in volatile memory is almost certainly\n/// incorrect.\n///\n/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n///\n/// [valid]: ../ptr/index.html#safety\n/// [`Copy`]: ../marker/trait.Copy.html\n/// [`read`]: ./fn.read.html\n/// [read-ownership]: ./fn.read.html#ownership-of-the-returned-value\n///\n/// Just like in C, whether an operation is volatile has no bearing whatsoever\n/// on questions involving concurrent access from multiple threads. Volatile\n/// accesses behave exactly like non-atomic accesses in that regard. In particular,\n/// a race between a `read_volatile` and any write operation to the same location\n/// is undefined behavior.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let x = 12;\n/// let y = \u0026x as *const i32;\n///\n/// unsafe {\n///     assert_eq!(std::ptr::read_volatile(y), 12);\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"volatile\", since = \"1.9.0\")]\npub unsafe fn read_volatile\u003cT\u003e(src: *const T) -\u003e T {\n    debug_assert!(is_aligned_and_not_null(src), \"attempt to read from unaligned or null pointer\");\n    intrinsics::volatile_load(src)\n}\n\n/// Performs a volatile write of a memory location with the given value without\n/// reading or dropping the old value.\n///\n/// Volatile operations are intended to act on I/O memory, and are guaranteed\n/// to not be elided or reordered by the compiler across other volatile\n/// operations.\n///\n/// `write_volatile` does not drop the contents of `dst`. This is safe, but it\n/// could leak allocations or resources, so care should be taken not to overwrite\n/// an object that should be dropped.\n///\n/// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n/// location pointed to by `dst`.\n///\n/// [`read_volatile`]: ./fn.read_volatile.html\n///\n/// # Notes\n///\n/// Rust does not currently have a rigorously and formally defined memory model,\n/// so the precise semantics of what \"volatile\" means here is subject to change\n/// over time. That being said, the semantics will almost always end up pretty\n/// similar to [C11's definition of volatile][c11].\n///\n/// The compiler shouldn't change the relative order or number of volatile\n/// memory operations. However, volatile memory operations on zero-sized types\n/// (e.g., if a zero-sized type is passed to `write_volatile`) are noops\n/// and may be ignored.\n///\n/// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `dst` must be [valid] for writes.\n///\n/// * `dst` must be properly aligned.\n///\n/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n///\n/// [valid]: ../ptr/index.html#safety\n///\n/// Just like in C, whether an operation is volatile has no bearing whatsoever\n/// on questions involving concurrent access from multiple threads. Volatile\n/// accesses behave exactly like non-atomic accesses in that regard. In particular,\n/// a race between a `write_volatile` and any other operation (reading or writing)\n/// on the same location is undefined behavior.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let mut x = 0;\n/// let y = \u0026mut x as *mut i32;\n/// let z = 12;\n///\n/// unsafe {\n///     std::ptr::write_volatile(y, z);\n///     assert_eq!(std::ptr::read_volatile(y), 12);\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"volatile\", since = \"1.9.0\")]\npub unsafe fn write_volatile\u003cT\u003e(dst: *mut T, src: T) {\n    debug_assert!(is_aligned_and_not_null(dst), \"attempt to write to unaligned or null pointer\");\n    intrinsics::volatile_store(dst, src);\n}\n\n/// Align pointer `p`.\n///\n/// Calculate offset (in terms of elements of `stride` stride) that has to be applied\n/// to pointer `p` so that pointer `p` would get aligned to `a`.\n///\n/// Note: This implementation has been carefully tailored to not panic. It is UB for this to panic.\n/// The only real change that can be made here is change of `INV_TABLE_MOD_16` and associated\n/// constants.\n///\n/// If we ever decide to make it possible to call the intrinsic with `a` that is not a\n/// power-of-two, it will probably be more prudent to just change to a naive implementation rather\n/// than trying to adapt this to accommodate that change.\n///\n/// Any questions go to @nagisa.\n#[lang = \"align_offset\"]\npub(crate) unsafe fn align_offset\u003cT: Sized\u003e(p: *const T, a: usize) -\u003e usize {\n    /// Calculate multiplicative modular inverse of `x` modulo `m`.\n    ///\n    /// This implementation is tailored for align_offset and has following preconditions:\n    ///\n    /// * `m` is a power-of-two;\n    /// * `x \u003c m`; (if `x ≥ m`, pass in `x % m` instead)\n    ///\n    /// Implementation of this function shall not panic. Ever.\n    #[inline]\n    fn mod_inv(x: usize, m: usize) -\u003e usize {\n        /// Multiplicative modular inverse table modulo 2⁴ = 16.\n        ///\n        /// Note, that this table does not contain values where inverse does not exist (i.e., for\n        /// `0⁻¹ mod 16`, `2⁻¹ mod 16`, etc.)\n        const INV_TABLE_MOD_16: [u8; 8] = [1, 11, 13, 7, 9, 3, 5, 15];\n        /// Modulo for which the `INV_TABLE_MOD_16` is intended.\n        const INV_TABLE_MOD: usize = 16;\n        /// INV_TABLE_MOD²\n        const INV_TABLE_MOD_SQUARED: usize = INV_TABLE_MOD * INV_TABLE_MOD;\n\n        let table_inverse = INV_TABLE_MOD_16[(x \u0026 (INV_TABLE_MOD - 1)) \u003e\u003e 1] as usize;\n        if m \u003c= INV_TABLE_MOD {\n            table_inverse \u0026 (m - 1)\n        } else {\n            // We iterate \"up\" using the following formula:\n            //\n            // $$ xy ≡ 1 (mod 2ⁿ) → xy (2 - xy) ≡ 1 (mod 2²ⁿ) $$\n            //\n            // until 2²ⁿ ≥ m. Then we can reduce to our desired `m` by taking the result `mod m`.\n            let mut inverse = table_inverse;\n            let mut going_mod = INV_TABLE_MOD_SQUARED;\n            loop {\n                // y = y * (2 - xy) mod n\n                //\n                // Note, that we use wrapping operations here intentionally – the original formula\n                // uses e.g., subtraction `mod n`. It is entirely fine to do them `mod\n                // usize::max_value()` instead, because we take the result `mod n` at the end\n                // anyway.\n                inverse = inverse.wrapping_mul(2usize.wrapping_sub(x.wrapping_mul(inverse)));\n                if going_mod \u003e= m {\n                    return inverse \u0026 (m - 1);\n                }\n                going_mod = going_mod.wrapping_mul(going_mod);\n            }\n        }\n    }\n\n    let stride = mem::size_of::\u003cT\u003e();\n    let a_minus_one = a.wrapping_sub(1);\n    let pmoda = p as usize \u0026 a_minus_one;\n\n    if pmoda == 0 {\n        // Already aligned. Yay!\n        return 0;\n    }\n\n    if stride \u003c= 1 {\n        return if stride == 0 {\n            // If the pointer is not aligned, and the element is zero-sized, then no amount of\n            // elements will ever align the pointer.\n            !0\n        } else {\n            a.wrapping_sub(pmoda)\n        };\n    }\n\n    let smoda = stride \u0026 a_minus_one;\n    // a is power-of-two so cannot be 0. stride = 0 is handled above.\n    let gcdpow = intrinsics::cttz_nonzero(stride).min(intrinsics::cttz_nonzero(a));\n    let gcd = 1usize \u003c\u003c gcdpow;\n\n    if p as usize \u0026 (gcd.wrapping_sub(1)) == 0 {\n        // This branch solves for the following linear congruence equation:\n        //\n        // ` p + so = 0 mod a `\n        //\n        // `p` here is the pointer value, `s` - stride of `T`, `o` offset in `T`s, and `a` - the\n        // requested alignment.\n        //\n        // With `g = gcd(a, s)`, and the above asserting that `p` is also divisible by `g`, we can\n        // denote `a' = a/g`, `s' = s/g`, `p' = p/g`, then this becomes equivalent to:\n        //\n        // ` p' + s'o = 0 mod a' `\n        // ` o = (a' - (p' mod a')) * (s'^-1 mod a') `\n        //\n        // The first term is \"the relative alignment of `p` to `a`\" (divided by the `g`), the second\n        // term is \"how does incrementing `p` by `s` bytes change the relative alignment of `p`\" (again\n        // divided by `g`).\n        // Division by `g` is necessary to make the inverse well formed if `a` and `s` are not\n        // co-prime.\n        //\n        // Furthermore, the result produced by this solution is not \"minimal\", so it is necessary\n        // to take the result `o mod lcm(s, a)`. We can replace `lcm(s, a)` with just a `a'`.\n        let a2 = a \u003e\u003e gcdpow;\n        let a2minus1 = a2.wrapping_sub(1);\n        let s2 = smoda \u003e\u003e gcdpow;\n        let minusp2 = a2.wrapping_sub(pmoda \u003e\u003e gcdpow);\n        return (minusp2.wrapping_mul(mod_inv(s2, a2))) \u0026 a2minus1;\n    }\n\n    // Cannot be aligned at all.\n    usize::max_value()\n}\n\n/// Compares raw pointers for equality.\n///\n/// This is the same as using the `==` operator, but less generic:\n/// the arguments have to be `*const T` raw pointers,\n/// not anything that implements `PartialEq`.\n///\n/// This can be used to compare `\u0026T` references (which coerce to `*const T` implicitly)\n/// by their address rather than comparing the values they point to\n/// (which is what the `PartialEq for \u0026T` implementation does).\n///\n/// # Examples\n///\n/// ```\n/// use std::ptr;\n///\n/// let five = 5;\n/// let other_five = 5;\n/// let five_ref = \u0026five;\n/// let same_five_ref = \u0026five;\n/// let other_five_ref = \u0026other_five;\n///\n/// assert!(five_ref == same_five_ref);\n/// assert!(ptr::eq(five_ref, same_five_ref));\n///\n/// assert!(five_ref == other_five_ref);\n/// assert!(!ptr::eq(five_ref, other_five_ref));\n/// ```\n///\n/// Slices are also compared by their length (fat pointers):\n///\n/// ```\n/// let a = [1, 2, 3];\n/// assert!(std::ptr::eq(\u0026a[..3], \u0026a[..3]));\n/// assert!(!std::ptr::eq(\u0026a[..2], \u0026a[..3]));\n/// assert!(!std::ptr::eq(\u0026a[0..2], \u0026a[1..3]));\n/// ```\n///\n/// Traits are also compared by their implementation:\n///\n/// ```\n/// #[repr(transparent)]\n/// struct Wrapper { member: i32 }\n///\n/// trait Trait {}\n/// impl Trait for Wrapper {}\n/// impl Trait for i32 {}\n///\n/// let wrapper = Wrapper { member: 10 };\n///\n/// // Pointers have equal addresses.\n/// assert!(std::ptr::eq(\n///     \u0026wrapper as *const Wrapper as *const u8,\n///     \u0026wrapper.member as *const i32 as *const u8\n/// ));\n///\n/// // Objects have equal addresses, but `Trait` has different implementations.\n/// assert!(!std::ptr::eq(\n///     \u0026wrapper as \u0026dyn Trait,\n///     \u0026wrapper.member as \u0026dyn Trait,\n/// ));\n/// assert!(!std::ptr::eq(\n///     \u0026wrapper as \u0026dyn Trait as *const dyn Trait,\n///     \u0026wrapper.member as \u0026dyn Trait as *const dyn Trait,\n/// ));\n///\n/// // Converting the reference to a `*const u8` compares by address.\n/// assert!(std::ptr::eq(\n///     \u0026wrapper as \u0026dyn Trait as *const dyn Trait as *const u8,\n///     \u0026wrapper.member as \u0026dyn Trait as *const dyn Trait as *const u8,\n/// ));\n/// ```\n#[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n#[inline]\npub fn eq\u003cT: ?Sized\u003e(a: *const T, b: *const T) -\u003e bool {\n    a == b\n}\n\n/// Hash a raw pointer.\n///\n/// This can be used to hash a `\u0026T` reference (which coerces to `*const T` implicitly)\n/// by its address rather than the value it points to\n/// (which is what the `Hash for \u0026T` implementation does).\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::hash_map::DefaultHasher;\n/// use std::hash::{Hash, Hasher};\n/// use std::ptr;\n///\n/// let five = 5;\n/// let five_ref = \u0026five;\n///\n/// let mut hasher = DefaultHasher::new();\n/// ptr::hash(five_ref, \u0026mut hasher);\n/// let actual = hasher.finish();\n///\n/// let mut hasher = DefaultHasher::new();\n/// (five_ref as *const i32).hash(\u0026mut hasher);\n/// let expected = hasher.finish();\n///\n/// assert_eq!(actual, expected);\n/// ```\n#[stable(feature = \"ptr_hash\", since = \"1.35.0\")]\npub fn hash\u003cT: ?Sized, S: hash::Hasher\u003e(hashee: *const T, into: \u0026mut S) {\n    use crate::hash::Hash;\n    hashee.hash(into);\n}\n\n// Impls for function pointers\nmacro_rules! fnptr_impls_safety_abi {\n    ($FnTy: ty, $($Arg: ident),*) =\u003e {\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl\u003cRet, $($Arg),*\u003e PartialEq for $FnTy {\n            #[inline]\n            fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n                *self as usize == *other as usize\n            }\n        }\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl\u003cRet, $($Arg),*\u003e Eq for $FnTy {}\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl\u003cRet, $($Arg),*\u003e PartialOrd for $FnTy {\n            #[inline]\n            fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n                (*self as usize).partial_cmp(\u0026(*other as usize))\n            }\n        }\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl\u003cRet, $($Arg),*\u003e Ord for $FnTy {\n            #[inline]\n            fn cmp(\u0026self, other: \u0026Self) -\u003e Ordering {\n                (*self as usize).cmp(\u0026(*other as usize))\n            }\n        }\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl\u003cRet, $($Arg),*\u003e hash::Hash for $FnTy {\n            fn hash\u003cHH: hash::Hasher\u003e(\u0026self, state: \u0026mut HH) {\n                state.write_usize(*self as usize)\n            }\n        }\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl\u003cRet, $($Arg),*\u003e fmt::Pointer for $FnTy {\n            fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                fmt::Pointer::fmt(\u0026(*self as *const ()), f)\n            }\n        }\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl\u003cRet, $($Arg),*\u003e fmt::Debug for $FnTy {\n            fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                fmt::Pointer::fmt(\u0026(*self as *const ()), f)\n            }\n        }\n    }\n}\n\nmacro_rules! fnptr_impls_args {\n    ($($Arg: ident),+) =\u003e {\n        fnptr_impls_safety_abi! { extern \"Rust\" fn($($Arg),+) -\u003e Ret, $($Arg),+ }\n        fnptr_impls_safety_abi! { extern \"C\" fn($($Arg),+) -\u003e Ret, $($Arg),+ }\n        fnptr_impls_safety_abi! { extern \"C\" fn($($Arg),+ , ...) -\u003e Ret, $($Arg),+ }\n        fnptr_impls_safety_abi! { unsafe extern \"Rust\" fn($($Arg),+) -\u003e Ret, $($Arg),+ }\n        fnptr_impls_safety_abi! { unsafe extern \"C\" fn($($Arg),+) -\u003e Ret, $($Arg),+ }\n        fnptr_impls_safety_abi! { unsafe extern \"C\" fn($($Arg),+ , ...) -\u003e Ret, $($Arg),+ }\n    };\n    () =\u003e {\n        // No variadic functions with 0 parameters\n        fnptr_impls_safety_abi! { extern \"Rust\" fn() -\u003e Ret, }\n        fnptr_impls_safety_abi! { extern \"C\" fn() -\u003e Ret, }\n        fnptr_impls_safety_abi! { unsafe extern \"Rust\" fn() -\u003e Ret, }\n        fnptr_impls_safety_abi! { unsafe extern \"C\" fn() -\u003e Ret, }\n    };\n}\n\nfnptr_impls_args! {}\nfnptr_impls_args! { A }\nfnptr_impls_args! { A, B }\nfnptr_impls_args! { A, B, C }\nfnptr_impls_args! { A, B, C, D }\nfnptr_impls_args! { A, B, C, D, E }\nfnptr_impls_args! { A, B, C, D, E, F }\nfnptr_impls_args! { A, B, C, D, E, F, G }\nfnptr_impls_args! { A, B, C, D, E, F, G, H }\nfnptr_impls_args! { A, B, C, D, E, F, G, H, I }\nfnptr_impls_args! { A, B, C, D, E, F, G, H, I, J }\nfnptr_impls_args! { A, B, C, D, E, F, G, H, I, J, K }\nfnptr_impls_args! { A, B, C, D, E, F, G, H, I, J, K, L }\n","traces":[{"line":184,"address":[4212222,4212208,4212217],"length":1,"stats":{"Line":0},"fn_name":"drop_in_place\u003cclosure-0\u003e"}],"covered":0,"coverable":1},{"path":["/","usr","local","rustup","toolchains","1.45.2-x86_64-unknown-linux-gnu","lib","rustlib","src","rust","src","libstd","macros.rs"],"content":"//! Standard library macros\n//!\n//! This modules contains a set of macros which are exported from the standard\n//! library. Each macro is available for use when linking against the standard\n//! library.\n\n#[doc(include = \"../libcore/macros/panic.md\")]\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow_internal_unstable(libstd_sys_internals)]\nmacro_rules! panic {\n    () =\u003e ({ $crate::panic!(\"explicit panic\") });\n    ($msg:expr) =\u003e ({ $crate::rt::begin_panic($msg) });\n    ($msg:expr,) =\u003e ({ $crate::panic!($msg) });\n    ($fmt:expr, $($arg:tt)+) =\u003e ({\n        $crate::rt::begin_panic_fmt(\u0026$crate::format_args!($fmt, $($arg)+))\n    });\n}\n\n/// Prints to the standard output.\n///\n/// Equivalent to the [`println!`] macro except that a newline is not printed at\n/// the end of the message.\n///\n/// Note that stdout is frequently line-buffered by default so it may be\n/// necessary to use [`io::stdout().flush()`][flush] to ensure the output is emitted\n/// immediately.\n///\n/// Use `print!` only for the primary output of your program. Use\n/// [`eprint!`] instead to print error and progress messages.\n///\n/// [`println!`]: ../std/macro.println.html\n/// [flush]: ../std/io/trait.Write.html#tymethod.flush\n/// [`eprint!`]: ../std/macro.eprint.html\n///\n/// # Panics\n///\n/// Panics if writing to `io::stdout()` fails.\n///\n/// # Examples\n///\n/// ```\n/// use std::io::{self, Write};\n///\n/// print!(\"this \");\n/// print!(\"will \");\n/// print!(\"be \");\n/// print!(\"on \");\n/// print!(\"the \");\n/// print!(\"same \");\n/// print!(\"line \");\n///\n/// io::stdout().flush().unwrap();\n///\n/// print!(\"this string has a newline, why not choose println! instead?\\n\");\n///\n/// io::stdout().flush().unwrap();\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow_internal_unstable(print_internals)]\nmacro_rules! print {\n    ($($arg:tt)*) =\u003e ($crate::io::_print($crate::format_args!($($arg)*)));\n}\n\n/// Prints to the standard output, with a newline.\n///\n/// On all platforms, the newline is the LINE FEED character (`\\n`/`U+000A`) alone\n/// (no additional CARRIAGE RETURN (`\\r`/`U+000D`)).\n///\n/// Use the [`format!`] syntax to write data to the standard output.\n/// See [`std::fmt`] for more information.\n///\n/// Use `println!` only for the primary output of your program. Use\n/// [`eprintln!`] instead to print error and progress messages.\n///\n/// [`format!`]: ../std/macro.format.html\n/// [`std::fmt`]: ../std/fmt/index.html\n/// [`eprintln!`]: ../std/macro.eprintln.html\n/// # Panics\n///\n/// Panics if writing to `io::stdout` fails.\n///\n/// # Examples\n///\n/// ```\n/// println!(); // prints just a newline\n/// println!(\"hello there!\");\n/// println!(\"format {} arguments\", \"some\");\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow_internal_unstable(print_internals, format_args_nl)]\nmacro_rules! println {\n    () =\u003e ($crate::print!(\"\\n\"));\n    ($($arg:tt)*) =\u003e ({\n        $crate::io::_print($crate::format_args_nl!($($arg)*));\n    })\n}\n\n/// Prints to the standard error.\n///\n/// Equivalent to the [`print!`] macro, except that output goes to\n/// [`io::stderr`] instead of `io::stdout`. See [`print!`] for\n/// example usage.\n///\n/// Use `eprint!` only for error and progress messages. Use `print!`\n/// instead for the primary output of your program.\n///\n/// [`io::stderr`]: ../std/io/struct.Stderr.html\n/// [`print!`]: ../std/macro.print.html\n///\n/// # Panics\n///\n/// Panics if writing to `io::stderr` fails.\n///\n/// # Examples\n///\n/// ```\n/// eprint!(\"Error: Could not complete task\");\n/// ```\n#[macro_export]\n#[stable(feature = \"eprint\", since = \"1.19.0\")]\n#[allow_internal_unstable(print_internals)]\nmacro_rules! eprint {\n    ($($arg:tt)*) =\u003e ($crate::io::_eprint($crate::format_args!($($arg)*)));\n}\n\n/// Prints to the standard error, with a newline.\n///\n/// Equivalent to the [`println!`] macro, except that output goes to\n/// [`io::stderr`] instead of `io::stdout`. See [`println!`] for\n/// example usage.\n///\n/// Use `eprintln!` only for error and progress messages. Use `println!`\n/// instead for the primary output of your program.\n///\n/// [`io::stderr`]: ../std/io/struct.Stderr.html\n/// [`println!`]: ../std/macro.println.html\n///\n/// # Panics\n///\n/// Panics if writing to `io::stderr` fails.\n///\n/// # Examples\n///\n/// ```\n/// eprintln!(\"Error: Could not complete task\");\n/// ```\n#[macro_export]\n#[stable(feature = \"eprint\", since = \"1.19.0\")]\n#[allow_internal_unstable(print_internals, format_args_nl)]\nmacro_rules! eprintln {\n    () =\u003e ($crate::eprint!(\"\\n\"));\n    ($($arg:tt)*) =\u003e ({\n        $crate::io::_eprint($crate::format_args_nl!($($arg)*));\n    })\n}\n\n/// Prints and returns the value of a given expression for quick and dirty\n/// debugging.\n///\n/// An example:\n///\n/// ```rust\n/// let a = 2;\n/// let b = dbg!(a * 2) + 1;\n/// //      ^-- prints: [src/main.rs:2] a * 2 = 4\n/// assert_eq!(b, 5);\n/// ```\n///\n/// The macro works by using the `Debug` implementation of the type of\n/// the given expression to print the value to [stderr] along with the\n/// source location of the macro invocation as well as the source code\n/// of the expression.\n///\n/// Invoking the macro on an expression moves and takes ownership of it\n/// before returning the evaluated expression unchanged. If the type\n/// of the expression does not implement `Copy` and you don't want\n/// to give up ownership, you can instead borrow with `dbg!(\u0026expr)`\n/// for some expression `expr`.\n///\n/// The `dbg!` macro works exactly the same in release builds.\n/// This is useful when debugging issues that only occur in release\n/// builds or when debugging in release mode is significantly faster.\n///\n/// Note that the macro is intended as a debugging tool and therefore you\n/// should avoid having uses of it in version control for long periods.\n/// Use cases involving debug output that should be added to version control\n/// are better served by macros such as [`debug!`] from the [`log`] crate.\n///\n/// # Stability\n///\n/// The exact output printed by this macro should not be relied upon\n/// and is subject to future changes.\n///\n/// # Panics\n///\n/// Panics if writing to `io::stderr` fails.\n///\n/// # Further examples\n///\n/// With a method call:\n///\n/// ```rust\n/// fn foo(n: usize) {\n///     if let Some(_) = dbg!(n.checked_sub(4)) {\n///         // ...\n///     }\n/// }\n///\n/// foo(3)\n/// ```\n///\n/// This prints to [stderr]:\n///\n/// ```text,ignore\n/// [src/main.rs:4] n.checked_sub(4) = None\n/// ```\n///\n/// Naive factorial implementation:\n///\n/// ```rust\n/// fn factorial(n: u32) -\u003e u32 {\n///     if dbg!(n \u003c= 1) {\n///         dbg!(1)\n///     } else {\n///         dbg!(n * factorial(n - 1))\n///     }\n/// }\n///\n/// dbg!(factorial(4));\n/// ```\n///\n/// This prints to [stderr]:\n///\n/// ```text,ignore\n/// [src/main.rs:3] n \u003c= 1 = false\n/// [src/main.rs:3] n \u003c= 1 = false\n/// [src/main.rs:3] n \u003c= 1 = false\n/// [src/main.rs:3] n \u003c= 1 = true\n/// [src/main.rs:4] 1 = 1\n/// [src/main.rs:5] n * factorial(n - 1) = 2\n/// [src/main.rs:5] n * factorial(n - 1) = 6\n/// [src/main.rs:5] n * factorial(n - 1) = 24\n/// [src/main.rs:11] factorial(4) = 24\n/// ```\n///\n/// The `dbg!(..)` macro moves the input:\n///\n/// ```compile_fail\n/// /// A wrapper around `usize` which importantly is not Copyable.\n/// #[derive(Debug)]\n/// struct NoCopy(usize);\n///\n/// let a = NoCopy(42);\n/// let _ = dbg!(a); // \u003c-- `a` is moved here.\n/// let _ = dbg!(a); // \u003c-- `a` is moved again; error!\n/// ```\n///\n/// You can also use `dbg!()` without a value to just print the\n/// file and line whenever it's reached.\n///\n/// Finally, if you want to `dbg!(..)` multiple values, it will treat them as\n/// a tuple (and return it, too):\n///\n/// ```\n/// assert_eq!(dbg!(1usize, 2u32), (1, 2));\n/// ```\n///\n/// However, a single argument with a trailing comma will still not be treated\n/// as a tuple, following the convention of ignoring trailing commas in macro\n/// invocations. You can use a 1-tuple directly if you need one:\n///\n/// ```\n/// assert_eq!(1, dbg!(1u32,)); // trailing comma ignored\n/// assert_eq!((1,), dbg!((1u32,))); // 1-tuple\n/// ```\n///\n/// [stderr]: https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)\n/// [`debug!`]: https://docs.rs/log/*/log/macro.debug.html\n/// [`log`]: https://crates.io/crates/log\n#[macro_export]\n#[stable(feature = \"dbg_macro\", since = \"1.32.0\")]\nmacro_rules! dbg {\n    () =\u003e {\n        $crate::eprintln!(\"[{}:{}]\", $crate::file!(), $crate::line!());\n    };\n    ($val:expr) =\u003e {\n        // Use of `match` here is intentional because it affects the lifetimes\n        // of temporaries - https://stackoverflow.com/a/48732525/1063961\n        match $val {\n            tmp =\u003e {\n                $crate::eprintln!(\"[{}:{}] {} = {:#?}\",\n                    $crate::file!(), $crate::line!(), $crate::stringify!($val), \u0026tmp);\n                tmp\n            }\n        }\n    };\n    // Trailing comma with single argument is ignored\n    ($val:expr,) =\u003e { $crate::dbg!($val) };\n    ($($val:expr),+ $(,)?) =\u003e {\n        ($($crate::dbg!($val)),+,)\n    };\n}\n\n#[cfg(test)]\nmacro_rules! assert_approx_eq {\n    ($a:expr, $b:expr) =\u003e {{\n        let (a, b) = (\u0026$a, \u0026$b);\n        assert!((*a - *b).abs() \u003c 1.0e-6, \"{} is not approximately equal to {}\", *a, *b);\n    }};\n}\n","traces":[{"line":16,"address":[4211813,4211717],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":1},{"path":["/","usr","local","rustup","toolchains","1.45.2-x86_64-unknown-linux-gnu","lib","rustlib","src","rust","src","libstd","process.rs"],"content":"//! A module for working with processes.\n//!\n//! This module is mostly concerned with spawning and interacting with child\n//! processes, but it also provides [`abort`] and [`exit`] for terminating the\n//! current process.\n//!\n//! # Spawning a process\n//!\n//! The [`Command`] struct is used to configure and spawn processes:\n//!\n//! ```no_run\n//! use std::process::Command;\n//!\n//! let output = Command::new(\"echo\")\n//!                      .arg(\"Hello world\")\n//!                      .output()\n//!                      .expect(\"Failed to execute command\");\n//!\n//! assert_eq!(b\"Hello world\\n\", output.stdout.as_slice());\n//! ```\n//!\n//! Several methods on [`Command`], such as [`spawn`] or [`output`], can be used\n//! to spawn a process. In particular, [`output`] spawns the child process and\n//! waits until the process terminates, while [`spawn`] will return a [`Child`]\n//! that represents the spawned child process.\n//!\n//! # Handling I/O\n//!\n//! The [`stdout`], [`stdin`], and [`stderr`] of a child process can be\n//! configured by passing an [`Stdio`] to the corresponding method on\n//! [`Command`]. Once spawned, they can be accessed from the [`Child`]. For\n//! example, piping output from one command into another command can be done\n//! like so:\n//!\n//! ```no_run\n//! use std::process::{Command, Stdio};\n//!\n//! // stdout must be configured with `Stdio::piped` in order to use\n//! // `echo_child.stdout`\n//! let echo_child = Command::new(\"echo\")\n//!     .arg(\"Oh no, a tpyo!\")\n//!     .stdout(Stdio::piped())\n//!     .spawn()\n//!     .expect(\"Failed to start echo process\");\n//!\n//! // Note that `echo_child` is moved here, but we won't be needing\n//! // `echo_child` anymore\n//! let echo_out = echo_child.stdout.expect(\"Failed to open echo stdout\");\n//!\n//! let mut sed_child = Command::new(\"sed\")\n//!     .arg(\"s/tpyo/typo/\")\n//!     .stdin(Stdio::from(echo_out))\n//!     .stdout(Stdio::piped())\n//!     .spawn()\n//!     .expect(\"Failed to start sed process\");\n//!\n//! let output = sed_child.wait_with_output().expect(\"Failed to wait on sed\");\n//! assert_eq!(b\"Oh no, a typo!\\n\", output.stdout.as_slice());\n//! ```\n//!\n//! Note that [`ChildStderr`] and [`ChildStdout`] implement [`Read`] and\n//! [`ChildStdin`] implements [`Write`]:\n//!\n//! ```no_run\n//! use std::process::{Command, Stdio};\n//! use std::io::Write;\n//!\n//! let mut child = Command::new(\"/bin/cat\")\n//!     .stdin(Stdio::piped())\n//!     .stdout(Stdio::piped())\n//!     .spawn()\n//!     .expect(\"failed to execute child\");\n//!\n//! {\n//!     // limited borrow of stdin\n//!     let stdin = child.stdin.as_mut().expect(\"failed to get stdin\");\n//!     stdin.write_all(b\"test\").expect(\"failed to write to stdin\");\n//! }\n//!\n//! let output = child\n//!     .wait_with_output()\n//!     .expect(\"failed to wait on child\");\n//!\n//! assert_eq!(b\"test\", output.stdout.as_slice());\n//! ```\n//!\n//! [`abort`]: fn.abort.html\n//! [`exit`]: fn.exit.html\n//!\n//! [`Command`]: struct.Command.html\n//! [`spawn`]: struct.Command.html#method.spawn\n//! [`output`]: struct.Command.html#method.output\n//!\n//! [`Child`]: struct.Child.html\n//! [`ChildStdin`]: struct.ChildStdin.html\n//! [`ChildStdout`]: struct.ChildStdout.html\n//! [`ChildStderr`]: struct.ChildStderr.html\n//! [`Stdio`]: struct.Stdio.html\n//!\n//! [`stdout`]: struct.Command.html#method.stdout\n//! [`stdin`]: struct.Command.html#method.stdin\n//! [`stderr`]: struct.Command.html#method.stderr\n//!\n//! [`Write`]: ../io/trait.Write.html\n//! [`Read`]: ../io/trait.Read.html\n\n#![stable(feature = \"process\", since = \"1.0.0\")]\n\nuse crate::io::prelude::*;\n\nuse crate::ffi::OsStr;\nuse crate::fmt;\nuse crate::fs;\nuse crate::io::{self, Initializer, IoSlice, IoSliceMut};\nuse crate::path::Path;\nuse crate::str;\nuse crate::sys::pipe::{read2, AnonPipe};\nuse crate::sys::process as imp;\nuse crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n\n/// Representation of a running or exited child process.\n///\n/// This structure is used to represent and manage child processes. A child\n/// process is created via the [`Command`] struct, which configures the\n/// spawning process and can itself be constructed using a builder-style\n/// interface.\n///\n/// There is no implementation of [`Drop`] for child processes,\n/// so if you do not ensure the `Child` has exited then it will continue to\n/// run, even after the `Child` handle to the child process has gone out of\n/// scope.\n///\n/// Calling [`wait`](#method.wait) (or other functions that wrap around it) will make\n/// the parent process wait until the child has actually exited before\n/// continuing.\n///\n/// # Warning\n///\n/// On some system, calling [`wait`] or similar is necessary for the OS to\n/// release resources. A process that terminated but has not been waited on is\n/// still around as a \"zombie\". Leaving too many zombies around may exhaust\n/// global resources (for example process IDs).\n///\n/// The standard library does *not* automatically wait on child processes (not\n/// even if the `Child` is dropped), it is up to the application developer to do\n/// so. As a consequence, dropping `Child` handles without waiting on them first\n/// is not recommended in long-running applications.\n///\n/// # Examples\n///\n/// ```should_panic\n/// use std::process::Command;\n///\n/// let mut child = Command::new(\"/bin/cat\")\n///                         .arg(\"file.txt\")\n///                         .spawn()\n///                         .expect(\"failed to execute child\");\n///\n/// let ecode = child.wait()\n///                  .expect(\"failed to wait on child\");\n///\n/// assert!(ecode.success());\n/// ```\n///\n/// [`Command`]: struct.Command.html\n/// [`Drop`]: ../../core/ops/trait.Drop.html\n/// [`wait`]: #method.wait\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct Child {\n    handle: imp::Process,\n\n    /// The handle for writing to the child's standard input (stdin), if it has\n    /// been captured.\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub stdin: Option\u003cChildStdin\u003e,\n\n    /// The handle for reading from the child's standard output (stdout), if it\n    /// has been captured.\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub stdout: Option\u003cChildStdout\u003e,\n\n    /// The handle for reading from the child's standard error (stderr), if it\n    /// has been captured.\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub stderr: Option\u003cChildStderr\u003e,\n}\n\nimpl AsInner\u003cimp::Process\u003e for Child {\n    fn as_inner(\u0026self) -\u003e \u0026imp::Process {\n        \u0026self.handle\n    }\n}\n\nimpl FromInner\u003c(imp::Process, imp::StdioPipes)\u003e for Child {\n    fn from_inner((handle, io): (imp::Process, imp::StdioPipes)) -\u003e Child {\n        Child {\n            handle,\n            stdin: io.stdin.map(ChildStdin::from_inner),\n            stdout: io.stdout.map(ChildStdout::from_inner),\n            stderr: io.stderr.map(ChildStderr::from_inner),\n        }\n    }\n}\n\nimpl IntoInner\u003cimp::Process\u003e for Child {\n    fn into_inner(self) -\u003e imp::Process {\n        self.handle\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Child {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.debug_struct(\"Child\")\n            .field(\"stdin\", \u0026self.stdin)\n            .field(\"stdout\", \u0026self.stdout)\n            .field(\"stderr\", \u0026self.stderr)\n            .finish()\n    }\n}\n\n/// A handle to a child process's standard input (stdin).\n///\n/// This struct is used in the [`stdin`] field on [`Child`].\n///\n/// When an instance of `ChildStdin` is [dropped], the `ChildStdin`'s underlying\n/// file handle will be closed. If the child process was blocked on input prior\n/// to being dropped, it will become unblocked after dropping.\n///\n/// [`Child`]: struct.Child.html\n/// [`stdin`]: struct.Child.html#structfield.stdin\n/// [dropped]: ../ops/trait.Drop.html\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct ChildStdin {\n    inner: AnonPipe,\n}\n\n#[stable(feature = \"process\", since = \"1.0.0\")]\nimpl Write for ChildStdin {\n    fn write(\u0026mut self, buf: \u0026[u8]) -\u003e io::Result\u003cusize\u003e {\n        self.inner.write(buf)\n    }\n\n    fn write_vectored(\u0026mut self, bufs: \u0026[IoSlice\u003c'_\u003e]) -\u003e io::Result\u003cusize\u003e {\n        self.inner.write_vectored(bufs)\n    }\n\n    fn is_write_vectored(\u0026self) -\u003e bool {\n        self.inner.is_write_vectored()\n    }\n\n    fn flush(\u0026mut self) -\u003e io::Result\u003c()\u003e {\n        Ok(())\n    }\n}\n\nimpl AsInner\u003cAnonPipe\u003e for ChildStdin {\n    fn as_inner(\u0026self) -\u003e \u0026AnonPipe {\n        \u0026self.inner\n    }\n}\n\nimpl IntoInner\u003cAnonPipe\u003e for ChildStdin {\n    fn into_inner(self) -\u003e AnonPipe {\n        self.inner\n    }\n}\n\nimpl FromInner\u003cAnonPipe\u003e for ChildStdin {\n    fn from_inner(pipe: AnonPipe) -\u003e ChildStdin {\n        ChildStdin { inner: pipe }\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for ChildStdin {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.pad(\"ChildStdin { .. }\")\n    }\n}\n\n/// A handle to a child process's standard output (stdout).\n///\n/// This struct is used in the [`stdout`] field on [`Child`].\n///\n/// When an instance of `ChildStdout` is [dropped], the `ChildStdout`'s\n/// underlying file handle will be closed.\n///\n/// [`Child`]: struct.Child.html\n/// [`stdout`]: struct.Child.html#structfield.stdout\n/// [dropped]: ../ops/trait.Drop.html\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct ChildStdout {\n    inner: AnonPipe,\n}\n\n#[stable(feature = \"process\", since = \"1.0.0\")]\nimpl Read for ChildStdout {\n    fn read(\u0026mut self, buf: \u0026mut [u8]) -\u003e io::Result\u003cusize\u003e {\n        self.inner.read(buf)\n    }\n\n    fn read_vectored(\u0026mut self, bufs: \u0026mut [IoSliceMut\u003c'_\u003e]) -\u003e io::Result\u003cusize\u003e {\n        self.inner.read_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_read_vectored(\u0026self) -\u003e bool {\n        self.inner.is_read_vectored()\n    }\n\n    #[inline]\n    unsafe fn initializer(\u0026self) -\u003e Initializer {\n        Initializer::nop()\n    }\n}\n\nimpl AsInner\u003cAnonPipe\u003e for ChildStdout {\n    fn as_inner(\u0026self) -\u003e \u0026AnonPipe {\n        \u0026self.inner\n    }\n}\n\nimpl IntoInner\u003cAnonPipe\u003e for ChildStdout {\n    fn into_inner(self) -\u003e AnonPipe {\n        self.inner\n    }\n}\n\nimpl FromInner\u003cAnonPipe\u003e for ChildStdout {\n    fn from_inner(pipe: AnonPipe) -\u003e ChildStdout {\n        ChildStdout { inner: pipe }\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for ChildStdout {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.pad(\"ChildStdout { .. }\")\n    }\n}\n\n/// A handle to a child process's stderr.\n///\n/// This struct is used in the [`stderr`] field on [`Child`].\n///\n/// When an instance of `ChildStderr` is [dropped], the `ChildStderr`'s\n/// underlying file handle will be closed.\n///\n/// [`Child`]: struct.Child.html\n/// [`stderr`]: struct.Child.html#structfield.stderr\n/// [dropped]: ../ops/trait.Drop.html\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct ChildStderr {\n    inner: AnonPipe,\n}\n\n#[stable(feature = \"process\", since = \"1.0.0\")]\nimpl Read for ChildStderr {\n    fn read(\u0026mut self, buf: \u0026mut [u8]) -\u003e io::Result\u003cusize\u003e {\n        self.inner.read(buf)\n    }\n\n    fn read_vectored(\u0026mut self, bufs: \u0026mut [IoSliceMut\u003c'_\u003e]) -\u003e io::Result\u003cusize\u003e {\n        self.inner.read_vectored(bufs)\n    }\n\n    #[inline]\n    fn is_read_vectored(\u0026self) -\u003e bool {\n        self.inner.is_read_vectored()\n    }\n\n    #[inline]\n    unsafe fn initializer(\u0026self) -\u003e Initializer {\n        Initializer::nop()\n    }\n}\n\nimpl AsInner\u003cAnonPipe\u003e for ChildStderr {\n    fn as_inner(\u0026self) -\u003e \u0026AnonPipe {\n        \u0026self.inner\n    }\n}\n\nimpl IntoInner\u003cAnonPipe\u003e for ChildStderr {\n    fn into_inner(self) -\u003e AnonPipe {\n        self.inner\n    }\n}\n\nimpl FromInner\u003cAnonPipe\u003e for ChildStderr {\n    fn from_inner(pipe: AnonPipe) -\u003e ChildStderr {\n        ChildStderr { inner: pipe }\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for ChildStderr {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.pad(\"ChildStderr { .. }\")\n    }\n}\n\n/// A process builder, providing fine-grained control\n/// over how a new process should be spawned.\n///\n/// A default configuration can be\n/// generated using `Command::new(program)`, where `program` gives a path to the\n/// program to be executed. Additional builder methods allow the configuration\n/// to be changed (for example, by adding arguments) prior to spawning:\n///\n/// ```\n/// use std::process::Command;\n///\n/// let output = if cfg!(target_os = \"windows\") {\n///     Command::new(\"cmd\")\n///             .args(\u0026[\"/C\", \"echo hello\"])\n///             .output()\n///             .expect(\"failed to execute process\")\n/// } else {\n///     Command::new(\"sh\")\n///             .arg(\"-c\")\n///             .arg(\"echo hello\")\n///             .output()\n///             .expect(\"failed to execute process\")\n/// };\n///\n/// let hello = output.stdout;\n/// ```\n///\n/// `Command` can be reused to spawn multiple processes. The builder methods\n/// change the command without needing to immediately spawn the process.\n///\n/// ```no_run\n/// use std::process::Command;\n///\n/// let mut echo_hello = Command::new(\"sh\");\n/// echo_hello.arg(\"-c\")\n///           .arg(\"echo hello\");\n/// let hello_1 = echo_hello.output().expect(\"failed to execute process\");\n/// let hello_2 = echo_hello.output().expect(\"failed to execute process\");\n/// ```\n///\n/// Similarly, you can call builder methods after spawning a process and then\n/// spawn a new process with the modified settings.\n///\n/// ```no_run\n/// use std::process::Command;\n///\n/// let mut list_dir = Command::new(\"ls\");\n///\n/// // Execute `ls` in the current directory of the program.\n/// list_dir.status().expect(\"process failed to execute\");\n///\n/// println!();\n///\n/// // Change `ls` to execute in the root directory.\n/// list_dir.current_dir(\"/\");\n///\n/// // And then execute `ls` again but in the root directory.\n/// list_dir.status().expect(\"process failed to execute\");\n/// ```\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct Command {\n    inner: imp::Command,\n}\n\nimpl Command {\n    /// Constructs a new `Command` for launching the program at\n    /// path `program`, with the following default configuration:\n    ///\n    /// * No arguments to the program\n    /// * Inherit the current process's environment\n    /// * Inherit the current process's working directory\n    /// * Inherit stdin/stdout/stderr for `spawn` or `status`, but create pipes for `output`\n    ///\n    /// Builder methods are provided to change these defaults and\n    /// otherwise configure the process.\n    ///\n    /// If `program` is not an absolute path, the `PATH` will be searched in\n    /// an OS-defined way.\n    ///\n    /// The search path to be used may be controlled by setting the\n    /// `PATH` environment variable on the Command,\n    /// but this has some implementation limitations on Windows\n    /// (see issue #37519).\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"sh\")\n    ///         .spawn()\n    ///         .expect(\"sh command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn new\u003cS: AsRef\u003cOsStr\u003e\u003e(program: S) -\u003e Command {\n        Command { inner: imp::Command::new(program.as_ref()) }\n    }\n\n    /// Adds an argument to pass to the program.\n    ///\n    /// Only one argument can be passed per use. So instead of:\n    ///\n    /// ```no_run\n    /// # std::process::Command::new(\"sh\")\n    /// .arg(\"-C /path/to/repo\")\n    /// # ;\n    /// ```\n    ///\n    /// usage would be:\n    ///\n    /// ```no_run\n    /// # std::process::Command::new(\"sh\")\n    /// .arg(\"-C\")\n    /// .arg(\"/path/to/repo\")\n    /// # ;\n    /// ```\n    ///\n    /// To pass multiple arguments see [`args`].\n    ///\n    /// [`args`]: #method.args\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"ls\")\n    ///         .arg(\"-l\")\n    ///         .arg(\"-a\")\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn arg\u003cS: AsRef\u003cOsStr\u003e\u003e(\u0026mut self, arg: S) -\u003e \u0026mut Command {\n        self.inner.arg(arg.as_ref());\n        self\n    }\n\n    /// Adds multiple arguments to pass to the program.\n    ///\n    /// To pass a single argument see [`arg`].\n    ///\n    /// [`arg`]: #method.arg\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"ls\")\n    ///         .args(\u0026[\"-l\", \"-a\"])\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn args\u003cI, S\u003e(\u0026mut self, args: I) -\u003e \u0026mut Command\n    where\n        I: IntoIterator\u003cItem = S\u003e,\n        S: AsRef\u003cOsStr\u003e,\n    {\n        for arg in args {\n            self.arg(arg.as_ref());\n        }\n        self\n    }\n\n    /// Inserts or updates an environment variable mapping.\n    ///\n    /// Note that environment variable names are case-insensitive (but case-preserving) on Windows,\n    /// and case-sensitive on all other platforms.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"ls\")\n    ///         .env(\"PATH\", \"/bin\")\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn env\u003cK, V\u003e(\u0026mut self, key: K, val: V) -\u003e \u0026mut Command\n    where\n        K: AsRef\u003cOsStr\u003e,\n        V: AsRef\u003cOsStr\u003e,\n    {\n        self.inner.env_mut().set(key.as_ref(), val.as_ref());\n        self\n    }\n\n    /// Adds or updates multiple environment variable mappings.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    /// use std::env;\n    /// use std::collections::HashMap;\n    ///\n    /// let filtered_env : HashMap\u003cString, String\u003e =\n    ///     env::vars().filter(|\u0026(ref k, _)|\n    ///         k == \"TERM\" || k == \"TZ\" || k == \"LANG\" || k == \"PATH\"\n    ///     ).collect();\n    ///\n    /// Command::new(\"printenv\")\n    ///         .stdin(Stdio::null())\n    ///         .stdout(Stdio::inherit())\n    ///         .env_clear()\n    ///         .envs(\u0026filtered_env)\n    ///         .spawn()\n    ///         .expect(\"printenv failed to start\");\n    /// ```\n    #[stable(feature = \"command_envs\", since = \"1.19.0\")]\n    pub fn envs\u003cI, K, V\u003e(\u0026mut self, vars: I) -\u003e \u0026mut Command\n    where\n        I: IntoIterator\u003cItem = (K, V)\u003e,\n        K: AsRef\u003cOsStr\u003e,\n        V: AsRef\u003cOsStr\u003e,\n    {\n        for (ref key, ref val) in vars {\n            self.inner.env_mut().set(key.as_ref(), val.as_ref());\n        }\n        self\n    }\n\n    /// Removes an environment variable mapping.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"ls\")\n    ///         .env_remove(\"PATH\")\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn env_remove\u003cK: AsRef\u003cOsStr\u003e\u003e(\u0026mut self, key: K) -\u003e \u0026mut Command {\n        self.inner.env_mut().remove(key.as_ref());\n        self\n    }\n\n    /// Clears the entire environment map for the child process.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"ls\")\n    ///         .env_clear()\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn env_clear(\u0026mut self) -\u003e \u0026mut Command {\n        self.inner.env_mut().clear();\n        self\n    }\n\n    /// Sets the working directory for the child process.\n    ///\n    /// # Platform-specific behavior\n    ///\n    /// If the program path is relative (e.g., `\"./script.sh\"`), it's ambiguous\n    /// whether it should be interpreted relative to the parent's working\n    /// directory or relative to `current_dir`. The behavior in this case is\n    /// platform specific and unstable, and it's recommended to use\n    /// [`canonicalize`] to get an absolute program path instead.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"ls\")\n    ///         .current_dir(\"/bin\")\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    ///\n    /// [`canonicalize`]: ../fs/fn.canonicalize.html\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn current_dir\u003cP: AsRef\u003cPath\u003e\u003e(\u0026mut self, dir: P) -\u003e \u0026mut Command {\n        self.inner.cwd(dir.as_ref().as_ref());\n        self\n    }\n\n    /// Configuration for the child process's standard input (stdin) handle.\n    ///\n    /// Defaults to [`inherit`] when used with `spawn` or `status`, and\n    /// defaults to [`piped`] when used with `output`.\n    ///\n    /// [`inherit`]: struct.Stdio.html#method.inherit\n    /// [`piped`]: struct.Stdio.html#method.piped\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// Command::new(\"ls\")\n    ///         .stdin(Stdio::null())\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn stdin\u003cT: Into\u003cStdio\u003e\u003e(\u0026mut self, cfg: T) -\u003e \u0026mut Command {\n        self.inner.stdin(cfg.into().0);\n        self\n    }\n\n    /// Configuration for the child process's standard output (stdout) handle.\n    ///\n    /// Defaults to [`inherit`] when used with `spawn` or `status`, and\n    /// defaults to [`piped`] when used with `output`.\n    ///\n    /// [`inherit`]: struct.Stdio.html#method.inherit\n    /// [`piped`]: struct.Stdio.html#method.piped\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// Command::new(\"ls\")\n    ///         .stdout(Stdio::null())\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn stdout\u003cT: Into\u003cStdio\u003e\u003e(\u0026mut self, cfg: T) -\u003e \u0026mut Command {\n        self.inner.stdout(cfg.into().0);\n        self\n    }\n\n    /// Configuration for the child process's standard error (stderr) handle.\n    ///\n    /// Defaults to [`inherit`] when used with `spawn` or `status`, and\n    /// defaults to [`piped`] when used with `output`.\n    ///\n    /// [`inherit`]: struct.Stdio.html#method.inherit\n    /// [`piped`]: struct.Stdio.html#method.piped\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// Command::new(\"ls\")\n    ///         .stderr(Stdio::null())\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn stderr\u003cT: Into\u003cStdio\u003e\u003e(\u0026mut self, cfg: T) -\u003e \u0026mut Command {\n        self.inner.stderr(cfg.into().0);\n        self\n    }\n\n    /// Executes the command as a child process, returning a handle to it.\n    ///\n    /// By default, stdin, stdout and stderr are inherited from the parent.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"ls\")\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn spawn(\u0026mut self) -\u003e io::Result\u003cChild\u003e {\n        self.inner.spawn(imp::Stdio::Inherit, true).map(Child::from_inner)\n    }\n\n    /// Executes the command as a child process, waiting for it to finish and\n    /// collecting all of its output.\n    ///\n    /// By default, stdout and stderr are captured (and used to provide the\n    /// resulting output). Stdin is not inherited from the parent and any\n    /// attempt by the child process to read from the stdin stream will result\n    /// in the stream immediately closing.\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::process::Command;\n    /// use std::io::{self, Write};\n    /// let output = Command::new(\"/bin/cat\")\n    ///                      .arg(\"file.txt\")\n    ///                      .output()\n    ///                      .expect(\"failed to execute process\");\n    ///\n    /// println!(\"status: {}\", output.status);\n    /// io::stdout().write_all(\u0026output.stdout).unwrap();\n    /// io::stderr().write_all(\u0026output.stderr).unwrap();\n    ///\n    /// assert!(output.status.success());\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn output(\u0026mut self) -\u003e io::Result\u003cOutput\u003e {\n        self.inner\n            .spawn(imp::Stdio::MakePipe, false)\n            .map(Child::from_inner)\n            .and_then(|p| p.wait_with_output())\n    }\n\n    /// Executes a command as a child process, waiting for it to finish and\n    /// collecting its exit status.\n    ///\n    /// By default, stdin, stdout and stderr are inherited from the parent.\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::process::Command;\n    ///\n    /// let status = Command::new(\"/bin/cat\")\n    ///                      .arg(\"file.txt\")\n    ///                      .status()\n    ///                      .expect(\"failed to execute process\");\n    ///\n    /// println!(\"process exited with: {}\", status);\n    ///\n    /// assert!(status.success());\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn status(\u0026mut self) -\u003e io::Result\u003cExitStatus\u003e {\n        self.inner\n            .spawn(imp::Stdio::Inherit, true)\n            .map(Child::from_inner)\n            .and_then(|mut p| p.wait())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for Command {\n    /// Format the program and arguments of a Command for display. Any\n    /// non-utf8 data is lossily converted using the utf8 replacement\n    /// character.\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        self.inner.fmt(f)\n    }\n}\n\nimpl AsInner\u003cimp::Command\u003e for Command {\n    fn as_inner(\u0026self) -\u003e \u0026imp::Command {\n        \u0026self.inner\n    }\n}\n\nimpl AsInnerMut\u003cimp::Command\u003e for Command {\n    fn as_inner_mut(\u0026mut self) -\u003e \u0026mut imp::Command {\n        \u0026mut self.inner\n    }\n}\n\n/// The output of a finished process.\n///\n/// This is returned in a Result by either the [`output`] method of a\n/// [`Command`], or the [`wait_with_output`] method of a [`Child`]\n/// process.\n///\n/// [`Command`]: struct.Command.html\n/// [`Child`]: struct.Child.html\n/// [`output`]: struct.Command.html#method.output\n/// [`wait_with_output`]: struct.Child.html#method.wait_with_output\n#[derive(PartialEq, Eq, Clone)]\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct Output {\n    /// The status (exit code) of the process.\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub status: ExitStatus,\n    /// The data that the process wrote to stdout.\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub stdout: Vec\u003cu8\u003e,\n    /// The data that the process wrote to stderr.\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub stderr: Vec\u003cu8\u003e,\n}\n\n// If either stderr or stdout are valid utf8 strings it prints the valid\n// strings, otherwise it prints the byte sequence instead\n#[stable(feature = \"process_output_debug\", since = \"1.7.0\")]\nimpl fmt::Debug for Output {\n    fn fmt(\u0026self, fmt: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        let stdout_utf8 = str::from_utf8(\u0026self.stdout);\n        let stdout_debug: \u0026dyn fmt::Debug = match stdout_utf8 {\n            Ok(ref str) =\u003e str,\n            Err(_) =\u003e \u0026self.stdout,\n        };\n\n        let stderr_utf8 = str::from_utf8(\u0026self.stderr);\n        let stderr_debug: \u0026dyn fmt::Debug = match stderr_utf8 {\n            Ok(ref str) =\u003e str,\n            Err(_) =\u003e \u0026self.stderr,\n        };\n\n        fmt.debug_struct(\"Output\")\n            .field(\"status\", \u0026self.status)\n            .field(\"stdout\", stdout_debug)\n            .field(\"stderr\", stderr_debug)\n            .finish()\n    }\n}\n\n/// Describes what to do with a standard I/O stream for a child process when\n/// passed to the [`stdin`], [`stdout`], and [`stderr`] methods of [`Command`].\n///\n/// [`stdin`]: struct.Command.html#method.stdin\n/// [`stdout`]: struct.Command.html#method.stdout\n/// [`stderr`]: struct.Command.html#method.stderr\n/// [`Command`]: struct.Command.html\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct Stdio(imp::Stdio);\n\nimpl Stdio {\n    /// A new pipe should be arranged to connect the parent and child processes.\n    ///\n    /// # Examples\n    ///\n    /// With stdout:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let output = Command::new(\"echo\")\n    ///     .arg(\"Hello, world!\")\n    ///     .stdout(Stdio::piped())\n    ///     .output()\n    ///     .expect(\"Failed to execute command\");\n    ///\n    /// assert_eq!(String::from_utf8_lossy(\u0026output.stdout), \"Hello, world!\\n\");\n    /// // Nothing echoed to console\n    /// ```\n    ///\n    /// With stdin:\n    ///\n    /// ```no_run\n    /// use std::io::Write;\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let mut child = Command::new(\"rev\")\n    ///     .stdin(Stdio::piped())\n    ///     .stdout(Stdio::piped())\n    ///     .spawn()\n    ///     .expect(\"Failed to spawn child process\");\n    ///\n    /// {\n    ///     let stdin = child.stdin.as_mut().expect(\"Failed to open stdin\");\n    ///     stdin.write_all(\"Hello, world!\".as_bytes()).expect(\"Failed to write to stdin\");\n    /// }\n    ///\n    /// let output = child.wait_with_output().expect(\"Failed to read stdout\");\n    /// assert_eq!(String::from_utf8_lossy(\u0026output.stdout), \"!dlrow ,olleH\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn piped() -\u003e Stdio {\n        Stdio(imp::Stdio::MakePipe)\n    }\n\n    /// The child inherits from the corresponding parent descriptor.\n    ///\n    /// # Examples\n    ///\n    /// With stdout:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let output = Command::new(\"echo\")\n    ///     .arg(\"Hello, world!\")\n    ///     .stdout(Stdio::inherit())\n    ///     .output()\n    ///     .expect(\"Failed to execute command\");\n    ///\n    /// assert_eq!(String::from_utf8_lossy(\u0026output.stdout), \"\");\n    /// // \"Hello, world!\" echoed to console\n    /// ```\n    ///\n    /// With stdin:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    /// use std::io::{self, Write};\n    ///\n    /// let output = Command::new(\"rev\")\n    ///     .stdin(Stdio::inherit())\n    ///     .stdout(Stdio::piped())\n    ///     .output()\n    ///     .expect(\"Failed to execute command\");\n    ///\n    /// print!(\"You piped in the reverse of: \");\n    /// io::stdout().write_all(\u0026output.stdout).unwrap();\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn inherit() -\u003e Stdio {\n        Stdio(imp::Stdio::Inherit)\n    }\n\n    /// This stream will be ignored. This is the equivalent of attaching the\n    /// stream to `/dev/null`\n    ///\n    /// # Examples\n    ///\n    /// With stdout:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let output = Command::new(\"echo\")\n    ///     .arg(\"Hello, world!\")\n    ///     .stdout(Stdio::null())\n    ///     .output()\n    ///     .expect(\"Failed to execute command\");\n    ///\n    /// assert_eq!(String::from_utf8_lossy(\u0026output.stdout), \"\");\n    /// // Nothing echoed to console\n    /// ```\n    ///\n    /// With stdin:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let output = Command::new(\"rev\")\n    ///     .stdin(Stdio::null())\n    ///     .stdout(Stdio::piped())\n    ///     .output()\n    ///     .expect(\"Failed to execute command\");\n    ///\n    /// assert_eq!(String::from_utf8_lossy(\u0026output.stdout), \"\");\n    /// // Ignores any piped-in input\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn null() -\u003e Stdio {\n        Stdio(imp::Stdio::Null)\n    }\n}\n\nimpl FromInner\u003cimp::Stdio\u003e for Stdio {\n    fn from_inner(inner: imp::Stdio) -\u003e Stdio {\n        Stdio(inner)\n    }\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Stdio {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.pad(\"Stdio { .. }\")\n    }\n}\n\n#[stable(feature = \"stdio_from\", since = \"1.20.0\")]\nimpl From\u003cChildStdin\u003e for Stdio {\n    /// Converts a `ChildStdin` into a `Stdio`\n    ///\n    /// # Examples\n    ///\n    /// `ChildStdin` will be converted to `Stdio` using `Stdio::from` under the hood.\n    ///\n    /// ```rust,no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let reverse = Command::new(\"rev\")\n    ///     .stdin(Stdio::piped())\n    ///     .spawn()\n    ///     .expect(\"failed reverse command\");\n    ///\n    /// let _echo = Command::new(\"echo\")\n    ///     .arg(\"Hello, world!\")\n    ///     .stdout(reverse.stdin.unwrap()) // Converted into a Stdio here\n    ///     .output()\n    ///     .expect(\"failed echo command\");\n    ///\n    /// // \"!dlrow ,olleH\" echoed to console\n    /// ```\n    fn from(child: ChildStdin) -\u003e Stdio {\n        Stdio::from_inner(child.into_inner().into())\n    }\n}\n\n#[stable(feature = \"stdio_from\", since = \"1.20.0\")]\nimpl From\u003cChildStdout\u003e for Stdio {\n    /// Converts a `ChildStdout` into a `Stdio`\n    ///\n    /// # Examples\n    ///\n    /// `ChildStdout` will be converted to `Stdio` using `Stdio::from` under the hood.\n    ///\n    /// ```rust,no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let hello = Command::new(\"echo\")\n    ///     .arg(\"Hello, world!\")\n    ///     .stdout(Stdio::piped())\n    ///     .spawn()\n    ///     .expect(\"failed echo command\");\n    ///\n    /// let reverse = Command::new(\"rev\")\n    ///     .stdin(hello.stdout.unwrap())  // Converted into a Stdio here\n    ///     .output()\n    ///     .expect(\"failed reverse command\");\n    ///\n    /// assert_eq!(reverse.stdout, b\"!dlrow ,olleH\\n\");\n    /// ```\n    fn from(child: ChildStdout) -\u003e Stdio {\n        Stdio::from_inner(child.into_inner().into())\n    }\n}\n\n#[stable(feature = \"stdio_from\", since = \"1.20.0\")]\nimpl From\u003cChildStderr\u003e for Stdio {\n    /// Converts a `ChildStderr` into a `Stdio`\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let reverse = Command::new(\"rev\")\n    ///     .arg(\"non_existing_file.txt\")\n    ///     .stderr(Stdio::piped())\n    ///     .spawn()\n    ///     .expect(\"failed reverse command\");\n    ///\n    /// let cat = Command::new(\"cat\")\n    ///     .arg(\"-\")\n    ///     .stdin(reverse.stderr.unwrap()) // Converted into a Stdio here\n    ///     .output()\n    ///     .expect(\"failed echo command\");\n    ///\n    /// assert_eq!(\n    ///     String::from_utf8_lossy(\u0026cat.stdout),\n    ///     \"rev: cannot open non_existing_file.txt: No such file or directory\\n\"\n    /// );\n    /// ```\n    fn from(child: ChildStderr) -\u003e Stdio {\n        Stdio::from_inner(child.into_inner().into())\n    }\n}\n\n#[stable(feature = \"stdio_from\", since = \"1.20.0\")]\nimpl From\u003cfs::File\u003e for Stdio {\n    /// Converts a `File` into a `Stdio`\n    ///\n    /// # Examples\n    ///\n    /// `File` will be converted to `Stdio` using `Stdio::from` under the hood.\n    ///\n    /// ```rust,no_run\n    /// use std::fs::File;\n    /// use std::process::Command;\n    ///\n    /// // With the `foo.txt` file containing `Hello, world!\"\n    /// let file = File::open(\"foo.txt\").unwrap();\n    ///\n    /// let reverse = Command::new(\"rev\")\n    ///     .stdin(file)  // Implicit File conversion into a Stdio\n    ///     .output()\n    ///     .expect(\"failed reverse command\");\n    ///\n    /// assert_eq!(reverse.stdout, b\"!dlrow ,olleH\");\n    /// ```\n    fn from(file: fs::File) -\u003e Stdio {\n        Stdio::from_inner(file.into_inner().into())\n    }\n}\n\n/// Describes the result of a process after it has terminated.\n///\n/// This `struct` is used to represent the exit status of a child process.\n/// Child processes are created via the [`Command`] struct and their exit\n/// status is exposed through the [`status`] method, or the [`wait`] method\n/// of a [`Child`] process.\n///\n/// [`Command`]: struct.Command.html\n/// [`Child`]: struct.Child.html\n/// [`status`]: struct.Command.html#method.status\n/// [`wait`]: struct.Child.html#method.wait\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct ExitStatus(imp::ExitStatus);\n\nimpl ExitStatus {\n    /// Was termination successful? Signal termination is not considered a\n    /// success, and success is defined as a zero exit status.\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// use std::process::Command;\n    ///\n    /// let status = Command::new(\"mkdir\")\n    ///                      .arg(\"projects\")\n    ///                      .status()\n    ///                      .expect(\"failed to execute mkdir\");\n    ///\n    /// if status.success() {\n    ///     println!(\"'projects/' directory created\");\n    /// } else {\n    ///     println!(\"failed to create 'projects/' directory\");\n    /// }\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn success(\u0026self) -\u003e bool {\n        self.0.success()\n    }\n\n    /// Returns the exit code of the process, if any.\n    ///\n    /// On Unix, this will return `None` if the process was terminated\n    /// by a signal; `std::os::unix` provides an extension trait for\n    /// extracting the signal and other details from the `ExitStatus`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// let status = Command::new(\"mkdir\")\n    ///                      .arg(\"projects\")\n    ///                      .status()\n    ///                      .expect(\"failed to execute mkdir\");\n    ///\n    /// match status.code() {\n    ///     Some(code) =\u003e println!(\"Exited with status code: {}\", code),\n    ///     None       =\u003e println!(\"Process terminated by signal\")\n    /// }\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn code(\u0026self) -\u003e Option\u003ci32\u003e {\n        self.0.code()\n    }\n}\n\nimpl AsInner\u003cimp::ExitStatus\u003e for ExitStatus {\n    fn as_inner(\u0026self) -\u003e \u0026imp::ExitStatus {\n        \u0026self.0\n    }\n}\n\nimpl FromInner\u003cimp::ExitStatus\u003e for ExitStatus {\n    fn from_inner(s: imp::ExitStatus) -\u003e ExitStatus {\n        ExitStatus(s)\n    }\n}\n\n#[stable(feature = \"process\", since = \"1.0.0\")]\nimpl fmt::Display for ExitStatus {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        self.0.fmt(f)\n    }\n}\n\n/// This type represents the status code a process can return to its\n/// parent under normal termination.\n///\n/// Numeric values used in this type don't have portable meanings, and\n/// different platforms may mask different amounts of them.\n///\n/// For the platform's canonical successful and unsuccessful codes, see\n/// the [`SUCCESS`] and [`FAILURE`] associated items.\n///\n/// [`SUCCESS`]: #associatedconstant.SUCCESS\n/// [`FAILURE`]: #associatedconstant.FAILURE\n///\n/// **Warning**: While various forms of this were discussed in [RFC #1937],\n/// it was ultimately cut from that RFC, and thus this type is more subject\n/// to change even than the usual unstable item churn.\n///\n/// [RFC #1937]: https://github.com/rust-lang/rfcs/pull/1937\n#[derive(Clone, Copy, Debug)]\n#[unstable(feature = \"process_exitcode_placeholder\", issue = \"48711\")]\npub struct ExitCode(imp::ExitCode);\n\n#[unstable(feature = \"process_exitcode_placeholder\", issue = \"48711\")]\nimpl ExitCode {\n    /// The canonical ExitCode for successful termination on this platform.\n    ///\n    /// Note that a `()`-returning `main` implicitly results in a successful\n    /// termination, so there's no need to return this from `main` unless\n    /// you're also returning other possible codes.\n    #[unstable(feature = \"process_exitcode_placeholder\", issue = \"48711\")]\n    pub const SUCCESS: ExitCode = ExitCode(imp::ExitCode::SUCCESS);\n\n    /// The canonical ExitCode for unsuccessful termination on this platform.\n    ///\n    /// If you're only returning this and `SUCCESS` from `main`, consider\n    /// instead returning `Err(_)` and `Ok(())` respectively, which will\n    /// return the same codes (but will also `eprintln!` the error).\n    #[unstable(feature = \"process_exitcode_placeholder\", issue = \"48711\")]\n    pub const FAILURE: ExitCode = ExitCode(imp::ExitCode::FAILURE);\n}\n\nimpl Child {\n    /// Forces the child process to exit. If the child has already exited, an [`InvalidInput`]\n    /// error is returned.\n    ///\n    /// The mapping to [`ErrorKind`]s is not part of the compatibility contract of the function,\n    /// especially the [`Other`] kind might change to more specific kinds in the future.\n    ///\n    /// This is equivalent to sending a SIGKILL on Unix platforms.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// let mut command = Command::new(\"yes\");\n    /// if let Ok(mut child) = command.spawn() {\n    ///     child.kill().expect(\"command wasn't running\");\n    /// } else {\n    ///     println!(\"yes command didn't start\");\n    /// }\n    /// ```\n    ///\n    /// [`ErrorKind`]: ../io/enum.ErrorKind.html\n    /// [`InvalidInput`]: ../io/enum.ErrorKind.html#variant.InvalidInput\n    /// [`Other`]: ../io/enum.ErrorKind.html#variant.Other\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn kill(\u0026mut self) -\u003e io::Result\u003c()\u003e {\n        self.handle.kill()\n    }\n\n    /// Returns the OS-assigned process identifier associated with this child.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// let mut command = Command::new(\"ls\");\n    /// if let Ok(child) = command.spawn() {\n    ///     println!(\"Child's ID is {}\", child.id());\n    /// } else {\n    ///     println!(\"ls command didn't start\");\n    /// }\n    /// ```\n    #[stable(feature = \"process_id\", since = \"1.3.0\")]\n    pub fn id(\u0026self) -\u003e u32 {\n        self.handle.id()\n    }\n\n    /// Waits for the child to exit completely, returning the status that it\n    /// exited with. This function will continue to have the same return value\n    /// after it has been called at least once.\n    ///\n    /// The stdin handle to the child process, if any, will be closed\n    /// before waiting. This helps avoid deadlock: it ensures that the\n    /// child does not block waiting for input from the parent, while\n    /// the parent waits for the child to exit.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// let mut command = Command::new(\"ls\");\n    /// if let Ok(mut child) = command.spawn() {\n    ///     child.wait().expect(\"command wasn't running\");\n    ///     println!(\"Child has finished its execution!\");\n    /// } else {\n    ///     println!(\"ls command didn't start\");\n    /// }\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn wait(\u0026mut self) -\u003e io::Result\u003cExitStatus\u003e {\n        drop(self.stdin.take());\n        self.handle.wait().map(ExitStatus)\n    }\n\n    /// Attempts to collect the exit status of the child if it has already\n    /// exited.\n    ///\n    /// This function will not block the calling thread and will only\n    /// check to see if the child process has exited or not. If the child has\n    /// exited then on Unix the process ID is reaped. This function is\n    /// guaranteed to repeatedly return a successful exit status so long as the\n    /// child has already exited.\n    ///\n    /// If the child has exited, then `Ok(Some(status))` is returned. If the\n    /// exit status is not available at this time then `Ok(None)` is returned.\n    /// If an error occurs, then that error is returned.\n    ///\n    /// Note that unlike `wait`, this function will not attempt to drop stdin.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// let mut child = Command::new(\"ls\").spawn().unwrap();\n    ///\n    /// match child.try_wait() {\n    ///     Ok(Some(status)) =\u003e println!(\"exited with: {}\", status),\n    ///     Ok(None) =\u003e {\n    ///         println!(\"status not ready yet, let's really wait\");\n    ///         let res = child.wait();\n    ///         println!(\"result: {:?}\", res);\n    ///     }\n    ///     Err(e) =\u003e println!(\"error attempting to wait: {}\", e),\n    /// }\n    /// ```\n    #[stable(feature = \"process_try_wait\", since = \"1.18.0\")]\n    pub fn try_wait(\u0026mut self) -\u003e io::Result\u003cOption\u003cExitStatus\u003e\u003e {\n        Ok(self.handle.try_wait()?.map(ExitStatus))\n    }\n\n    /// Simultaneously waits for the child to exit and collect all remaining\n    /// output on the stdout/stderr handles, returning an `Output`\n    /// instance.\n    ///\n    /// The stdin handle to the child process, if any, will be closed\n    /// before waiting. This helps avoid deadlock: it ensures that the\n    /// child does not block waiting for input from the parent, while\n    /// the parent waits for the child to exit.\n    ///\n    /// By default, stdin, stdout and stderr are inherited from the parent.\n    /// In order to capture the output into this `Result\u003cOutput\u003e` it is\n    /// necessary to create new pipes between parent and child. Use\n    /// `stdout(Stdio::piped())` or `stderr(Stdio::piped())`, respectively.\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let child = Command::new(\"/bin/cat\")\n    ///     .arg(\"file.txt\")\n    ///     .stdout(Stdio::piped())\n    ///     .spawn()\n    ///     .expect(\"failed to execute child\");\n    ///\n    /// let output = child\n    ///     .wait_with_output()\n    ///     .expect(\"failed to wait on child\");\n    ///\n    /// assert!(output.status.success());\n    /// ```\n    ///\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn wait_with_output(mut self) -\u003e io::Result\u003cOutput\u003e {\n        drop(self.stdin.take());\n\n        let (mut stdout, mut stderr) = (Vec::new(), Vec::new());\n        match (self.stdout.take(), self.stderr.take()) {\n            (None, None) =\u003e {}\n            (Some(mut out), None) =\u003e {\n                let res = out.read_to_end(\u0026mut stdout);\n                res.unwrap();\n            }\n            (None, Some(mut err)) =\u003e {\n                let res = err.read_to_end(\u0026mut stderr);\n                res.unwrap();\n            }\n            (Some(out), Some(err)) =\u003e {\n                let res = read2(out.inner, \u0026mut stdout, err.inner, \u0026mut stderr);\n                res.unwrap();\n            }\n        }\n\n        let status = self.wait()?;\n        Ok(Output { status, stdout, stderr })\n    }\n}\n\n/// Terminates the current process with the specified exit code.\n///\n/// This function will never return and will immediately terminate the current\n/// process. The exit code is passed through to the underlying OS and will be\n/// available for consumption by another process.\n///\n/// Note that because this function never returns, and that it terminates the\n/// process, no destructors on the current stack or any other thread's stack\n/// will be run. If a clean shutdown is needed it is recommended to only call\n/// this function at a known point where there are no more destructors left\n/// to run.\n///\n/// ## Platform-specific behavior\n///\n/// **Unix**: On Unix-like platforms, it is unlikely that all 32 bits of `exit`\n/// will be visible to a parent process inspecting the exit code. On most\n/// Unix-like platforms, only the eight least-significant bits are considered.\n///\n/// # Examples\n///\n/// Due to this function’s behavior regarding destructors, a conventional way\n/// to use the function is to extract the actual computation to another\n/// function and compute the exit code from its return value:\n///\n/// ```\n/// fn run_app() -\u003e Result\u003c(), ()\u003e {\n///     // Application logic here\n///     Ok(())\n/// }\n///\n/// fn main() {\n///     std::process::exit(match run_app() {\n///         Ok(_) =\u003e 0,\n///         Err(err) =\u003e {\n///             eprintln!(\"error: {:?}\", err);\n///             1\n///         }\n///     });\n/// }\n/// ```\n///\n/// Due to [platform-specific behavior], the exit code for this example will be\n/// `0` on Linux, but `256` on Windows:\n///\n/// ```no_run\n/// use std::process;\n///\n/// process::exit(0x0100);\n/// ```\n///\n/// [platform-specific behavior]: #platform-specific-behavior\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn exit(code: i32) -\u003e ! {\n    crate::sys_common::cleanup();\n    crate::sys::os::exit(code)\n}\n\n/// Terminates the process in an abnormal fashion.\n///\n/// The function will never return and will immediately terminate the current\n/// process in a platform specific \"abnormal\" manner.\n///\n/// Note that because this function never returns, and that it terminates the\n/// process, no destructors on the current stack or any other thread's stack\n/// will be run.\n///\n/// This is in contrast to the default behaviour of [`panic!`] which unwinds\n/// the current thread's stack and calls all destructors.\n/// When `panic=\"abort\"` is set, either as an argument to `rustc` or in a\n/// crate's Cargo.toml, [`panic!`] and `abort` are similar. However,\n/// [`panic!`] will still call the [panic hook] while `abort` will not.\n///\n/// If a clean shutdown is needed it is recommended to only call\n/// this function at a known point where there are no more destructors left\n/// to run.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::process;\n///\n/// fn main() {\n///     println!(\"aborting\");\n///\n///     process::abort();\n///\n///     // execution never gets here\n/// }\n/// ```\n///\n/// The `abort` function terminates the process, so the destructor will not\n/// get run on the example below:\n///\n/// ```no_run\n/// use std::process;\n///\n/// struct HasDrop;\n///\n/// impl Drop for HasDrop {\n///     fn drop(\u0026mut self) {\n///         println!(\"This will never be printed!\");\n///     }\n/// }\n///\n/// fn main() {\n///     let _x = HasDrop;\n///     process::abort();\n///     // the destructor implemented for HasDrop will never get run\n/// }\n/// ```\n///\n/// [`panic!`]: ../../std/macro.panic.html\n/// [panic hook]: ../../std/panic/fn.set_hook.html\n#[stable(feature = \"process_abort\", since = \"1.17.0\")]\npub fn abort() -\u003e ! {\n    crate::sys::abort_internal();\n}\n\n/// Returns the OS-assigned process identifier associated with this process.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```no_run\n/// use std::process;\n///\n/// println!(\"My pid is {}\", process::id());\n/// ```\n///\n///\n#[stable(feature = \"getpid\", since = \"1.26.0\")]\npub fn id() -\u003e u32 {\n    crate::sys::os::getpid()\n}\n\n/// A trait for implementing arbitrary return types in the `main` function.\n///\n/// The C-main function only supports to return integers as return type.\n/// So, every type implementing the `Termination` trait has to be converted\n/// to an integer.\n///\n/// The default implementations are returning `libc::EXIT_SUCCESS` to indicate\n/// a successful execution. In case of a failure, `libc::EXIT_FAILURE` is returned.\n#[cfg_attr(not(test), lang = \"termination\")]\n#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\n#[rustc_on_unimplemented(\n    message = \"`main` has invalid return type `{Self}`\",\n    label = \"`main` can only return types that implement `{Termination}`\"\n)]\npub trait Termination {\n    /// Is called to get the representation of the value as status code.\n    /// This status code is returned to the operating system.\n    fn report(self) -\u003e i32;\n}\n\n#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\nimpl Termination for () {\n    #[inline]\n    fn report(self) -\u003e i32 {\n        ExitCode::SUCCESS.report()\n    }\n}\n\n#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\nimpl\u003cE: fmt::Debug\u003e Termination for Result\u003c(), E\u003e {\n    fn report(self) -\u003e i32 {\n        match self {\n            Ok(()) =\u003e ().report(),\n            Err(err) =\u003e Err::\u003c!, _\u003e(err).report(),\n        }\n    }\n}\n\n#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\nimpl Termination for ! {\n    fn report(self) -\u003e i32 {\n        self\n    }\n}\n\n#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\nimpl\u003cE: fmt::Debug\u003e Termination for Result\u003c!, E\u003e {\n    fn report(self) -\u003e i32 {\n        let Err(err) = self;\n        eprintln!(\"Error: {:?}\", err);\n        ExitCode::FAILURE.report()\n    }\n}\n\n#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\nimpl Termination for ExitCode {\n    #[inline]\n    fn report(self) -\u003e i32 {\n        self.0.as_i32()\n    }\n}\n\n#[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\", target_env = \"sgx\"))))]\nmod tests {\n    use crate::io::prelude::*;\n\n    use super::{Command, Output, Stdio};\n    use crate::io::ErrorKind;\n    use crate::str;\n\n    // FIXME(#10380) these tests should not all be ignored on android.\n\n    #[test]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn smoke() {\n        let p = if cfg!(target_os = \"windows\") {\n            Command::new(\"cmd\").args(\u0026[\"/C\", \"exit 0\"]).spawn()\n        } else {\n            Command::new(\"true\").spawn()\n        };\n        assert!(p.is_ok());\n        let mut p = p.unwrap();\n        assert!(p.wait().unwrap().success());\n    }\n\n    #[test]\n    #[cfg_attr(target_os = \"android\", ignore)]\n    fn smoke_failure() {\n        match Command::new(\"if-this-is-a-binary-then-the-world-has-ended\").spawn() {\n            Ok(..) =\u003e panic!(),\n            Err(..) =\u003e {}\n        }\n    }\n\n    #[test]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn exit_reported_right() {\n        let p = if cfg!(target_os = \"windows\") {\n            Command::new(\"cmd\").args(\u0026[\"/C\", \"exit 1\"]).spawn()\n        } else {\n            Command::new(\"false\").spawn()\n        };\n        assert!(p.is_ok());\n        let mut p = p.unwrap();\n        assert!(p.wait().unwrap().code() == Some(1));\n        drop(p.wait());\n    }\n\n    #[test]\n    #[cfg(unix)]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn signal_reported_right() {\n        use crate::os::unix::process::ExitStatusExt;\n\n        let mut p =\n            Command::new(\"/bin/sh\").arg(\"-c\").arg(\"read a\").stdin(Stdio::piped()).spawn().unwrap();\n        p.kill().unwrap();\n        match p.wait().unwrap().signal() {\n            Some(9) =\u003e {}\n            result =\u003e panic!(\"not terminated by signal 9 (instead, {:?})\", result),\n        }\n    }\n\n    pub fn run_output(mut cmd: Command) -\u003e String {\n        let p = cmd.spawn();\n        assert!(p.is_ok());\n        let mut p = p.unwrap();\n        assert!(p.stdout.is_some());\n        let mut ret = String::new();\n        p.stdout.as_mut().unwrap().read_to_string(\u0026mut ret).unwrap();\n        assert!(p.wait().unwrap().success());\n        return ret;\n    }\n\n    #[test]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn stdout_works() {\n        if cfg!(target_os = \"windows\") {\n            let mut cmd = Command::new(\"cmd\");\n            cmd.args(\u0026[\"/C\", \"echo foobar\"]).stdout(Stdio::piped());\n            assert_eq!(run_output(cmd), \"foobar\\r\\n\");\n        } else {\n            let mut cmd = Command::new(\"echo\");\n            cmd.arg(\"foobar\").stdout(Stdio::piped());\n            assert_eq!(run_output(cmd), \"foobar\\n\");\n        }\n    }\n\n    #[test]\n    #[cfg_attr(any(windows, target_os = \"android\", target_os = \"vxworks\"), ignore)]\n    fn set_current_dir_works() {\n        let mut cmd = Command::new(\"/bin/sh\");\n        cmd.arg(\"-c\").arg(\"pwd\").current_dir(\"/\").stdout(Stdio::piped());\n        assert_eq!(run_output(cmd), \"/\\n\");\n    }\n\n    #[test]\n    #[cfg_attr(any(windows, target_os = \"android\", target_os = \"vxworks\"), ignore)]\n    fn stdin_works() {\n        let mut p = Command::new(\"/bin/sh\")\n            .arg(\"-c\")\n            .arg(\"read line; echo $line\")\n            .stdin(Stdio::piped())\n            .stdout(Stdio::piped())\n            .spawn()\n            .unwrap();\n        p.stdin.as_mut().unwrap().write(\"foobar\".as_bytes()).unwrap();\n        drop(p.stdin.take());\n        let mut out = String::new();\n        p.stdout.as_mut().unwrap().read_to_string(\u0026mut out).unwrap();\n        assert!(p.wait().unwrap().success());\n        assert_eq!(out, \"foobar\\n\");\n    }\n\n    #[test]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn test_process_status() {\n        let mut status = if cfg!(target_os = \"windows\") {\n            Command::new(\"cmd\").args(\u0026[\"/C\", \"exit 1\"]).status().unwrap()\n        } else {\n            Command::new(\"false\").status().unwrap()\n        };\n        assert!(status.code() == Some(1));\n\n        status = if cfg!(target_os = \"windows\") {\n            Command::new(\"cmd\").args(\u0026[\"/C\", \"exit 0\"]).status().unwrap()\n        } else {\n            Command::new(\"true\").status().unwrap()\n        };\n        assert!(status.success());\n    }\n\n    #[test]\n    fn test_process_output_fail_to_start() {\n        match Command::new(\"/no-binary-by-this-name-should-exist\").output() {\n            Err(e) =\u003e assert_eq!(e.kind(), ErrorKind::NotFound),\n            Ok(..) =\u003e panic!(),\n        }\n    }\n\n    #[test]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn test_process_output_output() {\n        let Output { status, stdout, stderr } = if cfg!(target_os = \"windows\") {\n            Command::new(\"cmd\").args(\u0026[\"/C\", \"echo hello\"]).output().unwrap()\n        } else {\n            Command::new(\"echo\").arg(\"hello\").output().unwrap()\n        };\n        let output_str = str::from_utf8(\u0026stdout).unwrap();\n\n        assert!(status.success());\n        assert_eq!(output_str.trim().to_string(), \"hello\");\n        assert_eq!(stderr, Vec::new());\n    }\n\n    #[test]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn test_process_output_error() {\n        let Output { status, stdout, stderr } = if cfg!(target_os = \"windows\") {\n            Command::new(\"cmd\").args(\u0026[\"/C\", \"mkdir .\"]).output().unwrap()\n        } else {\n            Command::new(\"mkdir\").arg(\"./\").output().unwrap()\n        };\n\n        assert!(status.code() == Some(1));\n        assert_eq!(stdout, Vec::new());\n        assert!(!stderr.is_empty());\n    }\n\n    #[test]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn test_finish_once() {\n        let mut prog = if cfg!(target_os = \"windows\") {\n            Command::new(\"cmd\").args(\u0026[\"/C\", \"exit 1\"]).spawn().unwrap()\n        } else {\n            Command::new(\"false\").spawn().unwrap()\n        };\n        assert!(prog.wait().unwrap().code() == Some(1));\n    }\n\n    #[test]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn test_finish_twice() {\n        let mut prog = if cfg!(target_os = \"windows\") {\n            Command::new(\"cmd\").args(\u0026[\"/C\", \"exit 1\"]).spawn().unwrap()\n        } else {\n            Command::new(\"false\").spawn().unwrap()\n        };\n        assert!(prog.wait().unwrap().code() == Some(1));\n        assert!(prog.wait().unwrap().code() == Some(1));\n    }\n\n    #[test]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn test_wait_with_output_once() {\n        let prog = if cfg!(target_os = \"windows\") {\n            Command::new(\"cmd\").args(\u0026[\"/C\", \"echo hello\"]).stdout(Stdio::piped()).spawn().unwrap()\n        } else {\n            Command::new(\"echo\").arg(\"hello\").stdout(Stdio::piped()).spawn().unwrap()\n        };\n\n        let Output { status, stdout, stderr } = prog.wait_with_output().unwrap();\n        let output_str = str::from_utf8(\u0026stdout).unwrap();\n\n        assert!(status.success());\n        assert_eq!(output_str.trim().to_string(), \"hello\");\n        assert_eq!(stderr, Vec::new());\n    }\n\n    #[cfg(all(unix, not(target_os = \"android\")))]\n    pub fn env_cmd() -\u003e Command {\n        Command::new(\"env\")\n    }\n    #[cfg(target_os = \"android\")]\n    pub fn env_cmd() -\u003e Command {\n        let mut cmd = Command::new(\"/system/bin/sh\");\n        cmd.arg(\"-c\").arg(\"set\");\n        cmd\n    }\n\n    #[cfg(windows)]\n    pub fn env_cmd() -\u003e Command {\n        let mut cmd = Command::new(\"cmd\");\n        cmd.arg(\"/c\").arg(\"set\");\n        cmd\n    }\n\n    #[test]\n    #[cfg_attr(target_os = \"vxworks\", ignore)]\n    fn test_override_env() {\n        use crate::env;\n\n        // In some build environments (such as chrooted Nix builds), `env` can\n        // only be found in the explicitly-provided PATH env variable, not in\n        // default places such as /bin or /usr/bin. So we need to pass through\n        // PATH to our sub-process.\n        let mut cmd = env_cmd();\n        cmd.env_clear().env(\"RUN_TEST_NEW_ENV\", \"123\");\n        if let Some(p) = env::var_os(\"PATH\") {\n            cmd.env(\"PATH\", \u0026p);\n        }\n        let result = cmd.output().unwrap();\n        let output = String::from_utf8_lossy(\u0026result.stdout).to_string();\n\n        assert!(\n            output.contains(\"RUN_TEST_NEW_ENV=123\"),\n            \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\",\n            output\n        );\n    }\n\n    #[test]\n    #[cfg_attr(target_os = \"vxworks\", ignore)]\n    fn test_add_to_env() {\n        let result = env_cmd().env(\"RUN_TEST_NEW_ENV\", \"123\").output().unwrap();\n        let output = String::from_utf8_lossy(\u0026result.stdout).to_string();\n\n        assert!(\n            output.contains(\"RUN_TEST_NEW_ENV=123\"),\n            \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\",\n            output\n        );\n    }\n\n    #[test]\n    #[cfg_attr(target_os = \"vxworks\", ignore)]\n    fn test_capture_env_at_spawn() {\n        use crate::env;\n\n        let mut cmd = env_cmd();\n        cmd.env(\"RUN_TEST_NEW_ENV1\", \"123\");\n\n        // This variable will not be present if the environment has already\n        // been captured above.\n        env::set_var(\"RUN_TEST_NEW_ENV2\", \"456\");\n        let result = cmd.output().unwrap();\n        env::remove_var(\"RUN_TEST_NEW_ENV2\");\n\n        let output = String::from_utf8_lossy(\u0026result.stdout).to_string();\n\n        assert!(\n            output.contains(\"RUN_TEST_NEW_ENV1=123\"),\n            \"didn't find RUN_TEST_NEW_ENV1 inside of:\\n\\n{}\",\n            output\n        );\n        assert!(\n            output.contains(\"RUN_TEST_NEW_ENV2=456\"),\n            \"didn't find RUN_TEST_NEW_ENV2 inside of:\\n\\n{}\",\n            output\n        );\n    }\n\n    // Regression tests for #30858.\n    #[test]\n    fn test_interior_nul_in_progname_is_error() {\n        match Command::new(\"has-some-\\0\\0s-inside\").spawn() {\n            Err(e) =\u003e assert_eq!(e.kind(), ErrorKind::InvalidInput),\n            Ok(_) =\u003e panic!(),\n        }\n    }\n\n    #[test]\n    fn test_interior_nul_in_arg_is_error() {\n        match Command::new(\"echo\").arg(\"has-some-\\0\\0s-inside\").spawn() {\n            Err(e) =\u003e assert_eq!(e.kind(), ErrorKind::InvalidInput),\n            Ok(_) =\u003e panic!(),\n        }\n    }\n\n    #[test]\n    fn test_interior_nul_in_args_is_error() {\n        match Command::new(\"echo\").args(\u0026[\"has-some-\\0\\0s-inside\"]).spawn() {\n            Err(e) =\u003e assert_eq!(e.kind(), ErrorKind::InvalidInput),\n            Ok(_) =\u003e panic!(),\n        }\n    }\n\n    #[test]\n    fn test_interior_nul_in_current_dir_is_error() {\n        match Command::new(\"echo\").current_dir(\"has-some-\\0\\0s-inside\").spawn() {\n            Err(e) =\u003e assert_eq!(e.kind(), ErrorKind::InvalidInput),\n            Ok(_) =\u003e panic!(),\n        }\n    }\n\n    // Regression tests for #30862.\n    #[test]\n    #[cfg_attr(target_os = \"vxworks\", ignore)]\n    fn test_interior_nul_in_env_key_is_error() {\n        match env_cmd().env(\"has-some-\\0\\0s-inside\", \"value\").spawn() {\n            Err(e) =\u003e assert_eq!(e.kind(), ErrorKind::InvalidInput),\n            Ok(_) =\u003e panic!(),\n        }\n    }\n\n    #[test]\n    #[cfg_attr(target_os = \"vxworks\", ignore)]\n    fn test_interior_nul_in_env_value_is_error() {\n        match env_cmd().env(\"key\", \"has-some-\\0\\0s-inside\").spawn() {\n            Err(e) =\u003e assert_eq!(e.kind(), ErrorKind::InvalidInput),\n            Ok(_) =\u003e panic!(),\n        }\n    }\n\n    /// Tests that process creation flags work by debugging a process.\n    /// Other creation flags make it hard or impossible to detect\n    /// behavioral changes in the process.\n    #[test]\n    #[cfg(windows)]\n    fn test_creation_flags() {\n        use crate::os::windows::process::CommandExt;\n        use crate::sys::c::{BOOL, DWORD, INFINITE};\n        #[repr(C, packed)]\n        struct DEBUG_EVENT {\n            pub event_code: DWORD,\n            pub process_id: DWORD,\n            pub thread_id: DWORD,\n            // This is a union in the real struct, but we don't\n            // need this data for the purposes of this test.\n            pub _junk: [u8; 164],\n        }\n\n        extern \"system\" {\n            fn WaitForDebugEvent(lpDebugEvent: *mut DEBUG_EVENT, dwMilliseconds: DWORD) -\u003e BOOL;\n            fn ContinueDebugEvent(\n                dwProcessId: DWORD,\n                dwThreadId: DWORD,\n                dwContinueStatus: DWORD,\n            ) -\u003e BOOL;\n        }\n\n        const DEBUG_PROCESS: DWORD = 1;\n        const EXIT_PROCESS_DEBUG_EVENT: DWORD = 5;\n        const DBG_EXCEPTION_NOT_HANDLED: DWORD = 0x80010001;\n\n        let mut child = Command::new(\"cmd\")\n            .creation_flags(DEBUG_PROCESS)\n            .stdin(Stdio::piped())\n            .spawn()\n            .unwrap();\n        child.stdin.take().unwrap().write_all(b\"exit\\r\\n\").unwrap();\n        let mut events = 0;\n        let mut event = DEBUG_EVENT { event_code: 0, process_id: 0, thread_id: 0, _junk: [0; 164] };\n        loop {\n            if unsafe { WaitForDebugEvent(\u0026mut event as *mut DEBUG_EVENT, INFINITE) } == 0 {\n                panic!(\"WaitForDebugEvent failed!\");\n            }\n            events += 1;\n\n            if event.event_code == EXIT_PROCESS_DEBUG_EVENT {\n                break;\n            }\n\n            if unsafe {\n                ContinueDebugEvent(event.process_id, event.thread_id, DBG_EXCEPTION_NOT_HANDLED)\n            } == 0\n            {\n                panic!(\"ContinueDebugEvent failed!\");\n            }\n        }\n        assert!(events \u003e 0);\n    }\n\n    #[test]\n    fn test_command_implements_send_sync() {\n        fn take_send_sync_type\u003cT: Send + Sync\u003e(_: T) {}\n        take_send_sync_type(Command::new(\"\"))\n    }\n}\n","traces":[{"line":1667,"address":[4212832],"length":1,"stats":{"Line":1},"fn_name":"report"},{"line":1668,"address":[4212838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1669,"address":[4212851,4212856],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1701,"address":[4212864],"length":1,"stats":{"Line":1},"fn_name":"report"},{"line":1702,"address":[4212870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":1703,"address":[4212886,4212888],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","usr","local","rustup","toolchains","1.45.2-x86_64-unknown-linux-gnu","lib","rustlib","src","rust","src","libstd","rt.rs"],"content":"//! Runtime services\n//!\n//! The `rt` module provides a narrow set of runtime services,\n//! including the global heap (exported in `heap`) and unwinding and\n//! backtrace support. The APIs in this module are highly unstable,\n//! and should be considered as private implementation details for the\n//! time being.\n\n#![unstable(\n    feature = \"rt\",\n    reason = \"this public module should not exist and is highly likely \\\n              to disappear\",\n    issue = \"none\"\n)]\n#![doc(hidden)]\n\n// Re-export some of our utilities which are expected by other crates.\npub use crate::panicking::{begin_panic, begin_panic_fmt, update_panic_count};\n\n// To reduce the generated code of the new `lang_start`, this function is doing\n// the real work.\n#[cfg(not(test))]\nfn lang_start_internal(\n    main: \u0026(dyn Fn() -\u003e i32 + Sync + crate::panic::RefUnwindSafe),\n    argc: isize,\n    argv: *const *const u8,\n) -\u003e isize {\n    use crate::panic;\n    use crate::sys;\n    use crate::sys_common;\n    use crate::sys_common::thread_info;\n    use crate::thread::Thread;\n\n    sys::init();\n\n    unsafe {\n        let main_guard = sys::thread::guard::init();\n        sys::stack_overflow::init();\n\n        // Next, set up the current Thread with the guard information we just\n        // created. Note that this isn't necessary in general for new threads,\n        // but we just do this to name the main thread and to give it correct\n        // info about the stack bounds.\n        let thread = Thread::new(Some(\"main\".to_owned()));\n        thread_info::set(main_guard, thread);\n\n        // Store our args if necessary in a squirreled away location\n        sys::args::init(argc, argv);\n\n        // Let's run some code!\n        let exit_code = panic::catch_unwind(|| {\n            sys_common::backtrace::__rust_begin_short_backtrace(move || main())\n        });\n\n        sys_common::cleanup();\n        exit_code.unwrap_or(101) as isize\n    }\n}\n\n#[cfg(not(test))]\n#[lang = \"start\"]\nfn lang_start\u003cT: crate::process::Termination + 'static\u003e(\n    main: fn() -\u003e T,\n    argc: isize,\n    argv: *const *const u8,\n) -\u003e isize {\n    lang_start_internal(\u0026move || main().report(), argc, argv)\n}\n","traces":[{"line":62,"address":[4212224],"length":1,"stats":{"Line":1},"fn_name":"lang_start\u003c()\u003e"},{"line":67,"address":[4212320,4212329,4212250],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}\u003c()\u003e"},{"line":68,"address":[4212308,4212303],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":3,"coverable":3},{"path":["/","usr","local","rustup","toolchains","1.45.2-x86_64-unknown-linux-gnu","lib","rustlib","src","rust","src","libstd","sys","unix","process","process_common.rs"],"content":"use crate::os::unix::prelude::*;\n\nuse crate::collections::BTreeMap;\nuse crate::ffi::{CStr, CString, OsStr, OsString};\nuse crate::fmt;\nuse crate::io;\nuse crate::ptr;\nuse crate::sys::fd::FileDesc;\nuse crate::sys::fs::File;\nuse crate::sys::pipe::{self, AnonPipe};\nuse crate::sys_common::process::CommandEnv;\n\n#[cfg(not(target_os = \"fuchsia\"))]\nuse crate::sys::fs::OpenOptions;\n\nuse libc::{c_char, c_int, gid_t, uid_t, EXIT_FAILURE, EXIT_SUCCESS};\n\ncfg_if::cfg_if! {\n    if #[cfg(target_os = \"fuchsia\")] {\n        // fuchsia doesn't have /dev/null\n    } else if #[cfg(target_os = \"redox\")] {\n        const DEV_NULL: \u0026str = \"null:\\0\";\n    } else {\n        const DEV_NULL: \u0026str = \"/dev/null\\0\";\n    }\n}\n\n// Android with api less than 21 define sig* functions inline, so it is not\n// available for dynamic link. Implementing sigemptyset and sigaddset allow us\n// to support older Android version (independent of libc version).\n// The following implementations are based on https://git.io/vSkNf\ncfg_if::cfg_if! {\n    if #[cfg(target_os = \"android\")] {\n        pub unsafe fn sigemptyset(set: *mut libc::sigset_t) -\u003e libc::c_int {\n            set.write_bytes(0u8, 1);\n            return 0;\n        }\n        #[allow(dead_code)]\n        pub unsafe fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -\u003e libc::c_int {\n            use crate::{slice, mem};\n\n            let raw = slice::from_raw_parts_mut(set as *mut u8, mem::size_of::\u003clibc::sigset_t\u003e());\n            let bit = (signum - 1) as usize;\n            raw[bit / 8] |= 1 \u003c\u003c (bit % 8);\n            return 0;\n        }\n    } else {\n        pub use libc::{sigemptyset, sigaddset};\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Command\n////////////////////////////////////////////////////////////////////////////////\n\npub struct Command {\n    // Currently we try hard to ensure that the call to `.exec()` doesn't\n    // actually allocate any memory. While many platforms try to ensure that\n    // memory allocation works after a fork in a multithreaded process, it's\n    // been observed to be buggy and somewhat unreliable, so we do our best to\n    // just not do it at all!\n    //\n    // Along those lines, the `argv` and `envp` raw pointers here are exactly\n    // what's gonna get passed to `execvp`. The `argv` array starts with the\n    // `program` and ends with a NULL, and the `envp` pointer, if present, is\n    // also null-terminated.\n    //\n    // Right now we don't support removing arguments, so there's no much fancy\n    // support there, but we support adding and removing environment variables,\n    // so a side table is used to track where in the `envp` array each key is\n    // located. Whenever we add a key we update it in place if it's already\n    // present, and whenever we remove a key we update the locations of all\n    // other keys.\n    program: CString,\n    args: Vec\u003cCString\u003e,\n    argv: Argv,\n    env: CommandEnv,\n\n    cwd: Option\u003cCString\u003e,\n    uid: Option\u003cuid_t\u003e,\n    gid: Option\u003cgid_t\u003e,\n    saw_nul: bool,\n    closures: Vec\u003cBox\u003cdyn FnMut() -\u003e io::Result\u003c()\u003e + Send + Sync\u003e\u003e,\n    stdin: Option\u003cStdio\u003e,\n    stdout: Option\u003cStdio\u003e,\n    stderr: Option\u003cStdio\u003e,\n}\n\n// Create a new type for argv, so that we can make it `Send` and `Sync`\nstruct Argv(Vec\u003c*const c_char\u003e);\n\n// It is safe to make `Argv` `Send` and `Sync`, because it contains\n// pointers to memory owned by `Command.args`\nunsafe impl Send for Argv {}\nunsafe impl Sync for Argv {}\n\n// passed back to std::process with the pipes connected to the child, if any\n// were requested\npub struct StdioPipes {\n    pub stdin: Option\u003cAnonPipe\u003e,\n    pub stdout: Option\u003cAnonPipe\u003e,\n    pub stderr: Option\u003cAnonPipe\u003e,\n}\n\n// passed to do_exec() with configuration of what the child stdio should look\n// like\npub struct ChildPipes {\n    pub stdin: ChildStdio,\n    pub stdout: ChildStdio,\n    pub stderr: ChildStdio,\n}\n\npub enum ChildStdio {\n    Inherit,\n    Explicit(c_int),\n    Owned(FileDesc),\n\n    // On Fuchsia, null stdio is the default, so we simply don't specify\n    // any actions at the time of spawning.\n    #[cfg(target_os = \"fuchsia\")]\n    Null,\n}\n\npub enum Stdio {\n    Inherit,\n    Null,\n    MakePipe,\n    Fd(FileDesc),\n}\n\nimpl Command {\n    pub fn new(program: \u0026OsStr) -\u003e Command {\n        let mut saw_nul = false;\n        let program = os2c(program, \u0026mut saw_nul);\n        Command {\n            argv: Argv(vec![program.as_ptr(), ptr::null()]),\n            args: vec![program.clone()],\n            program,\n            env: Default::default(),\n            cwd: None,\n            uid: None,\n            gid: None,\n            saw_nul,\n            closures: Vec::new(),\n            stdin: None,\n            stdout: None,\n            stderr: None,\n        }\n    }\n\n    pub fn set_arg_0(\u0026mut self, arg: \u0026OsStr) {\n        // Set a new arg0\n        let arg = os2c(arg, \u0026mut self.saw_nul);\n        debug_assert!(self.argv.0.len() \u003e 1);\n        self.argv.0[0] = arg.as_ptr();\n        self.args[0] = arg;\n    }\n\n    pub fn arg(\u0026mut self, arg: \u0026OsStr) {\n        // Overwrite the trailing NULL pointer in `argv` and then add a new null\n        // pointer.\n        let arg = os2c(arg, \u0026mut self.saw_nul);\n        self.argv.0[self.args.len()] = arg.as_ptr();\n        self.argv.0.push(ptr::null());\n\n        // Also make sure we keep track of the owned value to schedule a\n        // destructor for this memory.\n        self.args.push(arg);\n    }\n\n    pub fn cwd(\u0026mut self, dir: \u0026OsStr) {\n        self.cwd = Some(os2c(dir, \u0026mut self.saw_nul));\n    }\n    pub fn uid(\u0026mut self, id: uid_t) {\n        self.uid = Some(id);\n    }\n    pub fn gid(\u0026mut self, id: gid_t) {\n        self.gid = Some(id);\n    }\n\n    pub fn saw_nul(\u0026self) -\u003e bool {\n        self.saw_nul\n    }\n    pub fn get_argv(\u0026self) -\u003e \u0026Vec\u003c*const c_char\u003e {\n        \u0026self.argv.0\n    }\n\n    pub fn get_program(\u0026self) -\u003e \u0026CStr {\n        \u0026*self.program\n    }\n\n    #[allow(dead_code)]\n    pub fn get_cwd(\u0026self) -\u003e \u0026Option\u003cCString\u003e {\n        \u0026self.cwd\n    }\n    #[allow(dead_code)]\n    pub fn get_uid(\u0026self) -\u003e Option\u003cuid_t\u003e {\n        self.uid\n    }\n    #[allow(dead_code)]\n    pub fn get_gid(\u0026self) -\u003e Option\u003cgid_t\u003e {\n        self.gid\n    }\n\n    pub fn get_closures(\u0026mut self) -\u003e \u0026mut Vec\u003cBox\u003cdyn FnMut() -\u003e io::Result\u003c()\u003e + Send + Sync\u003e\u003e {\n        \u0026mut self.closures\n    }\n\n    pub unsafe fn pre_exec(\u0026mut self, f: Box\u003cdyn FnMut() -\u003e io::Result\u003c()\u003e + Send + Sync\u003e) {\n        self.closures.push(f);\n    }\n\n    pub fn stdin(\u0026mut self, stdin: Stdio) {\n        self.stdin = Some(stdin);\n    }\n\n    pub fn stdout(\u0026mut self, stdout: Stdio) {\n        self.stdout = Some(stdout);\n    }\n\n    pub fn stderr(\u0026mut self, stderr: Stdio) {\n        self.stderr = Some(stderr);\n    }\n\n    pub fn env_mut(\u0026mut self) -\u003e \u0026mut CommandEnv {\n        \u0026mut self.env\n    }\n\n    pub fn capture_env(\u0026mut self) -\u003e Option\u003cCStringArray\u003e {\n        let maybe_env = self.env.capture_if_changed();\n        maybe_env.map(|env| construct_envp(env, \u0026mut self.saw_nul))\n    }\n    #[allow(dead_code)]\n    pub fn env_saw_path(\u0026self) -\u003e bool {\n        self.env.have_changed_path()\n    }\n\n    pub fn setup_io(\n        \u0026self,\n        default: Stdio,\n        needs_stdin: bool,\n    ) -\u003e io::Result\u003c(StdioPipes, ChildPipes)\u003e {\n        let null = Stdio::Null;\n        let default_stdin = if needs_stdin { \u0026default } else { \u0026null };\n        let stdin = self.stdin.as_ref().unwrap_or(default_stdin);\n        let stdout = self.stdout.as_ref().unwrap_or(\u0026default);\n        let stderr = self.stderr.as_ref().unwrap_or(\u0026default);\n        let (their_stdin, our_stdin) = stdin.to_child_stdio(true)?;\n        let (their_stdout, our_stdout) = stdout.to_child_stdio(false)?;\n        let (their_stderr, our_stderr) = stderr.to_child_stdio(false)?;\n        let ours = StdioPipes { stdin: our_stdin, stdout: our_stdout, stderr: our_stderr };\n        let theirs = ChildPipes { stdin: their_stdin, stdout: their_stdout, stderr: their_stderr };\n        Ok((ours, theirs))\n    }\n}\n\nfn os2c(s: \u0026OsStr, saw_nul: \u0026mut bool) -\u003e CString {\n    CString::new(s.as_bytes()).unwrap_or_else(|_e| {\n        *saw_nul = true;\n        CString::new(\"\u003cstring-with-nul\u003e\").unwrap()\n    })\n}\n\n// Helper type to manage ownership of the strings within a C-style array.\npub struct CStringArray {\n    items: Vec\u003cCString\u003e,\n    ptrs: Vec\u003c*const c_char\u003e,\n}\n\nimpl CStringArray {\n    pub fn with_capacity(capacity: usize) -\u003e Self {\n        let mut result = CStringArray {\n            items: Vec::with_capacity(capacity),\n            ptrs: Vec::with_capacity(capacity + 1),\n        };\n        result.ptrs.push(ptr::null());\n        result\n    }\n    pub fn push(\u0026mut self, item: CString) {\n        let l = self.ptrs.len();\n        self.ptrs[l - 1] = item.as_ptr();\n        self.ptrs.push(ptr::null());\n        self.items.push(item);\n    }\n    pub fn as_ptr(\u0026self) -\u003e *const *const c_char {\n        self.ptrs.as_ptr()\n    }\n}\n\nfn construct_envp(env: BTreeMap\u003cOsString, OsString\u003e, saw_nul: \u0026mut bool) -\u003e CStringArray {\n    let mut result = CStringArray::with_capacity(env.len());\n    for (mut k, v) in env {\n        // Reserve additional space for '=' and null terminator\n        k.reserve_exact(v.len() + 2);\n        k.push(\"=\");\n        k.push(\u0026v);\n\n        // Add the new entry into the array\n        if let Ok(item) = CString::new(k.into_vec()) {\n            result.push(item);\n        } else {\n            *saw_nul = true;\n        }\n    }\n\n    result\n}\n\nimpl Stdio {\n    pub fn to_child_stdio(\u0026self, readable: bool) -\u003e io::Result\u003c(ChildStdio, Option\u003cAnonPipe\u003e)\u003e {\n        match *self {\n            Stdio::Inherit =\u003e Ok((ChildStdio::Inherit, None)),\n\n            // Make sure that the source descriptors are not an stdio\n            // descriptor, otherwise the order which we set the child's\n            // descriptors may blow away a descriptor which we are hoping to\n            // save. For example, suppose we want the child's stderr to be the\n            // parent's stdout, and the child's stdout to be the parent's\n            // stderr. No matter which we dup first, the second will get\n            // overwritten prematurely.\n            Stdio::Fd(ref fd) =\u003e {\n                if fd.raw() \u003e= 0 \u0026\u0026 fd.raw() \u003c= libc::STDERR_FILENO {\n                    Ok((ChildStdio::Owned(fd.duplicate()?), None))\n                } else {\n                    Ok((ChildStdio::Explicit(fd.raw()), None))\n                }\n            }\n\n            Stdio::MakePipe =\u003e {\n                let (reader, writer) = pipe::anon_pipe()?;\n                let (ours, theirs) = if readable { (writer, reader) } else { (reader, writer) };\n                Ok((ChildStdio::Owned(theirs.into_fd()), Some(ours)))\n            }\n\n            #[cfg(not(target_os = \"fuchsia\"))]\n            Stdio::Null =\u003e {\n                let mut opts = OpenOptions::new();\n                opts.read(readable);\n                opts.write(!readable);\n                let path = unsafe { CStr::from_ptr(DEV_NULL.as_ptr() as *const _) };\n                let fd = File::open_c(\u0026path, \u0026opts)?;\n                Ok((ChildStdio::Owned(fd.into_fd()), None))\n            }\n\n            #[cfg(target_os = \"fuchsia\")]\n            Stdio::Null =\u003e Ok((ChildStdio::Null, None)),\n        }\n    }\n}\n\nimpl From\u003cAnonPipe\u003e for Stdio {\n    fn from(pipe: AnonPipe) -\u003e Stdio {\n        Stdio::Fd(pipe.into_fd())\n    }\n}\n\nimpl From\u003cFile\u003e for Stdio {\n    fn from(file: File) -\u003e Stdio {\n        Stdio::Fd(file.into_fd())\n    }\n}\n\nimpl ChildStdio {\n    pub fn fd(\u0026self) -\u003e Option\u003cc_int\u003e {\n        match *self {\n            ChildStdio::Inherit =\u003e None,\n            ChildStdio::Explicit(fd) =\u003e Some(fd),\n            ChildStdio::Owned(ref fd) =\u003e Some(fd.raw()),\n\n            #[cfg(target_os = \"fuchsia\")]\n            ChildStdio::Null =\u003e None,\n        }\n    }\n}\n\nimpl fmt::Debug for Command {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        if self.program != self.args[0] {\n            write!(f, \"[{:?}] \", self.program)?;\n        }\n        write!(f, \"{:?}\", self.args[0])?;\n\n        for arg in \u0026self.args[1..] {\n            write!(f, \" {:?}\", arg)?;\n        }\n        Ok(())\n    }\n}\n\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\npub struct ExitCode(u8);\n\nimpl ExitCode {\n    pub const SUCCESS: ExitCode = ExitCode(EXIT_SUCCESS as _);\n    pub const FAILURE: ExitCode = ExitCode(EXIT_FAILURE as _);\n\n    #[inline]\n    pub fn as_i32(\u0026self) -\u003e i32 {\n        self.0 as i32\n    }\n}\n\n#[cfg(all(test, not(target_os = \"emscripten\")))]\nmod tests {\n    use super::*;\n\n    use crate::ffi::OsStr;\n    use crate::mem;\n    use crate::ptr;\n    use crate::sys::cvt;\n\n    macro_rules! t {\n        ($e:expr) =\u003e {\n            match $e {\n                Ok(t) =\u003e t,\n                Err(e) =\u003e panic!(\"received error for `{}`: {}\", stringify!($e), e),\n            }\n        };\n    }\n\n    // See #14232 for more information, but it appears that signal delivery to a\n    // newly spawned process may just be raced in the macOS, so to prevent this\n    // test from being flaky we ignore it on macOS.\n    #[test]\n    #[cfg_attr(target_os = \"macos\", ignore)]\n    // When run under our current QEMU emulation test suite this test fails,\n    // although the reason isn't very clear as to why. For now this test is\n    // ignored there.\n    #[cfg_attr(target_arch = \"arm\", ignore)]\n    #[cfg_attr(target_arch = \"aarch64\", ignore)]\n    fn test_process_mask() {\n        unsafe {\n            // Test to make sure that a signal mask does not get inherited.\n            let mut cmd = Command::new(OsStr::new(\"cat\"));\n\n            let mut set = mem::MaybeUninit::\u003clibc::sigset_t\u003e::uninit();\n            let mut old_set = mem::MaybeUninit::\u003clibc::sigset_t\u003e::uninit();\n            t!(cvt(sigemptyset(set.as_mut_ptr())));\n            t!(cvt(sigaddset(set.as_mut_ptr(), libc::SIGINT)));\n            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, set.as_ptr(), old_set.as_mut_ptr())));\n\n            cmd.stdin(Stdio::MakePipe);\n            cmd.stdout(Stdio::MakePipe);\n\n            let (mut cat, mut pipes) = t!(cmd.spawn(Stdio::Null, true));\n            let stdin_write = pipes.stdin.take().unwrap();\n            let stdout_read = pipes.stdout.take().unwrap();\n\n            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, old_set.as_ptr(), ptr::null_mut())));\n\n            t!(cvt(libc::kill(cat.id() as libc::pid_t, libc::SIGINT)));\n            // We need to wait until SIGINT is definitely delivered. The\n            // easiest way is to write something to cat, and try to read it\n            // back: if SIGINT is unmasked, it'll get delivered when cat is\n            // next scheduled.\n            let _ = stdin_write.write(b\"Hello\");\n            drop(stdin_write);\n\n            // Either EOF or failure (EPIPE) is okay.\n            let mut buf = [0; 5];\n            if let Ok(ret) = stdout_read.read(\u0026mut buf) {\n                assert_eq!(ret, 0);\n            }\n\n            t!(cat.wait());\n        }\n    }\n}\n","traces":[{"line":398,"address":[4212048],"length":1,"stats":{"Line":1},"fn_name":"as_i32"},{"line":399,"address":[4212053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":400,"address":[4212056,4212058],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":3,"coverable":3},{"path":["/","usr","local","rustup","toolchains","1.45.2-x86_64-unknown-linux-gnu","lib","rustlib","src","rust","src","libtest","lib.rs"],"content":"//! Support code for rustc's built in unit-test and micro-benchmarking\n//! framework.\n//!\n//! Almost all user code will only be interested in `Bencher` and\n//! `black_box`. All other interactions (such as writing tests and\n//! benchmarks themselves) should be done via the `#[test]` and\n//! `#[bench]` attributes.\n//!\n//! See the [Testing Chapter](../book/ch11-00-testing.html) of the book for more details.\n\n// Currently, not much of this is meant for users. It is intended to\n// support the simplest interface possible for representing and\n// running tests while providing a base that other test frameworks may\n// build off of.\n\n// N.B., this is also specified in this crate's Cargo.toml, but librustc_ast contains logic specific to\n// this crate, which relies on this attribute (rather than the value of `--crate-name` passed by\n// cargo) to detect this crate.\n\n#![crate_name = \"test\"]\n#![unstable(feature = \"test\", issue = \"50297\")]\n#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\", test(attr(deny(warnings))))]\n#![cfg_attr(any(unix, target_os = \"cloudabi\"), feature(libc))]\n#![feature(rustc_private)]\n#![feature(nll)]\n#![feature(bool_to_option)]\n#![feature(set_stdio)]\n#![feature(panic_unwind)]\n#![feature(staged_api)]\n#![feature(termination_trait_lib)]\n#![feature(test)]\n\n// Public reexports\npub use self::bench::{black_box, Bencher};\npub use self::console::run_tests_console;\npub use self::options::{ColorConfig, Options, OutputFormat, RunIgnored, ShouldPanic};\npub use self::types::TestName::*;\npub use self::types::*;\npub use self::ColorConfig::*;\npub use cli::TestOpts;\n\n// Module to be used by rustc to compile tests in libtest\npub mod test {\n    pub use crate::{\n        assert_test_result,\n        bench::Bencher,\n        cli::{parse_opts, TestOpts},\n        filter_tests,\n        helpers::metrics::{Metric, MetricMap},\n        options::{Options, RunIgnored, RunStrategy, ShouldPanic},\n        run_test, test_main, test_main_static,\n        test_result::{TestResult, TrFailed, TrFailedMsg, TrIgnored, TrOk},\n        time::{TestExecTime, TestTimeOptions},\n        types::{\n            DynTestFn, DynTestName, StaticBenchFn, StaticTestFn, StaticTestName, TestDesc,\n            TestDescAndFn, TestName, TestType,\n        },\n    };\n}\n\nuse std::{\n    env, io,\n    io::prelude::Write,\n    panic::{self, catch_unwind, AssertUnwindSafe, PanicInfo},\n    process::{self, Command, Termination},\n    sync::mpsc::{channel, Sender},\n    sync::{Arc, Mutex},\n    thread,\n    time::{Duration, Instant},\n};\n\npub mod bench;\nmod cli;\nmod console;\nmod event;\nmod formatters;\nmod helpers;\nmod options;\npub mod stats;\nmod test_result;\nmod time;\nmod types;\n\n#[cfg(test)]\nmod tests;\n\nuse event::{CompletedTest, TestEvent};\nuse helpers::concurrency::get_concurrency;\nuse helpers::exit_code::get_exit_code;\nuse helpers::sink::Sink;\nuse options::{Concurrent, RunStrategy};\nuse test_result::*;\nuse time::TestExecTime;\n\n// Process exit code to be used to indicate test failures.\nconst ERROR_EXIT_CODE: i32 = 101;\n\nconst SECONDARY_TEST_INVOKER_VAR: \u0026str = \"__RUST_TEST_INVOKE\";\n\n// The default console test runner. It accepts the command line\n// arguments and a vector of test_descs.\npub fn test_main(args: \u0026[String], tests: Vec\u003cTestDescAndFn\u003e, options: Option\u003cOptions\u003e) {\n    let mut opts = match cli::parse_opts(args) {\n        Some(Ok(o)) =\u003e o,\n        Some(Err(msg)) =\u003e {\n            eprintln!(\"error: {}\", msg);\n            process::exit(ERROR_EXIT_CODE);\n        }\n        None =\u003e return,\n    };\n    if let Some(options) = options {\n        opts.options = options;\n    }\n    if opts.list {\n        if let Err(e) = console::list_tests_console(\u0026opts, tests) {\n            eprintln!(\"error: io error when listing tests: {:?}\", e);\n            process::exit(ERROR_EXIT_CODE);\n        }\n    } else {\n        match console::run_tests_console(\u0026opts, tests) {\n            Ok(true) =\u003e {}\n            Ok(false) =\u003e process::exit(ERROR_EXIT_CODE),\n            Err(e) =\u003e {\n                eprintln!(\"error: io error when listing tests: {:?}\", e);\n                process::exit(ERROR_EXIT_CODE);\n            }\n        }\n    }\n}\n\n/// A variant optimized for invocation with a static test vector.\n/// This will panic (intentionally) when fed any dynamic tests.\n///\n/// This is the entry point for the main function generated by `rustc --test`\n/// when panic=unwind.\npub fn test_main_static(tests: \u0026[\u0026TestDescAndFn]) {\n    let args = env::args().collect::\u003cVec\u003c_\u003e\u003e();\n    let owned_tests: Vec\u003c_\u003e = tests.iter().map(make_owned_test).collect();\n    test_main(\u0026args, owned_tests, None)\n}\n\n/// A variant optimized for invocation with a static test vector.\n/// This will panic (intentionally) when fed any dynamic tests.\n///\n/// Runs tests in panic=abort mode, which involves spawning subprocesses for\n/// tests.\n///\n/// This is the entry point for the main function generated by `rustc --test`\n/// when panic=abort.\npub fn test_main_static_abort(tests: \u0026[\u0026TestDescAndFn]) {\n    // If we're being run in SpawnedSecondary mode, run the test here. run_test\n    // will then exit the process.\n    if let Ok(name) = env::var(SECONDARY_TEST_INVOKER_VAR) {\n        env::remove_var(SECONDARY_TEST_INVOKER_VAR);\n        let test = tests\n            .iter()\n            .filter(|test| test.desc.name.as_slice() == name)\n            .map(make_owned_test)\n            .next()\n            .unwrap_or_else(|| panic!(\"couldn't find a test with the provided name '{}'\", name));\n        let TestDescAndFn { desc, testfn } = test;\n        let testfn = match testfn {\n            StaticTestFn(f) =\u003e f,\n            _ =\u003e panic!(\"only static tests are supported\"),\n        };\n        run_test_in_spawned_subprocess(desc, Box::new(testfn));\n    }\n\n    let args = env::args().collect::\u003cVec\u003c_\u003e\u003e();\n    let owned_tests: Vec\u003c_\u003e = tests.iter().map(make_owned_test).collect();\n    test_main(\u0026args, owned_tests, Some(Options::new().panic_abort(true)))\n}\n\n/// Clones static values for putting into a dynamic vector, which test_main()\n/// needs to hand out ownership of tests to parallel test runners.\n///\n/// This will panic when fed any dynamic tests, because they cannot be cloned.\nfn make_owned_test(test: \u0026\u0026TestDescAndFn) -\u003e TestDescAndFn {\n    match test.testfn {\n        StaticTestFn(f) =\u003e TestDescAndFn { testfn: StaticTestFn(f), desc: test.desc.clone() },\n        StaticBenchFn(f) =\u003e TestDescAndFn { testfn: StaticBenchFn(f), desc: test.desc.clone() },\n        _ =\u003e panic!(\"non-static tests passed to test::test_main_static\"),\n    }\n}\n\n/// Invoked when unit tests terminate. Should panic if the unit\n/// Tests is considered a failure. By default, invokes `report()`\n/// and checks for a `0` result.\npub fn assert_test_result\u003cT: Termination\u003e(result: T) {\n    let code = result.report();\n    assert_eq!(\n        code, 0,\n        \"the test returned a termination value with a non-zero status code ({}) \\\n         which indicates a failure\",\n        code\n    );\n}\n\npub fn run_tests\u003cF\u003e(\n    opts: \u0026TestOpts,\n    tests: Vec\u003cTestDescAndFn\u003e,\n    mut notify_about_test_event: F,\n) -\u003e io::Result\u003c()\u003e\nwhere\n    F: FnMut(TestEvent) -\u003e io::Result\u003c()\u003e,\n{\n    use std::collections::{self, HashMap};\n    use std::hash::BuildHasherDefault;\n    use std::sync::mpsc::RecvTimeoutError;\n    // Use a deterministic hasher\n    type TestMap =\n        HashMap\u003cTestDesc, Instant, BuildHasherDefault\u003ccollections::hash_map::DefaultHasher\u003e\u003e;\n\n    let tests_len = tests.len();\n\n    let mut filtered_tests = filter_tests(opts, tests);\n    if !opts.bench_benchmarks {\n        filtered_tests = convert_benchmarks_to_tests(filtered_tests);\n    }\n\n    let filtered_tests = {\n        let mut filtered_tests = filtered_tests;\n        for test in filtered_tests.iter_mut() {\n            test.desc.name = test.desc.name.with_padding(test.testfn.padding());\n        }\n\n        filtered_tests\n    };\n\n    let filtered_out = tests_len - filtered_tests.len();\n    let event = TestEvent::TeFilteredOut(filtered_out);\n    notify_about_test_event(event)?;\n\n    let filtered_descs = filtered_tests.iter().map(|t| t.desc.clone()).collect();\n\n    let event = TestEvent::TeFiltered(filtered_descs);\n    notify_about_test_event(event)?;\n\n    let (filtered_tests, filtered_benchs): (Vec\u003c_\u003e, _) =\n        filtered_tests.into_iter().partition(|e| match e.testfn {\n            StaticTestFn(_) | DynTestFn(_) =\u003e true,\n            _ =\u003e false,\n        });\n\n    let concurrency = opts.test_threads.unwrap_or_else(get_concurrency);\n\n    let mut remaining = filtered_tests;\n    remaining.reverse();\n    let mut pending = 0;\n\n    let (tx, rx) = channel::\u003cCompletedTest\u003e();\n    let run_strategy = if opts.options.panic_abort \u0026\u0026 !opts.force_run_in_process {\n        RunStrategy::SpawnPrimary\n    } else {\n        RunStrategy::InProcess\n    };\n\n    let mut running_tests: TestMap = HashMap::default();\n\n    fn get_timed_out_tests(running_tests: \u0026mut TestMap) -\u003e Vec\u003cTestDesc\u003e {\n        let now = Instant::now();\n        let timed_out = running_tests\n            .iter()\n            .filter_map(|(desc, timeout)| if \u0026now \u003e= timeout { Some(desc.clone()) } else { None })\n            .collect();\n        for test in \u0026timed_out {\n            running_tests.remove(test);\n        }\n        timed_out\n    };\n\n    fn calc_timeout(running_tests: \u0026TestMap) -\u003e Option\u003cDuration\u003e {\n        running_tests.values().min().map(|next_timeout| {\n            let now = Instant::now();\n            if *next_timeout \u003e= now { *next_timeout - now } else { Duration::new(0, 0) }\n        })\n    };\n\n    if concurrency == 1 {\n        while !remaining.is_empty() {\n            let test = remaining.pop().unwrap();\n            let event = TestEvent::TeWait(test.desc.clone());\n            notify_about_test_event(event)?;\n            run_test(opts, !opts.run_tests, test, run_strategy, tx.clone(), Concurrent::No);\n            let completed_test = rx.recv().unwrap();\n\n            let event = TestEvent::TeResult(completed_test);\n            notify_about_test_event(event)?;\n        }\n    } else {\n        while pending \u003e 0 || !remaining.is_empty() {\n            while pending \u003c concurrency \u0026\u0026 !remaining.is_empty() {\n                let test = remaining.pop().unwrap();\n                let timeout = time::get_default_test_timeout();\n                running_tests.insert(test.desc.clone(), timeout);\n\n                let event = TestEvent::TeWait(test.desc.clone());\n                notify_about_test_event(event)?; //here no pad\n                run_test(opts, !opts.run_tests, test, run_strategy, tx.clone(), Concurrent::Yes);\n                pending += 1;\n            }\n\n            let mut res;\n            loop {\n                if let Some(timeout) = calc_timeout(\u0026running_tests) {\n                    res = rx.recv_timeout(timeout);\n                    for test in get_timed_out_tests(\u0026mut running_tests) {\n                        let event = TestEvent::TeTimeout(test);\n                        notify_about_test_event(event)?;\n                    }\n\n                    match res {\n                        Err(RecvTimeoutError::Timeout) =\u003e {\n                            // Result is not yet ready, continue waiting.\n                        }\n                        _ =\u003e {\n                            // We've got a result, stop the loop.\n                            break;\n                        }\n                    }\n                } else {\n                    res = rx.recv().map_err(|_| RecvTimeoutError::Disconnected);\n                    break;\n                }\n            }\n\n            let completed_test = res.unwrap();\n            running_tests.remove(\u0026completed_test.desc);\n\n            let event = TestEvent::TeResult(completed_test);\n            notify_about_test_event(event)?;\n            pending -= 1;\n        }\n    }\n\n    if opts.bench_benchmarks {\n        // All benchmarks run at the end, in serial.\n        for b in filtered_benchs {\n            let event = TestEvent::TeWait(b.desc.clone());\n            notify_about_test_event(event)?;\n            run_test(opts, false, b, run_strategy, tx.clone(), Concurrent::No);\n            let completed_test = rx.recv().unwrap();\n\n            let event = TestEvent::TeResult(completed_test);\n            notify_about_test_event(event)?;\n        }\n    }\n    Ok(())\n}\n\npub fn filter_tests(opts: \u0026TestOpts, tests: Vec\u003cTestDescAndFn\u003e) -\u003e Vec\u003cTestDescAndFn\u003e {\n    let mut filtered = tests;\n    let matches_filter = |test: \u0026TestDescAndFn, filter: \u0026str| {\n        let test_name = test.desc.name.as_slice();\n\n        match opts.filter_exact {\n            true =\u003e test_name == filter,\n            false =\u003e test_name.contains(filter),\n        }\n    };\n\n    // Remove tests that don't match the test filter\n    if let Some(ref filter) = opts.filter {\n        filtered.retain(|test| matches_filter(test, filter));\n    }\n\n    // Skip tests that match any of the skip filters\n    filtered.retain(|test| !opts.skip.iter().any(|sf| matches_filter(test, sf)));\n\n    // Excludes #[should_panic] tests\n    if opts.exclude_should_panic {\n        filtered.retain(|test| test.desc.should_panic == ShouldPanic::No);\n    }\n\n    // maybe unignore tests\n    match opts.run_ignored {\n        RunIgnored::Yes =\u003e {\n            filtered.iter_mut().for_each(|test| test.desc.ignore = false);\n        }\n        RunIgnored::Only =\u003e {\n            filtered.retain(|test| test.desc.ignore);\n            filtered.iter_mut().for_each(|test| test.desc.ignore = false);\n        }\n        RunIgnored::No =\u003e {}\n    }\n\n    // Sort the tests alphabetically\n    filtered.sort_by(|t1, t2| t1.desc.name.as_slice().cmp(t2.desc.name.as_slice()));\n\n    filtered\n}\n\npub fn convert_benchmarks_to_tests(tests: Vec\u003cTestDescAndFn\u003e) -\u003e Vec\u003cTestDescAndFn\u003e {\n    // convert benchmarks to tests, if we're not benchmarking them\n    tests\n        .into_iter()\n        .map(|x| {\n            let testfn = match x.testfn {\n                DynBenchFn(bench) =\u003e DynTestFn(Box::new(move || {\n                    bench::run_once(|b| __rust_begin_short_backtrace(|| bench.run(b)))\n                })),\n                StaticBenchFn(benchfn) =\u003e DynTestFn(Box::new(move || {\n                    bench::run_once(|b| __rust_begin_short_backtrace(|| benchfn(b)))\n                })),\n                f =\u003e f,\n            };\n            TestDescAndFn { desc: x.desc, testfn }\n        })\n        .collect()\n}\n\npub fn run_test(\n    opts: \u0026TestOpts,\n    force_ignore: bool,\n    test: TestDescAndFn,\n    strategy: RunStrategy,\n    monitor_ch: Sender\u003cCompletedTest\u003e,\n    concurrency: Concurrent,\n) {\n    let TestDescAndFn { desc, testfn } = test;\n\n    // Emscripten can catch panics but other wasm targets cannot\n    let ignore_because_no_process_support = desc.should_panic != ShouldPanic::No\n        \u0026\u0026 cfg!(target_arch = \"wasm32\")\n        \u0026\u0026 !cfg!(target_os = \"emscripten\");\n\n    if force_ignore || desc.ignore || ignore_because_no_process_support {\n        let message = CompletedTest::new(desc, TrIgnored, None, Vec::new());\n        monitor_ch.send(message).unwrap();\n        return;\n    }\n\n    struct TestRunOpts {\n        pub strategy: RunStrategy,\n        pub nocapture: bool,\n        pub concurrency: Concurrent,\n        pub time: Option\u003ctime::TestTimeOptions\u003e,\n    }\n\n    fn run_test_inner(\n        desc: TestDesc,\n        monitor_ch: Sender\u003cCompletedTest\u003e,\n        testfn: Box\u003cdyn FnOnce() + Send\u003e,\n        opts: TestRunOpts,\n    ) {\n        let concurrency = opts.concurrency;\n        let name = desc.name.clone();\n\n        let runtest = move || match opts.strategy {\n            RunStrategy::InProcess =\u003e run_test_in_process(\n                desc,\n                opts.nocapture,\n                opts.time.is_some(),\n                testfn,\n                monitor_ch,\n                opts.time,\n            ),\n            RunStrategy::SpawnPrimary =\u003e spawn_test_subprocess(\n                desc,\n                opts.nocapture,\n                opts.time.is_some(),\n                monitor_ch,\n                opts.time,\n            ),\n        };\n\n        // If the platform is single-threaded we're just going to run\n        // the test synchronously, regardless of the concurrency\n        // level.\n        let supports_threads = !cfg!(target_os = \"emscripten\") \u0026\u0026 !cfg!(target_arch = \"wasm32\");\n        if concurrency == Concurrent::Yes \u0026\u0026 supports_threads {\n            let cfg = thread::Builder::new().name(name.as_slice().to_owned());\n            cfg.spawn(runtest).unwrap();\n        } else {\n            runtest();\n        }\n    }\n\n    let test_run_opts =\n        TestRunOpts { strategy, nocapture: opts.nocapture, concurrency, time: opts.time_options };\n\n    match testfn {\n        DynBenchFn(bencher) =\u003e {\n            // Benchmarks aren't expected to panic, so we run them all in-process.\n            crate::bench::benchmark(desc, monitor_ch, opts.nocapture, |harness| {\n                bencher.run(harness)\n            });\n        }\n        StaticBenchFn(benchfn) =\u003e {\n            // Benchmarks aren't expected to panic, so we run them all in-process.\n            crate::bench::benchmark(desc, monitor_ch, opts.nocapture, benchfn);\n        }\n        DynTestFn(f) =\u003e {\n            match strategy {\n                RunStrategy::InProcess =\u003e (),\n                _ =\u003e panic!(\"Cannot run dynamic test fn out-of-process\"),\n            };\n            run_test_inner(\n                desc,\n                monitor_ch,\n                Box::new(move || __rust_begin_short_backtrace(f)),\n                test_run_opts,\n            );\n        }\n        StaticTestFn(f) =\u003e run_test_inner(\n            desc,\n            monitor_ch,\n            Box::new(move || __rust_begin_short_backtrace(f)),\n            test_run_opts,\n        ),\n    }\n}\n\n/// Fixed frame used to clean the backtrace with `RUST_BACKTRACE=1`.\n#[inline(never)]\nfn __rust_begin_short_backtrace\u003cF: FnOnce()\u003e(f: F) {\n    f()\n}\n\nfn run_test_in_process(\n    desc: TestDesc,\n    nocapture: bool,\n    report_time: bool,\n    testfn: Box\u003cdyn FnOnce() + Send\u003e,\n    monitor_ch: Sender\u003cCompletedTest\u003e,\n    time_opts: Option\u003ctime::TestTimeOptions\u003e,\n) {\n    // Buffer for capturing standard I/O\n    let data = Arc::new(Mutex::new(Vec::new()));\n\n    let oldio = if !nocapture {\n        Some((\n            io::set_print(Some(Sink::new_boxed(\u0026data))),\n            io::set_panic(Some(Sink::new_boxed(\u0026data))),\n        ))\n    } else {\n        None\n    };\n\n    let start = report_time.then(Instant::now);\n    let result = catch_unwind(AssertUnwindSafe(testfn));\n    let exec_time = start.map(|start| {\n        let duration = start.elapsed();\n        TestExecTime(duration)\n    });\n\n    if let Some((printio, panicio)) = oldio {\n        io::set_print(printio);\n        io::set_panic(panicio);\n    }\n\n    let test_result = match result {\n        Ok(()) =\u003e calc_result(\u0026desc, Ok(()), \u0026time_opts, \u0026exec_time),\n        Err(e) =\u003e calc_result(\u0026desc, Err(e.as_ref()), \u0026time_opts, \u0026exec_time),\n    };\n    let stdout = data.lock().unwrap().to_vec();\n    let message = CompletedTest::new(desc, test_result, exec_time, stdout);\n    monitor_ch.send(message).unwrap();\n}\n\nfn spawn_test_subprocess(\n    desc: TestDesc,\n    nocapture: bool,\n    report_time: bool,\n    monitor_ch: Sender\u003cCompletedTest\u003e,\n    time_opts: Option\u003ctime::TestTimeOptions\u003e,\n) {\n    let (result, test_output, exec_time) = (|| {\n        let args = env::args().collect::\u003cVec\u003c_\u003e\u003e();\n        let current_exe = \u0026args[0];\n\n        let mut command = Command::new(current_exe);\n        command.env(SECONDARY_TEST_INVOKER_VAR, desc.name.as_slice());\n        if nocapture {\n            command.stdout(process::Stdio::inherit());\n            command.stderr(process::Stdio::inherit());\n        }\n\n        let start = report_time.then(Instant::now);\n        let output = match command.output() {\n            Ok(out) =\u003e out,\n            Err(e) =\u003e {\n                let err = format!(\"Failed to spawn {} as child for test: {:?}\", args[0], e);\n                return (TrFailed, err.into_bytes(), None);\n            }\n        };\n        let exec_time = start.map(|start| {\n            let duration = start.elapsed();\n            TestExecTime(duration)\n        });\n\n        let std::process::Output { stdout, stderr, status } = output;\n        let mut test_output = stdout;\n        formatters::write_stderr_delimiter(\u0026mut test_output, \u0026desc.name);\n        test_output.extend_from_slice(\u0026stderr);\n\n        let result = match (|| -\u003e Result\u003cTestResult, String\u003e {\n            let exit_code = get_exit_code(status)?;\n            Ok(get_result_from_exit_code(\u0026desc, exit_code, \u0026time_opts, \u0026exec_time))\n        })() {\n            Ok(r) =\u003e r,\n            Err(e) =\u003e {\n                write!(\u0026mut test_output, \"Unexpected error: {}\", e).unwrap();\n                TrFailed\n            }\n        };\n\n        (result, test_output, exec_time)\n    })();\n\n    let message = CompletedTest::new(desc, result, exec_time, test_output);\n    monitor_ch.send(message).unwrap();\n}\n\nfn run_test_in_spawned_subprocess(desc: TestDesc, testfn: Box\u003cdyn FnOnce() + Send\u003e) -\u003e ! {\n    let builtin_panic_hook = panic::take_hook();\n    let record_result = Arc::new(move |panic_info: Option\u003c\u0026'_ PanicInfo\u003c'_\u003e\u003e| {\n        let test_result = match panic_info {\n            Some(info) =\u003e calc_result(\u0026desc, Err(info.payload()), \u0026None, \u0026None),\n            None =\u003e calc_result(\u0026desc, Ok(()), \u0026None, \u0026None),\n        };\n\n        // We don't support serializing TrFailedMsg, so just\n        // print the message out to stderr.\n        if let TrFailedMsg(msg) = \u0026test_result {\n            eprintln!(\"{}\", msg);\n        }\n\n        if let Some(info) = panic_info {\n            builtin_panic_hook(info);\n        }\n\n        if let TrOk = test_result {\n            process::exit(test_result::TR_OK);\n        } else {\n            process::exit(test_result::TR_FAILED);\n        }\n    });\n    let record_result2 = record_result.clone();\n    panic::set_hook(Box::new(move |info| record_result2(Some(\u0026info))));\n    testfn();\n    record_result(None);\n    unreachable!(\"panic=abort callback should have exited the process\")\n}\n","traces":[{"line":189,"address":[4211424],"length":1,"stats":{"Line":1},"fn_name":"assert_test_result\u003c()\u003e"},{"line":190,"address":[4211431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[4211576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[4211596],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[4211528],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":3,"coverable":5},{"path":["/","workspaces","blinky","src","main.rs"],"content":"//! A basic blinky application. The purpose of this application is to serve as an easy starting point\n//! for embedded rust projects. Be sure to read the `README.md`. It gives usefull information for how\n//! to quickly get your environment up and running within vscode and illustrates some useful tools\n//! such as a debugger and a way to flash your microcontroller. All of these tools ship with docker\n//! container and have been .\n#![cfg_attr(feature = \"embedded_platform\", no_std)]\n#![cfg_attr(feature = \"embedded_platform\", no_main)]\n\n#[cfg(feature = \"embedded_platform\")] \nuse cortex_m_rt::entry;\n\n#[cfg(feature = \"stm32f407\")]\nuse stm32f4xx_hal as hal;\n\n#[cfg(feature = \"st_board\")]\nuse hal::{\n    prelude::*,\n    stm32 as board,\n};\n\n#[cfg_attr(feature = \"embedded_platform\", allow(unused_imports))]\n#[cfg(feature = \"embedded_platform\")]\nuse panic_halt;\n\n// NOTE(allow) bug rust-lang/rust#53964\n#[cfg_attr(feature = \"embedded_platform\", entry)]\n#[cfg(feature = \"embedded_platform\")]\nfn main() -\u003e ! {\n    let board_peripherals = board::Peripherals::take().unwrap();\n    let processor_peripherals = cortex_m::Peripherals::take().unwrap();\n    \n    // Setting system clock speed\n    let clock_controler = board_peripherals.RCC.constrain();\n    let system_clock = clock_controler.cfgr.sysclk(48.mhz()).freeze();\n\n    let mut delay = hal::delay::Delay::new(processor_peripherals.SYST, system_clock);\n\n    let mut led2 = board_peripherals.GPIOG.split().pg13.into_push_pull_output();\n\n    loop {\n        // On for 1s, off for 1s\n        led2.set_high().unwrap();\n        delay.delay_ms(1000_u32);\n        led2.set_low().unwrap();\n        delay.delay_ms(1000_u32);\n    }\n}\n\nfn add_two(x: u32) -\u003e u32 {\n    x + 2\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn add_two_good_value() {\n        assert_eq!(2, add_two(0));\n    }\n}\n","traces":[{"line":49,"address":[4213648],"length":1,"stats":{"Line":1},"fn_name":"add_two"},{"line":50,"address":[4213701,4213653,4213671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[4211317,4211312],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":59,"address":[4213257,4213360],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":4,"coverable":4}]};
    </script>
    <script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, pathToString(file.path)),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>